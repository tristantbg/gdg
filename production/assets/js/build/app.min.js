!function(t){var n={};function e(l){if(n[l])return n[l].exports;var c=n[l]={i:l,l:!1,exports:{}};return t[l].call(c.exports,c,c.exports,e),c.l=!0,c.exports}e.m=t,e.c=n,e.d=function(t,n,l){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:l})},e.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s="./src/js/app.js")}({"./node_modules/@egjs/component/dist/component.module.js":function(module,exports,__webpack_require__){eval('/*!\n * Copyright (c) 2017 NAVER Corp.\r\n * @egjs/component project is licensed under the MIT license\r\n * \r\n * @egjs/component JavaScript library\r\n * http://naver.github.io/egjs/component\r\n * \r\n * @version 2.1.1\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n * @alias eg.Component\n */\nvar Component = function () {\n\t/**\n  * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}\n  */\n\tfunction Component() {\n\t\t_classCallCheck(this, Component);\n\n\t\tthis._eventHandler = {};\n\t\tthis.options = {};\n\t}\n\t/**\n  * Triggers a custom event.\n  * @ko 커스텀 이벤트를 발생시킨다\n  * @param {String} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>\n  * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n  * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">Ref</a> <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 \'false\'를 반환하고 이벤트 발생을 중단한다. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">참고</a></ko>\n  * @example\n class Some extends eg.Component {\n  some(){\n  \tif(this.trigger("beforeHi")){ // When event call to stop return false.\n \tthis.trigger("hi");// fire hi event.\n  \t}\n  }\n }\n const some = new Some();\n some.on("beforeHi", (e) => {\n if(condition){\n \te.stop(); // When event call to stop, `hi` event not call.\n }\n });\n some.on("hi", (e) => {\n // `currentTarget` is component instance.\n console.log(some === e.currentTarget); // true\n });\n // If you want to more know event design. You can see article.\n // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n  */\n\n\n\tComponent.prototype.trigger = function trigger(eventName) {\n\t\tvar customEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tvar handlerList = this._eventHandler[eventName] || [];\n\t\tvar hasHandlerList = handlerList.length > 0;\n\n\t\tif (!hasHandlerList) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If detach method call in handler in first time then handler list calls.\n\t\thandlerList = handlerList.concat();\n\n\t\tcustomEvent.eventType = eventName;\n\n\t\tvar isCanceled = false;\n\t\tvar arg = [customEvent];\n\t\tvar i = 0;\n\n\t\tcustomEvent.stop = function () {\n\t\t\tisCanceled = true;\n\t\t};\n\t\tcustomEvent.currentTarget = this;\n\n\t\tfor (var _len = arguments.length, restParam = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t\trestParam[_key - 2] = arguments[_key];\n\t\t}\n\n\t\tif (restParam.length >= 1) {\n\t\t\targ = arg.concat(restParam);\n\t\t}\n\n\t\tfor (i = 0; handlerList[i]; i++) {\n\t\t\thandlerList[i].apply(this, arg);\n\t\t}\n\n\t\treturn !isCanceled;\n\t};\n\t/**\n  * Executed event just one time.\n  * @ko 이벤트가 한번만 실행된다.\n  * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    alert("hi");\n  }\n  thing() {\n    this.once("hi", this.hi);\n  }\n }\n var some = new Some();\n some.thing();\n some.trigger("hi");\n // fire alert("hi");\n some.trigger("hi");\n // Nothing happens\n  */\n\n\n\tComponent.prototype.once = function once(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === "undefined" ? "undefined" : _typeof(eventName)) === "object" && typeof handlerToAttach === "undefined") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar i = void 0;\n\n\t\t\tfor (i in eventHash) {\n\t\t\t\tthis.once(i, eventHash[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n\t\t\tvar self = this;\n\n\t\t\tthis.on(eventName, function listener() {\n\t\t\t\tfor (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\targ[_key2] = arguments[_key2];\n\t\t\t\t}\n\n\t\t\t\thandlerToAttach.apply(self, arg);\n\t\t\t\tself.off(eventName, listener);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Checks whether an event has been attached to a component.\n  * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n  * @param {String} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n  * @return {Boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n  * @example\n class Some extends eg.Component {\n  some() {\n    this.hasOn("hi");// check hi event.\n  }\n }\n  */\n\n\n\tComponent.prototype.hasOn = function hasOn(eventName) {\n\t\treturn !!this._eventHandler[eventName];\n\t};\n\n\t/**\n  * Attaches an event to a component.\n  * @ko 컴포넌트에 이벤트를 등록한다.\n  * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log("hi");\n  }\n  some() {\n    this.on("hi",this.hi); //attach event\n  }\n }\n */\n\n\n\tComponent.prototype.on = function on(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === "undefined" ? "undefined" : _typeof(eventName)) === "object" && typeof handlerToAttach === "undefined") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar name = void 0;\n\n\t\t\tfor (name in eventHash) {\n\t\t\t\tthis.on(name, eventHash[name]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === "string" && typeof handlerToAttach === "function") {\n\t\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\t\tif (typeof handlerList === "undefined") {\n\t\t\t\tthis._eventHandler[eventName] = [];\n\t\t\t\thandlerList = this._eventHandler[eventName];\n\t\t\t}\n\n\t\t\thandlerList.push(handlerToAttach);\n\t\t}\n\n\t\treturn this;\n\t};\n\t/**\n  * Detaches an event from the component.\n  * @ko 컴포넌트에 등록된 이벤트를 해제한다\n  * @param {eventName} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n  * @param {Function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n  * @return {eg.Component} An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log("hi");\n  }\n  some() {\n    this.off("hi",this.hi); //detach event\n  }\n }\n  */\n\n\n\tComponent.prototype.off = function off(eventName, handlerToDetach) {\n\t\t// All event detach.\n\t\tif (typeof eventName === "undefined") {\n\t\t\tthis._eventHandler = {};\n\t\t\treturn this;\n\t\t}\n\n\t\t// All handler of specific event detach.\n\t\tif (typeof handlerToDetach === "undefined") {\n\t\t\tif (typeof eventName === "string") {\n\t\t\t\tthis._eventHandler[eventName] = undefined;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\tvar eventHash = eventName;\n\t\t\t\tvar name = void 0;\n\n\t\t\t\tfor (name in eventHash) {\n\t\t\t\t\tthis.off(name, eventHash[name]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// The handler of specific event detach.\n\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\tif (handlerList) {\n\t\t\tvar k = void 0;\n\t\t\tvar handlerFunction = void 0;\n\n\t\t\tfor (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {\n\t\t\t\tif (handlerFunction === handlerToDetach) {\n\t\t\t\t\thandlerList = handlerList.splice(k, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\treturn Component;\n}();\n\nexports["default"] = Component;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _Component = __webpack_require__(0);\n\nvar _Component2 = _interopRequireDefault(_Component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\n_Component2["default"].VERSION = "2.1.1";\n\nexports["default"] = _Component2["default"];\nmodule.exports = exports["default"];\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=component.module.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50Lm1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZWdqcy9jb21wb25lbnQvZGlzdC9jb21wb25lbnQubW9kdWxlLmpzPzAyZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgTkFWRVIgQ29ycC5cclxuICogQGVnanMvY29tcG9uZW50IHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIFxyXG4gKiBAZWdqcy9jb21wb25lbnQgSmF2YVNjcmlwdCBsaWJyYXJ5XHJcbiAqIGh0dHA6Ly9uYXZlci5naXRodWIuaW8vZWdqcy9jb21wb25lbnRcclxuICogXHJcbiAqIEB2ZXJzaW9uIDIuMS4xXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNvbXBvbmVudFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlZ1wiXSA9IHJvb3RbXCJlZ1wiXSB8fCB7fSwgcm9vdFtcImVnXCJdW1wiQ29tcG9uZW50XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEEgY2xhc3MgdXNlZCB0byBtYW5hZ2UgZXZlbnRzIGluIGEgY29tcG9uZW50XG4gKiBAa28g7Lu07Y+s64SM7Yq47J2YIOydtOuypO2KuOydhCDqtIDrpqztlaAg7IiYIOyeiOqyjCDtlZjripQg7YG0656Y7IqkXG4gKiBAYWxpYXMgZWcuQ29tcG9uZW50XG4gKi9cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdC8qKlxuICAqIEBzdXBwb3J0IHtcImllXCI6IFwiNytcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjErIChleGNlcHQgMy54KVwifVxuICAqL1xuXHRmdW5jdGlvbiBDb21wb25lbnQoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudCk7XG5cblx0XHR0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcblx0XHR0aGlzLm9wdGlvbnMgPSB7fTtcblx0fVxuXHQvKipcbiAgKiBUcmlnZ2VycyBhIGN1c3RvbSBldmVudC5cbiAgKiBAa28g7Luk7Iqk7YWAIOydtOuypO2KuOulvCDrsJzsg53si5ztgqjri6RcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgdG8gYmUgdHJpZ2dlcmVkIDxrbz7rsJzsg53tlaAg7Luk7Iqk7YWAIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21FdmVudCBFdmVudCBkYXRhIHRvIGJlIHNlbnQgd2hlbiB0cmlnZ2VyaW5nIGEgY3VzdG9tIGV2ZW50IDxrbz7su6TsiqTthYAg7J2067Kk7Yq46rCAIOuwnOyDne2VoCDrlYwg7KCE64us7ZWgIOuNsOydtO2EsDwva28+XG4gICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IGhhcyBvY2N1cnJlZC4gSWYgdGhlIHN0b3AoKSBtZXRob2QgaXMgY2FsbGVkIGJ5IGEgY3VzdG9tIGV2ZW50IGhhbmRsZXIsIGl0IHdpbGwgcmV0dXJuIGZhbHNlIGFuZCBwcmV2ZW50IHRoZSBldmVudCBmcm9tIG9jY3VycmluZy4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudC93aWtpL0hvdy10by1tYWtlLUNvbXBvbmVudC1ldmVudC1kZXNpZ24lM0ZcIj5SZWY8L2E+IDxrbz7snbTrsqTtirgg67Cc7IOdIOyXrOu2gC4g7Luk7Iqk7YWAIOydtOuypO2KuCDtlbjrk6Trn6zsl5DshJwgc3RvcCgpIOuplOyEnOuTnOulvCDtmLjstpztlZjrqbQgJ2ZhbHNlJ+ulvCDrsJjtmZjtlZjqs6Ag7J2067Kk7Yq4IOuwnOyDneydhCDspJHri6jtlZzri6QuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnQvd2lraS9Ib3ctdG8tbWFrZS1Db21wb25lbnQtZXZlbnQtZGVzaWduJTNGXCI+7LC46rOgPC9hPjwva28+XG4gICogQGV4YW1wbGVcbiBjbGFzcyBTb21lIGV4dGVuZHMgZWcuQ29tcG9uZW50IHtcbiAgc29tZSgpe1xuICBcdGlmKHRoaXMudHJpZ2dlcihcImJlZm9yZUhpXCIpKXsgLy8gV2hlbiBldmVudCBjYWxsIHRvIHN0b3AgcmV0dXJuIGZhbHNlLlxuIFx0dGhpcy50cmlnZ2VyKFwiaGlcIik7Ly8gZmlyZSBoaSBldmVudC5cbiAgXHR9XG4gIH1cbiB9XG4gY29uc3Qgc29tZSA9IG5ldyBTb21lKCk7XG4gc29tZS5vbihcImJlZm9yZUhpXCIsIChlKSA9PiB7XG4gaWYoY29uZGl0aW9uKXtcbiBcdGUuc3RvcCgpOyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCwgYGhpYCBldmVudCBub3QgY2FsbC5cbiB9XG4gfSk7XG4gc29tZS5vbihcImhpXCIsIChlKSA9PiB7XG4gLy8gYGN1cnJlbnRUYXJnZXRgIGlzIGNvbXBvbmVudCBpbnN0YW5jZS5cbiBjb25zb2xlLmxvZyhzb21lID09PSBlLmN1cnJlbnRUYXJnZXQpOyAvLyB0cnVlXG4gfSk7XG4gLy8gSWYgeW91IHdhbnQgdG8gbW9yZSBrbm93IGV2ZW50IGRlc2lnbi4gWW91IGNhbiBzZWUgYXJ0aWNsZS5cbiAvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnQvd2lraS9Ib3ctdG8tbWFrZS1Db21wb25lbnQtZXZlbnQtZGVzaWduJTNGXG4gICovXG5cblxuXHRDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50TmFtZSkge1xuXHRcdHZhciBjdXN0b21FdmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblx0XHR2YXIgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSB8fCBbXTtcblx0XHR2YXIgaGFzSGFuZGxlckxpc3QgPSBoYW5kbGVyTGlzdC5sZW5ndGggPiAwO1xuXG5cdFx0aWYgKCFoYXNIYW5kbGVyTGlzdCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgZGV0YWNoIG1ldGhvZCBjYWxsIGluIGhhbmRsZXIgaW4gZmlyc3QgdGltZSB0aGVuIGhhbmRsZXIgbGlzdCBjYWxscy5cblx0XHRoYW5kbGVyTGlzdCA9IGhhbmRsZXJMaXN0LmNvbmNhdCgpO1xuXG5cdFx0Y3VzdG9tRXZlbnQuZXZlbnRUeXBlID0gZXZlbnROYW1lO1xuXG5cdFx0dmFyIGlzQ2FuY2VsZWQgPSBmYWxzZTtcblx0XHR2YXIgYXJnID0gW2N1c3RvbUV2ZW50XTtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRjdXN0b21FdmVudC5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aXNDYW5jZWxlZCA9IHRydWU7XG5cdFx0fTtcblx0XHRjdXN0b21FdmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0UGFyYW0gPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0XHRyZXN0UGFyYW1bX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuXHRcdH1cblxuXHRcdGlmIChyZXN0UGFyYW0ubGVuZ3RoID49IDEpIHtcblx0XHRcdGFyZyA9IGFyZy5jb25jYXQocmVzdFBhcmFtKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBoYW5kbGVyTGlzdFtpXTsgaSsrKSB7XG5cdFx0XHRoYW5kbGVyTGlzdFtpXS5hcHBseSh0aGlzLCBhcmcpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhaXNDYW5jZWxlZDtcblx0fTtcblx0LyoqXG4gICogRXhlY3V0ZWQgZXZlbnQganVzdCBvbmUgdGltZS5cbiAgKiBAa28g7J2067Kk7Yq46rCAIO2VnOuyiOunjCDsi6TtlonrkJzri6QuXG4gICogQHBhcmFtIHtldmVudE5hbWV9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyVG9BdHRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAqIEByZXR1cm4ge2VnLkNvbXBvbmVudH0gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAZXhhbXBsZVxuIGNsYXNzIFNvbWUgZXh0ZW5kcyBlZy5Db21wb25lbnQge1xuICBoaSgpIHtcbiAgICBhbGVydChcImhpXCIpO1xuICB9XG4gIHRoaW5nKCkge1xuICAgIHRoaXMub25jZShcImhpXCIsIHRoaXMuaGkpO1xuICB9XG4gfVxuIHZhciBzb21lID0gbmV3IFNvbWUoKTtcbiBzb21lLnRoaW5nKCk7XG4gc29tZS50cmlnZ2VyKFwiaGlcIik7XG4gLy8gZmlyZSBhbGVydChcImhpXCIpO1xuIHNvbWUudHJpZ2dlcihcImhpXCIpO1xuIC8vIE5vdGhpbmcgaGFwcGVuc1xuICAqL1xuXG5cblx0Q29tcG9uZW50LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuXHRcdGlmICgodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV2ZW50TmFtZSkpID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG5cdFx0XHR2YXIgaSA9IHZvaWQgMDtcblxuXHRcdFx0Zm9yIChpIGluIGV2ZW50SGFzaCkge1xuXHRcdFx0XHR0aGlzLm9uY2UoaSwgZXZlbnRIYXNoW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdFx0dGhpcy5vbihldmVudE5hbWUsIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuXHRcdFx0XHRmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdFx0XHRcdFx0YXJnW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoYW5kbGVyVG9BdHRhY2guYXBwbHkoc2VsZiwgYXJnKTtcblx0XHRcdFx0c2VsZi5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcbiAgKiBDaGVja3Mgd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiBhdHRhY2hlZCB0byBhIGNvbXBvbmVudC5cbiAgKiBAa28g7Lu07Y+s64SM7Yq47JeQIOydtOuypO2KuOqwgCDrk7HroZ3rkJDripTsp4Ag7ZmV7J247ZWc64ukLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ0g7Jes67aA66W8IO2ZleyduO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgaXMgYXR0YWNoZWQuIDxrbz7snbTrsqTtirgg65Ox66GdIOyXrOu2gDwva28+XG4gICogQGV4YW1wbGVcbiBjbGFzcyBTb21lIGV4dGVuZHMgZWcuQ29tcG9uZW50IHtcbiAgc29tZSgpIHtcbiAgICB0aGlzLmhhc09uKFwiaGlcIik7Ly8gY2hlY2sgaGkgZXZlbnQuXG4gIH1cbiB9XG4gICovXG5cblxuXHRDb21wb25lbnQucHJvdG90eXBlLmhhc09uID0gZnVuY3Rpb24gaGFzT24oZXZlbnROYW1lKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG5cdH07XG5cblx0LyoqXG4gICogQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBjb21wb25lbnQuXG4gICogQGtvIOy7tO2PrOuEjO2KuOyXkCDsnbTrsqTtirjrpbwg65Ox66Gd7ZWc64ukLlxuICAqIEBwYXJhbSB7ZXZlbnROYW1lfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIOydtOumhDwva28+XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5Db21wb25lbnR9IEFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICogQGV4YW1wbGVcbiBjbGFzcyBTb21lIGV4dGVuZHMgZWcuQ29tcG9uZW50IHtcbiAgaGkoKSB7XG4gICAgY29uc29sZS5sb2coXCJoaVwiKTtcbiAgfVxuICBzb21lKCkge1xuICAgIHRoaXMub24oXCJoaVwiLHRoaXMuaGkpOyAvL2F0dGFjaCBldmVudFxuICB9XG4gfVxuICovXG5cblxuXHRDb21wb25lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcblx0XHRpZiAoKHR5cGVvZiBldmVudE5hbWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihldmVudE5hbWUpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuXHRcdFx0dmFyIG5hbWUgPSB2b2lkIDA7XG5cblx0XHRcdGZvciAobmFtZSBpbiBldmVudEhhc2gpIHtcblx0XHRcdFx0dGhpcy5vbihuYW1lLCBldmVudEhhc2hbbmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG5cblx0XHRcdGlmICh0eXBlb2YgaGFuZGxlckxpc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0dGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV0gPSBbXTtcblx0XHRcdFx0aGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcblx0XHRcdH1cblxuXHRcdFx0aGFuZGxlckxpc3QucHVzaChoYW5kbGVyVG9BdHRhY2gpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcbiAgKiBEZXRhY2hlcyBhbiBldmVudCBmcm9tIHRoZSBjb21wb25lbnQuXG4gICogQGtvIOy7tO2PrOuEjO2KuOyXkCDrk7HroZ3rkJwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpFxuICAqIEBwYXJhbSB7ZXZlbnROYW1lfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGRldGFjaGVkIDxrbz7tlbTsoJztlaAg7J2067Kk7Yq47J2YIOydtOumhDwva28+XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclRvRGV0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5Db21wb25lbnR9IEFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGl0c2VsZiA8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqIEBleGFtcGxlXG4gY2xhc3MgU29tZSBleHRlbmRzIGVnLkNvbXBvbmVudCB7XG4gIGhpKCkge1xuICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gIH1cbiAgc29tZSgpIHtcbiAgICB0aGlzLm9mZihcImhpXCIsdGhpcy5oaSk7IC8vZGV0YWNoIGV2ZW50XG4gIH1cbiB9XG4gICovXG5cblxuXHRDb21wb25lbnQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudE5hbWUsIGhhbmRsZXJUb0RldGFjaCkge1xuXHRcdC8vIEFsbCBldmVudCBkZXRhY2guXG5cdFx0aWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHRoaXMuX2V2ZW50SGFuZGxlciA9IHt9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGhhbmRsZXIgb2Ygc3BlY2lmaWMgZXZlbnQgZGV0YWNoLlxuXHRcdGlmICh0eXBlb2YgaGFuZGxlclRvRGV0YWNoID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuXHRcdFx0XHR2YXIgbmFtZSA9IHZvaWQgMDtcblxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gZXZlbnRIYXNoKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYobmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUaGUgaGFuZGxlciBvZiBzcGVjaWZpYyBldmVudCBkZXRhY2guXG5cdFx0dmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG5cblx0XHRpZiAoaGFuZGxlckxpc3QpIHtcblx0XHRcdHZhciBrID0gdm9pZCAwO1xuXHRcdFx0dmFyIGhhbmRsZXJGdW5jdGlvbiA9IHZvaWQgMDtcblxuXHRcdFx0Zm9yIChrID0gMDsgKGhhbmRsZXJGdW5jdGlvbiA9IGhhbmRsZXJMaXN0W2tdKSAhPT0gdW5kZWZpbmVkOyBrKyspIHtcblx0XHRcdFx0aWYgKGhhbmRsZXJGdW5jdGlvbiA9PT0gaGFuZGxlclRvRGV0YWNoKSB7XG5cdFx0XHRcdFx0aGFuZGxlckxpc3QgPSBoYW5kbGVyTGlzdC5zcGxpY2UoaywgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbXBvbmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Db21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX0NvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db21wb25lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuX0NvbXBvbmVudDJbXCJkZWZhdWx0XCJdLlZFUlNJT04gPSBcIjIuMS4xXCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX0NvbXBvbmVudDJbXCJkZWZhdWx0XCJdO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnQubW9kdWxlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@egjs/component/dist/component.module.js\n')},"./node_modules/@egjs/infinitegrid/dist/infinitegrid.module.js":function(module,exports,__webpack_require__){eval('/*!\n * Copyright (c) 2017 NAVER Corp.\r\n * @egjs/infinitegrid project is licensed under the MIT license\r\n * \r\n * @egjs/infinitegrid JavaScript library\r\n * https://github.com/naver/egjs-infinitegrid\r\n * \r\n * @version 3.3.1\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! @egjs/component */ "./node_modules/@egjs/component/dist/component.module.js"));\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_12__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 10);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\nexports.STYLE = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nexports.toArray = toArray;\nexports.matchHTML = matchHTML;\nexports.$ = $;\nexports.addEvent = addEvent;\nexports.removeEvent = removeEvent;\nexports.scroll = scroll;\nexports.scrollTo = scrollTo;\nexports.scrollBy = scrollBy;\nexports.getStyles = getStyles;\nexports.innerWidth = innerWidth;\nexports.innerHeight = innerHeight;\nexports.getStyleNames = getStyleNames;\nexports.assignOptions = assignOptions;\nexports.toZeroArray = toZeroArray;\nexports.cloneItems = cloneItems;\nexports.isWindow = isWindow;\nexports.fill = fill;\nexports.isUndefined = isUndefined;\n\nvar _browser = __webpack_require__(2);\n\nvar _consts = __webpack_require__(1);\n\nfunction toArray(nodes) {\n\t// SCRIPT5014 in IE8\n\tvar array = [];\n\n\tif (nodes) {\n\t\tfor (var i = 0, len = nodes.length; i < len; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nfunction matchHTML(html) {\n\treturn html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nfunction $(param) {\n\tvar multi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\tvar el = void 0;\n\n\tif (typeof param === "string") {\n\t\t// String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tvar match = matchHTML(param);\n\n\t\t// creating element\n\t\tif (match) {\n\t\t\t// HTML\n\t\t\tvar dummy = _browser.document.createElement("div");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = dummy.childNodes;\n\t\t} else {\n\t\t\t// Selector\n\t\t\tel = _browser.document.querySelectorAll(param);\n\t\t}\n\t\tif (multi) {\n\t\t\tel = toArray(el);\n\t\t} else {\n\t\t\tel = el && el.length > 0 && el[0] || undefined;\n\t\t}\n\t} else if (param === _browser.window) {\n\t\t// window\n\t\tel = param;\n\t} else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n\t\t// HTMLElement, Document\n\t\tel = param;\n\t} else if ("jQuery" in _browser.window && param instanceof _browser.window.jQuery || param.constructor.prototype.jquery) {\n\t\t// jQuery\n\t\tel = $(multi ? param.toArray() : param.get(0), multi);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(function (v) {\n\t\t\treturn $(v);\n\t\t});\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t}\n\t}\n\treturn el;\n}\nfunction addEvent(element, type, handler, eventListenerOptions) {\n\tif (_consts.SUPPORT_ADDEVENTLISTENER) {\n\t\tvar options = eventListenerOptions || false;\n\n\t\tif ((typeof eventListenerOptions === "undefined" ? "undefined" : _typeof(eventListenerOptions)) === "object") {\n\t\t\toptions = _consts.SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if (element.attachEvent) {\n\t\telement.attachEvent("on" + type, handler);\n\t} else {\n\t\telement["on" + type] = handler;\n\t}\n}\nfunction removeEvent(element, type, handler) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if (element.detachEvent) {\n\t\telement.detachEvent("on" + type, handler);\n\t} else {\n\t\telement["on" + type] = null;\n\t}\n}\nfunction scroll(el) {\n\tvar horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\tvar prop = "scroll" + (horizontal ? "Left" : "Top");\n\n\tif (el === _browser.window) {\n\t\treturn _browser.window[horizontal ? "pageXOffset" : "pageYOffset"] || _browser.document.body[prop] || _browser.document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nfunction scrollTo(el, x, y) {\n\tif (el === _browser.window) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nfunction scrollBy(el, x, y) {\n\tif (el === _browser.window) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nfunction getStyles(el) {\n\treturn _consts.SUPPORT_COMPUTEDSTYLE ? _browser.window.getComputedStyle(el) : el.currentStyle;\n}\nfunction _getSize(el, name) {\n\tif (el === _browser.window) {\n\t\t// WINDOW\n\t\treturn _browser.window["inner" + name] || _browser.document.body["client" + name];\n\t} else if (el.nodeType === 9) {\n\t\t// DOCUMENT_NODE\n\t\tvar doc = el.documentElement;\n\n\t\treturn Math.max(el.body["scroll" + name], doc["scroll" + name], el.body["offset" + name], doc["offset" + name], doc["client" + name]);\n\t} else {\n\t\t// NODE\n\t\tvar style = getStyles(el);\n\t\tvar value = style[name.toLowerCase()];\n\n\t\treturn parseFloat(/auto|%/.test(value) ? el["offset" + name] : style[name.toLowerCase()]);\n\t}\n}\nfunction innerWidth(el) {\n\treturn _getSize(el, "Width");\n}\nfunction innerHeight(el) {\n\treturn _getSize(el, "Height");\n}\nvar STYLE = exports.STYLE = {\n\tvertical: {\n\t\tpos1: "top",\n\t\tendPos1: "bottom",\n\t\tsize1: "height",\n\t\tpos2: "left",\n\t\tendPos2: "right",\n\t\tsize2: "width"\n\t},\n\thorizontal: {\n\t\tpos1: "left",\n\t\tendPos1: "right",\n\t\tsize1: "width",\n\t\tpos2: "top",\n\t\tendPos2: "bottom",\n\t\tsize2: "height"\n\t}\n};\n\nfunction getStyleNames(isHorizontal) {\n\treturn STYLE[isHorizontal ? _consts.HORIZONTAL : _consts.VERTICAL];\n}\n\nfunction assignOptions(defaultOptions, options) {\n\treturn _extends({}, _consts.DEFAULT_OPTIONS, defaultOptions, options);\n}\n\nfunction toZeroArray(outline) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\nfunction cloneItems(items) {\n\treturn items.map(function (item) {\n\t\treturn _extends({}, item);\n\t});\n}\nfunction isWindow(el) {\n\treturn el === _browser.window;\n}\n\nfunction fill(arr, value) {\n\tvar length = arr.length;\n\n\tfor (var i = length - 1; i >= 0; --i) {\n\t\tarr[i] = value;\n\t}\n\n\treturn arr;\n}\n\nfunction isUndefined(target) {\n\treturn typeof target === "undefined";\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\nexports.DEFENSE_BROWSER = exports.WEBKIT_VERSION = exports.PROCESSING = exports.LOADING_PREPEND = exports.LOADING_APPEND = exports.IDLE = exports.ALIGN = exports.isMobile = exports.agent = exports.DEFAULT_OPTIONS = exports.GROUPKEY_ATT = exports.DUMMY_POSITION = exports.SINGLE = exports.MULTI = exports.NO_TRUSTED = exports.TRUSTED = exports.NO_CACHE = exports.CACHE = exports.HORIZONTAL = exports.VERTICAL = exports.PREPEND = exports.APPEND = exports.IGNORE_CLASSNAME = exports.CONTAINER_CLASSNAME = exports.RETRY = exports.IS_ANDROID2 = exports.IS_IOS = exports.IS_IE = exports.SUPPORT_PASSIVE = exports.SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_COMPUTEDSTYLE = undefined;\n\nvar _browser = __webpack_require__(2);\n\nvar ua = _browser.window.navigator.userAgent;\n\nvar SUPPORT_COMPUTEDSTYLE = exports.SUPPORT_COMPUTEDSTYLE = !!("getComputedStyle" in _browser.window);\nvar SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_ADDEVENTLISTENER = !!("addEventListener" in document);\nvar SUPPORT_PASSIVE = exports.SUPPORT_PASSIVE = function () {\n\tvar supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\tdocument.addEventListener("test", null, Object.defineProperty({}, "passive", {\n\t\t\t\tget: function get() {\n\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t} catch (e) {}\n\treturn supportsPassiveOption;\n}();\n\nvar IS_IE = exports.IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar IS_IOS = exports.IS_IOS = /iPhone|iPad/.test(ua);\nvar IS_ANDROID2 = exports.IS_ANDROID2 = /Android 2\\./.test(ua);\nvar RETRY = exports.RETRY = 3;\nvar CONTAINER_CLASSNAME = exports.CONTAINER_CLASSNAME = "_eg-infinitegrid-container_";\nvar IGNORE_CLASSNAME = exports.IGNORE_CLASSNAME = "_eg-infinitegrid-ignore_";\n\nvar APPEND = exports.APPEND = true;\nvar PREPEND = exports.PREPEND = false;\nvar VERTICAL = exports.VERTICAL = "vertical";\nvar HORIZONTAL = exports.HORIZONTAL = "horizontal";\nvar CACHE = exports.CACHE = true;\nvar NO_CACHE = exports.NO_CACHE = false;\nvar TRUSTED = exports.TRUSTED = true;\nvar NO_TRUSTED = exports.NO_TRUSTED = false;\nvar MULTI = exports.MULTI = true;\nvar SINGLE = exports.SINGLE = false;\nvar DUMMY_POSITION = exports.DUMMY_POSITION = -100000;\nvar GROUPKEY_ATT = exports.GROUPKEY_ATT = "data-groupkey";\n\nvar DEFAULT_OPTIONS = exports.DEFAULT_OPTIONS = {\n\thorizontal: false,\n\tmargin: 0\n};\n\nvar agent = exports.agent = ua.toLowerCase();\nvar isMobile = exports.isMobile = /mobi|ios|android/.test(agent);\n\nvar ALIGN = exports.ALIGN = {\n\tSTART: "start",\n\tCENTER: "center",\n\tEND: "end",\n\tJUSTIFY: "justify"\n};\n\nvar IDLE = exports.IDLE = 0;\nvar LOADING_APPEND = exports.LOADING_APPEND = 1;\nvar LOADING_PREPEND = exports.LOADING_PREPEND = 2;\nvar PROCESSING = exports.PROCESSING = 4;\n\nvar webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\n\nvar WEBKIT_VERSION = exports.WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;\nvar DEFENSE_BROWSER = exports.DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win = window;\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexports.window = win;\nvar document = exports.document = win.document;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _browser = __webpack_require__(2);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar elements = [];\n/* eslint-disable */\nfunction onResize(e) {\n\tAutoSizer.resizeAll();\n}\n/* eslint-enable */\n\nvar AutoSizer = function () {\n\tfunction AutoSizer() {\n\t\t_classCallCheck(this, AutoSizer);\n\t}\n\n\tAutoSizer.add = function add(element) {\n\t\tvar prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data-";\n\n\t\tif (!element.length) {\n\t\t\t(0, _utils.addEvent)(_browser.window, "resize", onResize);\n\t\t}\n\t\telement.__PREFIX__ = prefix;\n\t\telements.push(element);\n\t\tAutoSizer.resize(element);\n\t};\n\n\tAutoSizer.remove = function remove(element) {\n\t\tvar isFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\tvar fixed = element.getAttribute(element.__PREFIX__ + "fixed") || "width";\n\n\t\tif (!isFixed) {\n\t\t\telement.style[fixed === "width" ? "height" : "width"] = "";\n\t\t}\n\t\tvar index = elements.indexOf(element);\n\n\t\tif (!~index) {\n\t\t\treturn;\n\t\t}\n\t\telements.splice(index, 1);\n\t\tif (!elements.length) {\n\t\t\t(0, _utils.removeEvent)(_browser.window, "reisze", onResize);\n\t\t}\n\t};\n\n\tAutoSizer.resize = function resize(element) {\n\t\tvar prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data-";\n\n\t\tvar elementPrefix = typeof element.__PREFIX__ === "string" ? element.__PREFIX__ : prefix;\n\t\tvar dataWidth = element.getAttribute(elementPrefix + "width");\n\t\tvar dataHeight = element.getAttribute(elementPrefix + "height");\n\t\tvar fixed = element.getAttribute(elementPrefix + "fixed");\n\n\t\tif (fixed === "height") {\n\t\t\tvar size = (0, _utils.innerHeight)(element) || dataHeight;\n\n\t\t\telement.style.width = dataWidth / dataHeight * size + "px";\n\t\t} else {\n\t\t\tvar _size = (0, _utils.innerWidth)(element) || dataWidth;\n\n\t\t\telement.style.height = dataHeight / dataWidth * _size + "px";\n\t\t}\n\t};\n\n\tAutoSizer.resizeAll = function resizeAll() {\n\t\telements.forEach(function (element) {\n\t\t\treturn AutoSizer.resize(element);\n\t\t});\n\t};\n\n\treturn AutoSizer;\n}();\n\nexports["default"] = AutoSizer;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar ItemManager = function () {\n\tItemManager.from = function from(elements, selector, _ref) {\n\t\tvar groupKey = _ref.groupKey,\n\t\t    isAppend = _ref.isAppend;\n\n\t\tvar filted = ItemManager.selectItems((0, _utils.$)(elements, _consts.MULTI), selector);\n\n\t\t// Item Structure\n\t\treturn (0, _utils.toArray)(filted).map(function (el) {\n\t\t\treturn {\n\t\t\t\tel: el,\n\t\t\t\tgroupKey: groupKey,\n\t\t\t\tcontent: el.outerHTML\n\t\t\t};\n\t\t});\n\t};\n\n\tItemManager.selectItems = function selectItems(elements) {\n\t\tvar selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";\n\n\t\treturn elements.filter(function (v) {\n\t\t\tvar classNames = v.className.split(" ");\n\n\t\t\tif (classNames.some(function (c) {\n\t\t\t\treturn c === _consts.IGNORE_CLASSNAME;\n\t\t\t})) {\n\t\t\t\treturn false;\n\t\t\t} else if (!selector || selector === "*") {\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\treturn classNames.some(function (c) {\n\t\t\t\t\treturn c === selector;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\tItemManager.pluck = function pluck(data, property) {\n\t\treturn data.reduce(function (acc, v) {\n\t\t\treturn acc.concat(v[property]);\n\t\t}, []);\n\t};\n\n\tfunction ItemManager() {\n\t\t_classCallCheck(this, ItemManager);\n\n\t\tthis.clear();\n\t}\n\n\tItemManager.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\t_data: this._data.map(function (data) {\n\t\t\t\tvar items = data.items.map(function (item) {\n\t\t\t\t\tvar item2 = _extends({}, item);\n\n\t\t\t\t\tdelete item2.el;\n\t\t\t\t\treturn item2;\n\t\t\t\t});\n\t\t\t\tvar data2 = _extends({}, data);\n\n\t\t\t\tdata2.items = items;\n\t\t\t\treturn data2;\n\t\t\t})\n\t\t};\n\t};\n\n\tItemManager.prototype.setStatus = function setStatus(status) {\n\t\tvar data = status._data;\n\n\t\tthis.set(data);\n\t};\n\n\tItemManager.prototype.size = function size() {\n\t\treturn this._data.length;\n\t};\n\n\tItemManager.prototype.fit = function fit(base, horizontal) {\n\t\tif (!this._data.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar property = horizontal ? "left" : "top";\n\n\t\tif (base !== 0) {\n\t\t\tthis._data = this._data.map(function (v) {\n\t\t\t\tv.items = v.items.map(function (item) {\n\t\t\t\t\titem.rect[property] -= base;\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t\t\tv.outlines.start = v.outlines.start.map(function (start) {\n\t\t\t\t\treturn start - base;\n\t\t\t\t});\n\t\t\t\tv.outlines.end = v.outlines.end.map(function (end) {\n\t\t\t\t\treturn end - base;\n\t\t\t\t});\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t};\n\n\tItemManager.prototype.pluck = function pluck(property, start, end) {\n\t\tvar data = (0, _utils.isUndefined)(start) ? this._data : this._data.slice(start, ((0, _utils.isUndefined)(end) ? start : end) + 1);\n\n\t\treturn ItemManager.pluck(data, property);\n\t};\n\n\tItemManager.prototype.getOutline = function getOutline(index, property) {\n\t\tif (this._data.length) {\n\t\t\treturn this._data[index].outlines[property];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t};\n\n\tItemManager.prototype.getEdgeIndex = function getEdgeIndex(cursor, start, end) {\n\t\tvar prop = cursor === "start" ? "min" : "max";\n\t\tvar index = -1;\n\t\tvar targetValue = cursor === "start" ? Infinity : -Infinity;\n\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\tvar value = Math[prop].apply(Math, this.getOutline(i, cursor));\n\n\t\t\tif (cursor === "start" && targetValue > value || cursor === "end" && targetValue < value) {\n\t\t\t\ttargetValue = value;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t};\n\n\tItemManager.prototype.getEdge = function getEdge(cursor, start, end) {\n\t\tvar dataIdx = this.getEdgeIndex(cursor, start, end);\n\t\tvar items = this.pluck("items", dataIdx);\n\n\t\tif (items.length) {\n\t\t\tvar itemIdx = this.getOutline(dataIdx, cursor + "Index");\n\n\t\t\treturn items.length > itemIdx ? items[itemIdx] : null;\n\t\t}\n\t\treturn null;\n\t};\n\n\tItemManager.prototype.getEdgeValue = function getEdgeValue(cursor, start, end) {\n\t\tvar outlines = this.pluck("outlines", this.getEdgeIndex(cursor, start, end)).reduce(function (acc, v) {\n\t\t\treturn acc.concat(v[cursor]);\n\t\t}, []);\n\n\t\treturn outlines.length ? Math[cursor === "start" ? "min" : "max"].apply(Math, outlines) : 0;\n\t};\n\n\tItemManager.prototype.append = function append(layouted) {\n\t\tthis._data.push(layouted);\n\t\treturn layouted.items;\n\t};\n\n\tItemManager.prototype.prepend = function prepend(layouted) {\n\t\tthis._data.unshift(layouted);\n\t\treturn layouted.items;\n\t};\n\n\tItemManager.prototype.clear = function clear() {\n\t\tthis._data = [];\n\t};\n\n\tItemManager.prototype.remove = function remove(element, start, end) {\n\t\tvar items = [];\n\t\tvar key = element.getAttribute(_consts.GROUPKEY_ATT);\n\t\tvar data = this.get(start, end).filter(function (v) {\n\t\t\treturn String(v.groupKey) === key;\n\t\t});\n\n\t\tif (!data.length) {\n\t\t\treturn items;\n\t\t}\n\t\tdata = data[0];\n\n\t\tvar len = data.items.length;\n\t\tvar idx = -1;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (data.items[i].el === element) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~idx) {\n\t\t\t// remove item information\n\t\t\tdata.items.splice(idx, 1);\n\t\t\tthis.set(data, key);\n\t\t\titems = data.items;\n\t\t}\n\t\treturn items;\n\t};\n\n\tItemManager.prototype.indexOf = function indexOf(data) {\n\t\tvar groupKey = (typeof data === "undefined" ? "undefined" : _typeof(data)) === "object" ? data.groupKey : data;\n\t\tvar datas = this._data;\n\t\tvar length = datas.length;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tif (groupKey === datas[i].groupKey) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tItemManager.prototype.get = function get(start, end) {\n\t\tif ((0, _utils.isUndefined)(start)) {\n\t\t\treturn this._data.concat();\n\t\t}\n\t\treturn this._data.slice(start, ((0, _utils.isUndefined)(end) ? start : end) + 1);\n\t};\n\n\tItemManager.prototype.set = function set(data, key) {\n\t\tif (!(0, _utils.isUndefined)(key) && !Array.isArray(data)) {\n\t\t\tvar len = this._data.length;\n\t\t\tvar idx = -1;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (this._data[i].groupKey === key) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t~idx && (this._data[idx] = data);\n\t\t} else {\n\t\t\tthis._data = data.concat();\n\t\t}\n\t};\n\n\tItemManager.prototype.getData = function getData(index) {\n\t\treturn this._data[index];\n\t};\n\n\treturn ItemManager;\n}();\n\nexports["default"] = ItemManager;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defense(element) {\n\tvar container = document.createElement("div");\n\n\tcontainer.className = _consts.CONTAINER_CLASSNAME;\n\tcontainer.style.position = "relative";\n\tcontainer.style.height = "100%";\n\n\tvar children = element.children;\n\tvar length = children.length; // for IE8\n\n\tfor (var i = 0; i < length; i++) {\n\t\tcontainer.appendChild(children[0]);\n\t}\n\n\telement.appendChild(container);\n\treturn container;\n}\n\nvar DOMRenderer = function () {\n\tDOMRenderer.renderItem = function renderItem(item, styles) {\n\t\tvar el = item.el;\n\n\t\tif (el) {\n\t\t\tvar elStyle = el.style;\n\n\t\t\t// for debugging\n\t\t\tel.setAttribute(_consts.GROUPKEY_ATT, item.groupKey);\n\t\t\telStyle.position = "absolute";\n\t\t\t["left", "top", "width", "height"].forEach(function (p) {\n\t\t\t\tp in styles && (elStyle[p] = styles[p] + "px");\n\t\t\t});\n\t\t}\n\t};\n\n\tDOMRenderer.renderItems = function renderItems(items) {\n\t\titems.forEach(function (item) {\n\t\t\tDOMRenderer.renderItem(item, item.rect);\n\t\t});\n\t};\n\n\tDOMRenderer.removeItems = function removeItems(items) {\n\t\titems.forEach(function (item) {\n\t\t\tif (item.el) {\n\t\t\t\tDOMRenderer.removeElement(item.el);\n\t\t\t\titem.el = null;\n\t\t\t}\n\t\t});\n\t};\n\n\tDOMRenderer.removeElement = function removeElement(element) {\n\t\tvar parentNode = element && element.parentNode;\n\n\t\tif (!parentNode) {\n\t\t\treturn;\n\t\t}\n\t\tparentNode.removeChild(element);\n\t};\n\n\tDOMRenderer.createElements = function createElements(items) {\n\t\tif (!items.length || items[0].el) {\n\t\t\treturn items;\n\t\t}\n\t\tvar elements = (0, _utils.$)(items.map(function (_ref) {\n\t\t\tvar content = _ref.content;\n\t\t\treturn content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, "");\n\t\t}).join(""), _consts.MULTI);\n\n\t\treturn items.map(function (item, index) {\n\t\t\titem.el = elements[index];\n\t\t\treturn item;\n\t\t});\n\t};\n\n\tfunction DOMRenderer(element, options) {\n\t\t_classCallCheck(this, DOMRenderer);\n\n\t\t_extends(this.options = {\n\t\t\tisOverflowScroll: false,\n\t\t\tisEqualSize: false,\n\t\t\thorizontal: false\n\t\t}, options);\n\t\tthis._size = {\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t\tviewport: -1,\n\t\t\titem: null\n\t\t};\n\t\tthis._init(element);\n\t\tthis.resize();\n\t}\n\n\tDOMRenderer.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\tcssText: this.container.style.cssText,\n\t\t\toptions: _extends({}, this.options),\n\t\t\t_size: _extends({}, this._size)\n\t\t};\n\t};\n\n\tDOMRenderer.prototype.setStatus = function setStatus(status) {\n\t\tthis.container.style.cssText = status.cssText;\n\t\t_extends(this.options, status.options);\n\t\t_extends(this._size, status._size);\n\t};\n\n\tDOMRenderer.prototype.updateSize = function updateSize(items) {\n\t\tvar _this = this;\n\n\t\treturn items.map(function (item) {\n\t\t\tif (item.el) {\n\t\t\t\tif (_this.options.isEqualSize) {\n\t\t\t\t\t_this._size.item = _this._size.item || {\n\t\t\t\t\t\twidth: (0, _utils.innerWidth)(item.el),\n\t\t\t\t\t\theight: (0, _utils.innerHeight)(item.el)\n\t\t\t\t\t};\n\t\t\t\t\titem.size = _extends({}, _this._size.item);\n\t\t\t\t} else {\n\t\t\t\t\titem.size = {\n\t\t\t\t\t\twidth: (0, _utils.innerWidth)(item.el),\n\t\t\t\t\t\theight: (0, _utils.innerHeight)(item.el)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!item.orgSize) {\n\t\t\t\t\titem.orgSize = _extends({}, item.size);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\t};\n\n\tDOMRenderer.prototype._init = function _init(el) {\n\t\tvar element = (0, _utils.$)(el);\n\t\tvar style = (0, _utils.getStyles)(element);\n\t\tvar _options = this.options,\n\t\t    isOverflowScroll = _options.isOverflowScroll,\n\t\t    horizontal = _options.horizontal;\n\n\n\t\tthis._orgStyle = {};\n\n\t\tif (style.position === "static") {\n\t\t\tthis._orgStyle.position = element.style.position;\n\t\t\telement.style.position = "relative";\n\t\t}\n\t\tif (isOverflowScroll) {\n\t\t\tvar target = horizontal ? ["X", "Y"] : ["Y", "X"];\n\n\t\t\tthis._orgStyle.overflowX = element.style.overflowX;\n\t\t\tthis._orgStyle.overflowY = element.style.overflowY;\n\t\t\telement.style["overflow" + target[0]] = "scroll";\n\t\t\telement.style["overflow" + target[1]] = "hidden";\n\t\t\tthis.view = element;\n\t\t\t// defense code for android < 4.4 or webkit < 537\n\t\t\tthis.container = horizontal && _consts.DEFENSE_BROWSER ? _defense(element) : element;\n\t\t} else {\n\t\t\tthis.view = window;\n\t\t\tthis.container = element;\n\t\t}\n\t};\n\n\tDOMRenderer.prototype.append = function append(items) {\n\t\tthis._insert(items, _consts.APPEND, {\n\t\t\ttop: _consts.DUMMY_POSITION,\n\t\t\tleft: _consts.DUMMY_POSITION\n\t\t});\n\t};\n\n\tDOMRenderer.prototype.prepend = function prepend(items) {\n\t\tthis._insert(items, _consts.PREPEND, {\n\t\t\ttop: _consts.DUMMY_POSITION,\n\t\t\tleft: _consts.DUMMY_POSITION\n\t\t});\n\t};\n\n\tDOMRenderer.prototype.clear = function clear() {\n\t\tthis.container.innerHTML = "";\n\t\tif (!this.options.isOverflowScroll) {\n\t\t\tthis.container.style[this.options.horizontal ? "width" : "height"] = "";\n\t\t}\n\t\tthis._size = {\n\t\t\titem: null,\n\t\t\tviewport: -1,\n\t\t\tcontainer: -1,\n\t\t\tview: -1\n\t\t};\n\t};\n\n\tDOMRenderer.prototype.createAndInsert = function createAndInsert(items, isAppend) {\n\t\tvar itemsWithElement = DOMRenderer.createElements(items);\n\n\t\tDOMRenderer.renderItems(itemsWithElement);\n\t\tthis._insert(itemsWithElement, isAppend);\n\t};\n\n\tDOMRenderer.prototype._insert = function _insert(items, isAppend, styles) {\n\t\tvar container = this.container;\n\t\tvar df = document.createDocumentFragment();\n\n\t\titems.forEach(function (item) {\n\t\t\tstyles && DOMRenderer.renderItem(item, styles);\n\t\t\tisAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n\t\t});\n\t\tisAppend ? container.appendChild(df) : container.insertBefore(df, container.firstChild);\n\t};\n\n\tDOMRenderer.prototype._calcSize = function _calcSize() {\n\t\treturn this.options.horizontal ? (0, _utils.innerHeight)(this.container) : (0, _utils.innerWidth)(this.container);\n\t};\n\n\tDOMRenderer.prototype.getViewSize = function getViewSize() {\n\t\treturn this._size.view;\n\t};\n\n\tDOMRenderer.prototype.getViewportSize = function getViewportSize() {\n\t\treturn this._size.viewport;\n\t};\n\n\tDOMRenderer.prototype.setContainerSize = function setContainerSize(size) {\n\t\tvar _options2 = this.options,\n\t\t    isOverflowScroll = _options2.isOverflowScroll,\n\t\t    horizontal = _options2.horizontal;\n\n\n\t\tif (!isOverflowScroll || horizontal && _consts.DEFENSE_BROWSER) {\n\t\t\tthis.container.style[horizontal ? "width" : "height"] = size + "px";\n\t\t}\n\t};\n\n\tDOMRenderer.prototype.resize = function resize() {\n\t\tvar horizontal = this.options.horizontal;\n\t\tvar view = this.view;\n\t\tvar isResize = this.isNeededResize();\n\n\t\tif (isResize) {\n\t\t\tthis._size = {\n\t\t\t\tviewport: this._calcSize(),\n\t\t\t\titem: null\n\t\t\t};\n\t\t}\n\t\tthis._size.view = horizontal ? (0, _utils.innerWidth)(view) : (0, _utils.innerHeight)(view);\n\t\treturn isResize;\n\t};\n\n\tDOMRenderer.prototype.isNeededResize = function isNeededResize() {\n\t\treturn this._calcSize() !== this._size.viewport;\n\t};\n\n\tDOMRenderer.prototype.destroy = function destroy() {\n\t\tthis._size = {\n\t\t\tviewport: -1,\n\t\t\tview: -1,\n\t\t\titem: null\n\t\t};\n\t\tthis.container.style[this.options.horizontal ? "width" : "height"] = "";\n\t\tfor (var p in this._orgStyle) {\n\t\t\tthis[this.options.isOverflowScroll ? "view" : "container"].style[p] = this._orgStyle[p];\n\t\t}\n\t};\n\n\treturn DOMRenderer;\n}();\n\nexports["default"] = DOMRenderer;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\nexports.CHECK_ONLY_ERROR = exports.CHECK_ALL = undefined;\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nvar _AutoSizer = __webpack_require__(3);\n\nvar _AutoSizer2 = _interopRequireDefault(_AutoSizer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar CHECK_ALL = exports.CHECK_ALL = 1;\nvar CHECK_ONLY_ERROR = exports.CHECK_ONLY_ERROR = 2;\n\nfunction isDataAttribute(target, prefix) {\n\treturn !!target.getAttribute(prefix + "width");\n}\n\nvar ImageLoaded = function () {\n\tfunction ImageLoaded() {\n\t\t_classCallCheck(this, ImageLoaded);\n\t}\n\n\tImageLoaded.waitImageLoaded = function waitImageLoaded(needCheck, _ref) {\n\t\tvar _ref$prefix = _ref.prefix,\n\t\t    prefix = _ref$prefix === undefined ? "" : _ref$prefix,\n\t\t    length = _ref.length,\n\t\t    type = _ref.type,\n\t\t    complete = _ref.complete,\n\t\t    error = _ref.error,\n\t\t    end = _ref.end;\n\n\t\tvar checkCount = 0;\n\t\tvar endCount = length;\n\n\t\tif (type !== CHECK_ONLY_ERROR) {\n\t\t\tcheckCount = endCount;\n\t\t}\n\t\tvar checkEnd = function checkEnd() {\n\t\t\tif (--endCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tend && end();\n\t\t};\n\t\tvar checkImage = function checkImage() {\n\t\t\tcheckCount--;\n\t\t\tif (checkCount !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomplete && complete();\n\t\t};\n\t\tvar onError = function onError(target) {\n\t\t\tvar itemIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target.__ITEM_INDEX__;\n\n\t\t\terror && error({\n\t\t\t\ttarget: target,\n\t\t\t\titemIndex: itemIndex\n\t\t\t});\n\t\t};\n\t\tvar onCheck = function onCheck(e) {\n\t\t\tvar target = e.target || e.srcElement;\n\n\t\t\t(0, _utils.removeEvent)(target, "error", onCheck);\n\t\t\t(0, _utils.removeEvent)(target, "load", onCheck);\n\n\t\t\tif (type === CHECK_ALL && isDataAttribute(target, prefix)) {\n\t\t\t\t_AutoSizer2["default"].remove(target, e.type === "error");\n\t\t\t} else {\n\t\t\t\tcheckImage();\n\t\t\t}\n\t\t\tif (e.type === "error") {\n\t\t\t\tonError(target);\n\t\t\t}\n\t\t\tdelete target.__ITEM_INDEX__;\n\t\t\tcheckEnd();\n\t\t};\n\n\t\tneedCheck.forEach(function (images, i) {\n\t\t\timages.forEach(function (v) {\n\t\t\t\t// workaround for IE\n\t\t\t\tif (v.complete && (!_consts.IS_IE || _consts.IS_IE && v.naturalWidth)) {\n\t\t\t\t\tif (!v.naturalWidth) {\n\t\t\t\t\t\tonError(v, i);\n\t\t\t\t\t}\n\t\t\t\t\tcheckImage();\n\t\t\t\t\tcheckEnd();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tv.__ITEM_INDEX__ = i;\n\t\t\t\tif (type === CHECK_ALL && isDataAttribute(v, prefix)) {\n\t\t\t\t\t_AutoSizer2["default"].add(v, prefix);\n\t\t\t\t\tcheckImage();\n\t\t\t\t}\n\t\t\t\t(0, _utils.addEvent)(v, "load", onCheck);\n\t\t\t\t(0, _utils.addEvent)(v, "error", onCheck);\n\n\t\t\t\t_consts.IS_IE && v.setAttribute("src", v.getAttribute("src"));\n\t\t\t});\n\t\t});\n\t};\n\n\tImageLoaded.checkImageLoaded = function checkImageLoaded(el) {\n\t\tif (el.tagName === "IMG") {\n\t\t\treturn el.complete ? [] : [el];\n\t\t} else {\n\t\t\treturn (0, _utils.toArray)(el.querySelectorAll("img"));\n\t\t}\n\t};\n\n\tImageLoaded.check = function check(elements, _ref2) {\n\t\tvar _this = this;\n\n\t\tvar prefix = _ref2.prefix,\n\t\t    _ref2$type = _ref2.type,\n\t\t    type = _ref2$type === undefined ? CHECK_ALL : _ref2$type,\n\t\t    complete = _ref2.complete,\n\t\t    error = _ref2.error,\n\t\t    end = _ref2.end;\n\n\t\tvar images = elements.map(function (element) {\n\t\t\treturn _this.checkImageLoaded(element);\n\t\t});\n\t\tvar length = images.reduce(function (sum, element) {\n\t\t\treturn sum + element.length;\n\t\t}, 0);\n\n\t\tif (type === CHECK_ONLY_ERROR || length === 0) {\n\t\t\t// convert to async\n\t\t\tsetTimeout(function () {\n\t\t\t\tcomplete && complete();\n\t\t\t\tif (length === 0) {\n\t\t\t\t\tend && end();\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t\tif (length > 0) {\n\t\t\tsetTimeout(function () {\n\t\t\t\t_this.waitImageLoaded(images, { prefix: prefix, length: length, type: type, complete: complete, error: error, end: end });\n\t\t\t}, 0);\n\t\t}\n\t};\n\n\treturn ImageLoaded;\n}();\n\nexports["default"] = ImageLoaded;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Watcher = function () {\n\tfunction Watcher(view, options) {\n\t\t_classCallCheck(this, Watcher);\n\n\t\t_extends(this.options = {\n\t\t\tcontainer: view,\n\t\t\tresize: function resize() {},\n\t\t\tcheck: function check() {},\n\t\t\tisOverflowScroll: false,\n\t\t\thorizontal: false\n\t\t}, options);\n\t\tthis._timer = {\n\t\t\tresize: null\n\t\t\t// doubleCheck: null,\n\t\t\t// doubleCheckCount: RETRY,\n\t\t};\n\t\tthis.reset();\n\t\tthis._containerOffset = 0;\n\t\tthis._view = view;\n\t\tthis._onCheck = this._onCheck.bind(this);\n\t\tthis._onResize = this._onResize.bind(this);\n\t\tthis.attachEvent();\n\t\tthis.setScrollPos();\n\t\tthis._setContainerOffset();\n\t}\n\n\tWatcher.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\t_prevPos: this._prevPos,\n\t\t\tscrollPos: this.getOrgScrollPos()\n\t\t};\n\t};\n\n\tWatcher.prototype.setStatus = function setStatus(status) {\n\t\tvar applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tthis._prevPos = status._prevPos;\n\t\tapplyScrollPos && this.scrollTo(status.scrollPos);\n\t};\n\n\tWatcher.prototype.scrollBy = function scrollBy(pos) {\n\t\tvar arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\t_utils.scrollBy.apply(undefined, [this._view].concat(arrPos));\n\t\tthis.setScrollPos();\n\t};\n\n\tWatcher.prototype.scrollTo = function scrollTo(pos) {\n\t\tvar arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n\n\t\t_utils.scrollTo.apply(undefined, [this._view].concat(arrPos));\n\t};\n\n\tWatcher.prototype.getScrollPos = function getScrollPos() {\n\t\treturn this._prevPos;\n\t};\n\n\tWatcher.prototype.setScrollPos = function setScrollPos(pos) {\n\t\tvar rawPos = pos;\n\n\t\tif (typeof pos === "undefined") {\n\t\t\trawPos = this.getOrgScrollPos();\n\t\t}\n\t\tthis._prevPos = rawPos - this.getContainerOffset();\n\t};\n\n\tWatcher.prototype.attachEvent = function attachEvent() {\n\t\t(0, _utils.addEvent)(this._view, "scroll", this._onCheck);\n\t\t(0, _utils.addEvent)(window, "resize", this._onResize);\n\t};\n\n\tWatcher.prototype.getOrgScrollPos = function getOrgScrollPos() {\n\t\treturn (0, _utils.scroll)(this._view, this.options.horizontal);\n\t};\n\n\tWatcher.prototype.reset = function reset() {\n\t\tthis._prevPos = null;\n\t};\n\n\tWatcher.prototype._onCheck = function _onCheck() {\n\t\tvar prevPos = this.getScrollPos();\n\t\tvar orgScrollPos = this.getOrgScrollPos();\n\n\t\tthis.setScrollPos(orgScrollPos);\n\t\tvar scrollPos = this.getScrollPos();\n\n\t\tif (prevPos === null || _consts.IS_IOS && orgScrollPos === 0 || prevPos === scrollPos) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.options.check({\n\t\t\tisForward: prevPos < scrollPos,\n\t\t\tscrollPos: scrollPos,\n\t\t\torgScrollPos: orgScrollPos,\n\t\t\thorizontal: this.options.horizontal\n\t\t});\n\t};\n\n\tWatcher.prototype.getContainerOffset = function getContainerOffset() {\n\t\treturn this._containerOffset;\n\t};\n\n\tWatcher.prototype._setContainerOffset = function _setContainerOffset() {\n\t\tthis._containerOffset = this.options.isOverflowScroll ? 0 : this.options.container["offset" + (this.options.horizontal ? "Left" : "Top")];\n\t};\n\n\tWatcher.prototype._onResize = function _onResize() {\n\t\tvar _this = this;\n\n\t\tif (this._timer.resize) {\n\t\t\tclearTimeout(this._timer.resize);\n\t\t}\n\t\tthis._timer.resize = setTimeout(function () {\n\t\t\t_this._setContainerOffset();\n\t\t\t_this.options.resize();\n\t\t\t_this._timer.resize = null;\n\t\t\t_this.reset();\n\t\t}, 100);\n\t};\n\n\tWatcher.prototype.detachEvent = function detachEvent() {\n\t\t(0, _utils.removeEvent)(window, "resize", this._onResize);\n\t};\n\n\tWatcher.prototype.destroy = function destroy() {\n\t\tthis.detachEvent();\n\t\tthis.reset();\n\t};\n\n\treturn Watcher;\n}();\n\nexports["default"] = Watcher;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction isVisible(group, threshold, scrollPos, endScrollPos) {\n\tvar items = group.items,\n\t    outlines = group.outlines;\n\n\tvar start = outlines.start;\n\tvar end = outlines.end;\n\n\tif (start.legnth === 0 || end.length === 0 || !items.length || !items[0].el) {\n\t\treturn 2;\n\t}\n\tvar min = Math.min.apply(Math, start);\n\tvar max = Math.max.apply(Math, end);\n\n\tif (endScrollPos + threshold < min) {\n\t\treturn +1;\n\t} else if (scrollPos - threshold > max) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvar Infinite = function () {\n\tfunction Infinite(itemManger, options) {\n\t\t_classCallCheck(this, Infinite);\n\n\t\tthis.options = _extends({\n\t\t\tuseRecycle: true,\n\t\t\tthreshold: 100,\n\t\t\tappend: function append() {},\n\t\t\tprepend: function prepend() {},\n\t\t\trecycle: function recycle() {}\n\t\t}, options);\n\t\tthis._items = itemManger;\n\t\tthis.clear();\n\t}\n\n\tInfinite.prototype.setSize = function setSize(size) {\n\t\tthis._status.size = size;\n\t};\n\n\tInfinite.prototype.recycle = function recycle(scrollPos, isForward) {\n\t\tif (!this.options.useRecycle) {\n\t\t\treturn;\n\t\t}\n\t\tvar _status = this._status,\n\t\t    startCursor = _status.startCursor,\n\t\t    endCursor = _status.endCursor,\n\t\t    size = _status.size;\n\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn;\n\t\t}\n\t\tvar endScrollPos = scrollPos + size;\n\t\tvar _options = this.options,\n\t\t    threshold = _options.threshold,\n\t\t    recycle = _options.recycle;\n\n\t\tvar visibles = this._items.get(startCursor, endCursor).map(function (group) {\n\t\t\treturn isVisible(group, threshold, scrollPos, endScrollPos);\n\t\t});\n\t\tvar length = visibles.length;\n\t\tvar start = isForward ? 0 : visibles.lastIndexOf(0);\n\t\tvar end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n\t\tif (!isForward && start !== -1) {\n\t\t\tstart += 1;\n\t\t}\n\t\tif (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n\t\t\treturn;\n\t\t}\n\t\tstart = startCursor + start;\n\t\tend = startCursor + end;\n\n\t\trecycle({ start: start, end: end });\n\t\tif (isForward) {\n\t\t\tthis.setCursor("start", end + 1);\n\t\t} else {\n\t\t\tthis.setCursor("end", start - 1);\n\t\t}\n\t};\n\n\tInfinite.prototype.scroll = function scroll(scrollPos, isForward) {\n\t\tvar _status2 = this._status,\n\t\t    startCursor = _status2.startCursor,\n\t\t    endCursor = _status2.endCursor,\n\t\t    size = _status2.size;\n\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn;\n\t\t}\n\t\tvar _options2 = this.options,\n\t\t    append = _options2.append,\n\t\t    prepend = _options2.prepend,\n\t\t    threshold = _options2.threshold;\n\n\t\tvar items = this._items;\n\t\tvar length = items.size();\n\t\tvar endScrollPos = scrollPos + size;\n\t\tvar targetItem = items.getData(isForward ? endCursor : startCursor);\n\t\tvar outlines = targetItem.outlines[isForward ? "end" : "start"];\n\t\tvar edgePos = Math[isForward ? "min" : "max"].apply(Math, outlines);\n\n\t\tif (isForward) {\n\t\t\tif (endScrollPos >= edgePos - threshold) {\n\t\t\t\tappend({ cache: length > endCursor + 1 && items.getData(endCursor + 1) });\n\t\t\t}\n\t\t} else if (scrollPos <= edgePos + threshold) {\n\t\t\tprepend({ cache: startCursor > 0 && items.getData(startCursor - 1) });\n\t\t}\n\t};\n\n\tInfinite.prototype.setCursor = function setCursor(cursor, index) {\n\t\tvar status = this._status;\n\n\t\tif (!this.options.useRecycle) {\n\t\t\tstatus.startCursor = 0;\n\t\t\tstatus.endCursor = this._items.size() - 1;\n\t\t\treturn;\n\t\t}\n\t\tif (cursor === "start") {\n\t\t\tstatus.startCursor = index;\n\t\t} else {\n\t\t\tstatus.endCursor = Math.min(this._items.size() - 1, index);\n\t\t}\n\t\tstatus.startCursor = Math.max(0, status.startCursor);\n\t};\n\n\tInfinite.prototype.updateCursor = function updateCursor(cursor) {\n\t\tvar _status3 = this._status,\n\t\t    startCursor = _status3.startCursor,\n\t\t    endCursor = _status3.endCursor;\n\n\n\t\tif (cursor === "start") {\n\t\t\tif (startCursor <= 0) {\n\t\t\t\tthis.setCursor("start", 0);\n\t\t\t\tthis.setCursor("end", endCursor + 1);\n\t\t\t} else {\n\t\t\t\tthis.setCursor(cursor, startCursor - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.setCursor(cursor, endCursor + 1);\n\t\t}\n\t};\n\n\tInfinite.prototype.setData = function setData(item) {\n\t\tvar isAppend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tthis._items.set(item, item.groupKey);\n\t\tthis.setCursor(isAppend ? "end" : "start", this._items.indexOf(item));\n\t};\n\n\tInfinite.prototype.append = function append(item) {\n\t\tthis._items.append(item);\n\t\tthis.updateCursor("end");\n\t};\n\n\tInfinite.prototype.prepend = function prepend(item) {\n\t\tthis._items.prepend(item);\n\t\tthis.updateCursor("start");\n\t};\n\n\tInfinite.prototype.setStatus = function setStatus(status) {\n\t\tthis._status = _extends(this._status, status);\n\t};\n\n\tInfinite.prototype.getStatus = function getStatus() {\n\t\tvar _status4 = this._status,\n\t\t    startCursor = _status4.startCursor,\n\t\t    endCursor = _status4.endCursor,\n\t\t    size = _status4.size;\n\n\n\t\treturn {\n\t\t\tstartCursor: startCursor,\n\t\t\tendCursor: endCursor,\n\t\t\tsize: size\n\t\t};\n\t};\n\n\tInfinite.prototype.getEdgeOutline = function getEdgeOutline(cursor) {\n\t\tvar _status5 = this._status,\n\t\t    startCursor = _status5.startCursor,\n\t\t    endCursor = _status5.endCursor;\n\n\n\t\tif (startCursor === -1 || endCursor === -1) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this._items.getOutline(cursor === "start" ? startCursor : endCursor, cursor);\n\t};\n\n\tInfinite.prototype.getEdgeValue = function getEdgeValue(cursor) {\n\t\tvar outlines = this.getEdgeOutline(cursor);\n\n\t\treturn outlines.length ? Math[cursor === "start" ? "min" : "max"].apply(Math, outlines) : 0;\n\t};\n\n\tInfinite.prototype.getVisibleItems = function getVisibleItems() {\n\t\treturn this._items.pluck("items", this._status.startCursor, this._status.endCursor);\n\t};\n\n\tInfinite.prototype.getCursor = function getCursor(cursor) {\n\t\treturn this._status[cursor === "start" ? "startCursor" : "endCursor"];\n\t};\n\n\tInfinite.prototype.getVisibleData = function getVisibleData() {\n\t\treturn this._items.get(this._status.startCursor, this._status.endCursor);\n\t};\n\n\tInfinite.prototype.remove = function remove(element) {\n\t\treturn this._items.remove(element, this._status.startCursor, this._status.endCursor);\n\t};\n\n\tInfinite.prototype.clear = function clear() {\n\t\tthis._status = {\n\t\t\tstartCursor: -1,\n\t\t\tendCursor: -1,\n\t\t\tsize: -1\n\t\t};\n\t};\n\n\treturn Infinite;\n}();\n\nexports["default"] = Infinite;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\nfunction disableFrame(frame, type, x, y, width, height) {\n\tfor (var i = y; i < y + height; ++i) {\n\t\tfor (var j = x; j < x + width; ++j) {\n\t\t\tif (type !== frame[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe[i][j] = 0;\n\t\t}\n\t}\n}\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n\tvar size = {\n\t\tleft: left,\n\t\ttop: top,\n\t\ttype: type,\n\t\twidth: 1,\n\t\theight: 1\n\t};\n\n\tfor (var i = left; i < width; ++i) {\n\t\tif (frame[top][i] === type) {\n\t\t\tsize.width = i - left + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfor (var _i = top; _i < height; ++_i) {\n\t\tif (frame[_i][left] === type) {\n\t\t\tsize.height = _i - top + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t// After finding the shape, it will not find again.\n\tdisableFrame(frame, type, left, top, size.width, size.height);\n\treturn size;\n}\nfunction getShapes(frame) {\n\tvar height = frame.length;\n\tvar width = height ? frame[0].length : 0;\n\tvar shapes = [];\n\n\tfor (var i = 0; i < height; ++i) {\n\t\tfor (var j = 0; j < width; ++j) {\n\t\t\tvar type = frame[i][j];\n\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Separate shapes with other numbers.\n\t\t\tshapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n\t\t}\n\t}\n\tshapes.sort(function (a, b) {\n\t\treturn a.type < b.type ? -1 : 1;\n\t});\n\treturn {\n\t\tshapes: shapes,\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout은 주어진 프레임에 맞춰 카드를 배치하는 레이아웃입니다. 디자이너가 직접 이미지를 배치하는 것과 알고리즘을 사용한 배치의 중간 정도 수준에 해당하는 레이아웃이다.\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko> 다음 프레임이 전 프레임에 이어 붙일 수 있는지 있는지 확인한다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid("#grid". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n\tmargin: 10,\n\titemSize: 200,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n<\/script>\n```\n **/\n\nvar FrameLayout = function () {\n\tfunction FrameLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, FrameLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\titemSize: 0,\n\t\t\tframe: [],\n\t\t\tframeFill: true\n\t\t}, options);\n\t\tvar frame = this.options.frame.map(function (row) {\n\t\t\treturn row.slice();\n\t\t});\n\n\t\tthis._itemSize = this.options.itemSize || 0;\n\t\t// divide frame into shapes.\n\t\tthis._shapes = getShapes(frame);\n\t\tthis._size = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.horizontal);\n\t}\n\n\tFrameLayout.prototype._getItemSize = function _getItemSize() {\n\t\tthis._checkItemSize();\n\n\t\treturn this._itemSize;\n\t};\n\n\tFrameLayout.prototype._checkItemSize = function _checkItemSize() {\n\t\tif (this.options.itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t\treturn;\n\t\t}\n\t\tvar style = this._style;\n\t\tvar size = style.size2;\n\t\tvar margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / this._shapes[size] - margin;\n\t};\n\n\tFrameLayout.prototype._layout = function _layout(items) {\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar length = items.length;\n\t\tvar style = this._style;\n\t\tvar _options = this.options,\n\t\t    margin = _options.margin,\n\t\t    frameFill = _options.frameFill;\n\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar itemSize = this._getItemSize();\n\t\tvar isItemObject = (typeof itemSize === "undefined" ? "undefined" : _typeof(itemSize)) === "object";\n\t\tvar itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n\t\tvar itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n\t\tvar shapesSize = this._shapes[size2Name];\n\t\tvar shapes = this._shapes.shapes;\n\t\tvar shapesLength = shapes.length;\n\t\tvar startOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);\n\t\tvar endOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);\n\t\tvar dist = 0;\n\t\tvar end = 0;\n\t\tvar startIndex = -1;\n\t\tvar endIndex = -1;\n\t\tvar minPos = -1;\n\t\tvar maxPos = -1;\n\n\t\tif (!shapesLength) {\n\t\t\treturn { start: outline, end: outline, startIndex: startIndex, endIndex: endIndex };\n\t\t}\n\t\tfor (var i = 0; i < length; i += shapesLength) {\n\t\t\tfor (var j = 0; j < shapesLength && i + j < length; ++j) {\n\t\t\t\tvar _item$rect;\n\n\t\t\t\tvar item = items[i + j];\n\t\t\t\tvar shape = shapes[j];\n\t\t\t\tvar shapePos1 = shape[pos1Name];\n\t\t\t\tvar shapePos2 = shape[pos2Name];\n\t\t\t\tvar shapeSize1 = shape[size1Name];\n\t\t\t\tvar shapeSize2 = shape[size2Name];\n\t\t\t\tvar pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n\t\t\t\tvar pos2 = shapePos2 * (itemSize2 + margin);\n\t\t\t\tvar size1 = shapeSize1 * (itemSize1 + margin) - margin;\n\t\t\t\tvar size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n\t\t\t\tfor (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n\t\t\t\t\tif (startOutline[k] === _consts.DUMMY_POSITION) {\n\t\t\t\t\t\tstartOutline[k] = pos1;\n\t\t\t\t\t}\n\t\t\t\t\tif (startIndex === -1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (minPos > pos1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxPos < pos1 + size1 + margin) {\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tstartOutline[k] = Math.min(startOutline[k], pos1);\n\t\t\t\t\tendOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n\t\t\t\t}\n\t\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n\t\t\t}\n\t\t\tend = Math.max.apply(Math, endOutline);\n\t\t\t// check dist once\n\t\t\tif (i !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// find & fill empty block\n\t\t\tif (!frameFill) {\n\t\t\t\tdist = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist = end;\n\n\t\t\tfor (var _j = 0; _j < shapesSize; ++_j) {\n\t\t\t\tif (startOutline[_j] === _consts.DUMMY_POSITION) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// the dist between frame\'s end outline and next frame\'s start outline\n\t\t\t\t// expect that next frame\'s start outline is startOutline[j] + end\n\t\t\t\tdist = Math.min(startOutline[_j] + end - endOutline[_j], dist);\n\t\t\t}\n\t\t}\n\t\tfor (var _i2 = 0; _i2 < shapesSize; ++_i2) {\n\t\t\tif (startOutline[_i2] !== _consts.DUMMY_POSITION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstartOutline[_i2] = Math.max.apply(Math, startOutline);\n\t\t\tendOutline[_i2] = startOutline[_i2];\n\t\t}\n\t\t// The target outline is start outline when type is APPENDING\n\t\tvar targetOutline = isAppend ? startOutline : endOutline;\n\t\tvar prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? "max" : "min"].apply(Math, outline);\n\t\tvar prevOutlineDist = isAppend ? 0 : end;\n\n\t\tif (frameFill && outline.length === shapesSize) {\n\t\t\tprevOutlineDist = -_consts.DUMMY_POSITION;\n\t\t\tfor (var _i3 = 0; _i3 < shapesSize; ++_i3) {\n\t\t\t\tif (startOutline[_i3] === endOutline[_i3]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// if appending type is PREPEND, subtract dist from appending group\'s height.\n\n\t\t\t\tprevOutlineDist = Math.min(targetOutline[_i3] + prevOutlineEnd - outline[_i3], prevOutlineDist);\n\t\t\t}\n\t\t}\n\t\tfor (var _i4 = 0; _i4 < shapesSize; ++_i4) {\n\t\t\tstartOutline[_i4] += prevOutlineEnd - prevOutlineDist;\n\t\t\tendOutline[_i4] += prevOutlineEnd - prevOutlineDist;\n\t\t}\n\t\titems.forEach(function (item) {\n\t\t\titem.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n\t\t});\n\t\treturn {\n\t\t\tstart: startOutline,\n\t\t\tend: endOutline,\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tFrameLayout.prototype._insert = function _insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tvar clone = (0, _utils.cloneItems)(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\t/**\n  * Adds items of groups at the bottom of a outline.\n  * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.FrameLayout#layout\n  * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100, 200, 300, 400]);\n  */\n\n\n\tFrameLayout.prototype.layout = function layout(groups, outlines) {\n\t\tvar length = groups.length;\n\t\tvar point = outlines;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t};\n\t/**\n  * Set the viewport size of the layout.\n  * @ko 레이아웃의 가시 사이즈를 설정한다.\n  * @method eg.InfiniteGrid.FrameLayout#setSize\n  * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n  * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.setSize(800);\n  */\n\n\n\tFrameLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t};\n\t/**\n  * Adds items at the bottom of a outline.\n  * @ko 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.FrameLayout#append\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tFrameLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\t/**\n  * Adds items at the top of a outline.\n  * @ko 아이템을 아웃라인 위에 추가한다.\n  * @method eg.InfiniteGrid.FrameLayout#prepend\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tFrameLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\n\treturn FrameLayout;\n}();\n\nexports["default"] = FrameLayout;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\nexports.ItemManager = exports.Watcher = exports.DOMRenderer = exports.AutoSizer = exports.ImageLoaded = exports.Infinite = exports.JustifiedLayout = exports.PackingLayout = exports.SquareLayout = exports.FrameLayout = exports.GridLayout = undefined;\n\nvar _InfiniteGrid = __webpack_require__(11);\n\nvar _InfiniteGrid2 = _interopRequireDefault(_InfiniteGrid);\n\nvar _GridLayout = __webpack_require__(13);\n\nvar _GridLayout2 = _interopRequireDefault(_GridLayout);\n\nvar _FrameLayout = __webpack_require__(9);\n\nvar _FrameLayout2 = _interopRequireDefault(_FrameLayout);\n\nvar _SquareLayout = __webpack_require__(14);\n\nvar _SquareLayout2 = _interopRequireDefault(_SquareLayout);\n\nvar _PackingLayout = __webpack_require__(15);\n\nvar _PackingLayout2 = _interopRequireDefault(_PackingLayout);\n\nvar _JustifiedLayout = __webpack_require__(17);\n\nvar _JustifiedLayout2 = _interopRequireDefault(_JustifiedLayout);\n\nvar _ImageLoaded = __webpack_require__(6);\n\nvar _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);\n\nvar _AutoSizer = __webpack_require__(3);\n\nvar _AutoSizer2 = _interopRequireDefault(_AutoSizer);\n\nvar _DOMRenderer = __webpack_require__(5);\n\nvar _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);\n\nvar _Watcher = __webpack_require__(7);\n\nvar _Watcher2 = _interopRequireDefault(_Watcher);\n\nvar _ItemManager = __webpack_require__(4);\n\nvar _ItemManager2 = _interopRequireDefault(_ItemManager);\n\nvar _Infinite = __webpack_require__(8);\n\nvar _Infinite2 = _interopRequireDefault(_Infinite);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\n/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nexports.GridLayout = _GridLayout2["default"];\nexports.FrameLayout = _FrameLayout2["default"];\nexports.SquareLayout = _SquareLayout2["default"];\nexports.PackingLayout = _PackingLayout2["default"];\nexports.JustifiedLayout = _JustifiedLayout2["default"];\nexports.Infinite = _Infinite2["default"];\nexports.ImageLoaded = _ImageLoaded2["default"];\nexports.AutoSizer = _AutoSizer2["default"];\nexports.DOMRenderer = _DOMRenderer2["default"];\nexports.Watcher = _Watcher2["default"];\nexports.ItemManager = _ItemManager2["default"];\nexports["default"] = _InfiniteGrid2["default"];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * Copyright (c) 2017 NAVER Corp.\n                                                                                                                                                                                                                                                                               * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                              */\n\n\nvar _component = __webpack_require__(12);\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _ItemManager = __webpack_require__(4);\n\nvar _ItemManager2 = _interopRequireDefault(_ItemManager);\n\nvar _DOMRenderer = __webpack_require__(5);\n\nvar _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);\n\nvar _ImageLoaded = __webpack_require__(6);\n\nvar _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);\n\nvar _Watcher = __webpack_require__(7);\n\nvar _Watcher2 = _interopRequireDefault(_Watcher);\n\nvar _AutoSizer = __webpack_require__(3);\n\nvar _AutoSizer2 = _interopRequireDefault(_AutoSizer);\n\nvar _consts = __webpack_require__(1);\n\nvar _Infinite = __webpack_require__(8);\n\nvar _Infinite2 = _interopRequireDefault(_Infinite);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\nif (typeof Object.create !== "function") {\n\tObject.create = function (o, properties) {\n\t\tif ((typeof o === "undefined" ? "undefined" : _typeof(o)) !== "object" && typeof o !== "function") {\n\t\t\tthrow new TypeError("Object prototype may only be an Object: " + o);\n\t\t} else if (o === null) {\n\t\t\tthrow new Error("This browser\'s implementation of Object.create is a shim and doesn\'t support \'null\' as the first argument.");\n\t\t}\n\t\tfunction F() {}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n/* eslint-enable */\n\nfunction hasTarget() {\n\tfor (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {\n\t\ttargets[_key] = arguments[_key];\n\t}\n\n\treturn targets.every(function (target) {\n\t\treturn ~target[0].indexOf(target[1]);\n\t});\n}\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 카드 엘리먼트를 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 카드 엘리먼트를 다양한 레이아웃으로 배치할 수 있다. 카드 엘리먼트의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id="grid">\n\t<li class="card">\n\t\t<div>test1</div>\n\t</li>\n\t<li class="card">\n\t\t<div>test2</div>\n\t</li>\n\t<li class="card">\n\t\t<div>test3</div>\n\t</li>\n\t<li class="card">\n\t\t<div>test4</div>\n\t</li>\n\t<li class="card">\n\t\t<div>test5</div>\n\t</li>\n\t<li class="card">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid("#grid").on("layoutComplete", function(e) {\n\t// ...\n});\n<\/script>\n```\n *\n * @support {"ie": "8+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}\n **/\n\nvar InfiniteGrid = function (_Component) {\n\t_inherits(InfiniteGrid, _Component);\n\n\t/**\n  * @param {HTMLElement|String|jQuery} element A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n  * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n  * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>레이아웃을 구성하는 카드 엘리먼트를 선택할 선택자(selector)</ko>\n  * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is \'true\', keep the number of DOMs is maintained. If the useRecycle value is \'false\', the number of DOMs will increase as card elements are added. <ko>DOM의 수를 유지할지 여부를 나타낸다. useRecycle 값이 \'true\'이면 DOM 개수를 일정하게 유지한다. useRecycle 값이 \'false\' 이면 카드 엘리먼트가 추가될수록 DOM 개수가 계속 증가한다.</ko>\n  * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll 적용여부를 결정한다.</ko>\n  * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향)</ko>\n  * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to "true", the performance of layout arrangement can be improved. <ko>카드 엘리먼트의 크기가 동일한지 여부. 배치될 카드 엘리먼트의 크기가 모두 동일할 때 이 옵션을 \'true\'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n  * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>레이아웃에 카드 엘리먼트를 추가하는 이벤트가 발생하는 기준 영역의 크기.</ko>\n  * @param {String} [options.attributePrefix="data-"] The prefix to use element\'s data attribute.<ko>엘리먼트의 데이타 속성에 사용할 접두사.</ko>\n  */\n\tfunction InfiniteGrid(element, options) {\n\t\t_classCallCheck(this, InfiniteGrid);\n\n\t\tvar _this = _possibleConstructorReturn(this, _Component.call(this));\n\n\t\t_extends(_this.options = {\n\t\t\titemSelector: "*",\n\t\t\tisOverflowScroll: false,\n\t\t\tthreshold: 100,\n\t\t\tisEqualSize: false,\n\t\t\tuseRecycle: true,\n\t\t\thorizontal: false,\n\t\t\tattributePrefix: "data-"\n\t\t}, options);\n\t\t_this.options.useFit = !_consts.DEFENSE_BROWSER;\n\t\t_consts.IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\t\t_this._reset();\n\t\t_this._loadingBar = {};\n\n\t\tvar _this$options = _this.options,\n\t\t    isOverflowScroll = _this$options.isOverflowScroll,\n\t\t    isEqualSize = _this$options.isEqualSize,\n\t\t    horizontal = _this$options.horizontal,\n\t\t    threshold = _this$options.threshold,\n\t\t    useRecycle = _this$options.useRecycle;\n\n\n\t\t_this._items = new _ItemManager2["default"]();\n\t\t_this._renderer = new _DOMRenderer2["default"](element, {\n\t\t\tisOverflowScroll: isOverflowScroll,\n\t\t\tisEqualSize: isEqualSize,\n\t\t\thorizontal: horizontal\n\t\t});\n\t\t_this._watcher = new _Watcher2["default"](_this._renderer.view, {\n\t\t\tisOverflowScroll: isOverflowScroll,\n\t\t\thorizontal: horizontal,\n\t\t\tcontainer: _this._renderer.container,\n\t\t\tresize: function resize() {\n\t\t\t\treturn _this._onResize();\n\t\t\t},\n\t\t\tcheck: function check(param) {\n\t\t\t\treturn _this._onCheck(param);\n\t\t\t}\n\t\t});\n\n\t\t_this._infinite = new _Infinite2["default"](_this._items, {\n\t\t\thorizontal: horizontal,\n\t\t\tuseRecycle: useRecycle,\n\t\t\tthreshold: threshold,\n\t\t\tappend: function append(param) {\n\t\t\t\treturn _this._requestAppend(param);\n\t\t\t},\n\t\t\tprepend: function prepend(param) {\n\t\t\t\treturn _this._requestPrepend(param);\n\t\t\t},\n\t\t\trecycle: function recycle(param) {\n\t\t\t\treturn _this._recycle(param);\n\t\t\t}\n\t\t});\n\t\treturn _this;\n\t}\n\t/**\n  * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n  * @ko 카드 엘리먼트를 레이아웃 아래에 추가한다. isProcessing() 메서드의 반환값이 \'false\'일 때만 이 메서드를 사용할 수 있다\n  * 이 메소드는 isProcessing()의 반환값이 false일 경우에만 사용 가능하다.\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트의 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n  * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.append("&lt;div class=\'item\'&gt;test1&lt;/div&gt;&lt;div class=\'item\'&gt;test2&lt;/div&gt;");\n  * infinitegrid.append(["&lt;div class=\'item\'&gt;test1&lt;/div&gt;", "&lt;div class=\'item\'&gt;test2&lt;/div&gt;"]);\n  * infinitegrid.append([HTMLElement1, HTMLElement2]);\n  * infinitegrid.append(jQuery(["&lt;div class=\'item\'&gt;test1&lt;/div&gt;", "&lt;div class=\'item\'&gt;test2&lt;/div&gt;"]));\n  */\n\n\n\tInfiniteGrid.prototype.append = function append(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, _consts.APPEND, groupKey);\n\t\treturn this;\n\t};\n\t/**\n  * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n  * @ko 카드 엘리먼트를 레이아웃의 위에 추가한다. isProcessing() 메서드의 반환값이 \'false\'일 때만 이 메서드를 사용할 수 있다\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n  * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.prepend("&lt;div class=\'item\'&gt;test1&lt;/div&gt;&lt;div class=\'item\'&gt;test2&lt;/div&gt;");\n  * infinitegrid.prepend(["&lt;div class=\'item\'&gt;test1&lt;/div&gt;", "&lt;div class=\'item\'&gt;test2&lt;/div&gt;"]);\n  * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n  * infinitegrid.prepend(jQuery(["&lt;div class=\'item\'&gt;test1&lt;/div&gt;", "&lt;div class=\'item\'&gt;test2&lt;/div&gt;"]));\n  */\n\n\n\tInfiniteGrid.prototype.prepend = function prepend(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, _consts.PREPEND, groupKey);\n\t\treturn this;\n\t};\n\t/**\n  * Specifies the Layout class to use.\n  * @ko 사용할 Layout 클래스를 지정한다.\n  * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko>사용할 Layout 클래스 또는 레이아웃 모듈의 인스턴스</ko>\n  * @param {Object} options Options to apply to the Layout.<ko>Layout에 적용할 옵션</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n  *  margin: 10,\n  *  align: "start"\n  * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  *  margin: 10,\n  *  minSize: 100,\n  *  maxSize: 200\n  * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n  *  margin: 10,\n  *  column: 2\n  * });\n  * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n  *  margin: 10,\n  *  frame: [\n  *   [1, 2],\n   *   [4, 3],\n  *  ]\n  * });\n  * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n  *  margin: 10,\n  *  aspectRatio: 1.5\n  * });\n  * var layout = new eg.InfiniteGrid.GridLayout({\n  * \tmargin: 10,\n  *\talign: "start"\n  * });\n  * infinitegrid.setLayout(layout);\n  */\n\n\n\tInfiniteGrid.prototype.setLayout = function setLayout(LayoutKlass) {\n\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tif (typeof LayoutKlass === "function") {\n\t\t\tthis._layout = new LayoutKlass(_extends(options, {\n\t\t\t\thorizontal: this.options.horizontal\n\t\t\t}));\n\t\t} else {\n\t\t\tthis._layout = LayoutKlass;\n\t\t\tthis._layout.options.horizontal = this.options.horizontal;\n\t\t}\n\t\tthis._renderer.resize();\n\t\tthis._setSize(this._renderer.getViewportSize());\n\t\treturn this;\n\t};\n\n\tInfiniteGrid.prototype._setSize = function _setSize(size) {\n\t\tthis._infinite.setSize(this._renderer.getViewSize());\n\t\tthis._layout.setSize(size);\n\t};\n\t/**\n  * Returns the layouted items.\n  * @ko 레이아웃된 아이템들을 반환한다.\n  * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>캐싱된 아이템을 포함할지 여부를 나타낸다.</ko>\n  * @returns {Array} List of items <ko>아이템의 목록</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getItems = function getItems() {\n\t\tvar includeCached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\treturn includeCached ? this._items.pluck("items") : this._infinite.getVisibleItems();\n\t};\n\n\tInfiniteGrid.prototype._fitItems = function _fitItems(base) {\n\t\tvar margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\tbase > 0 && this._watcher.scrollBy(-base);\n\t\tthis._items.fit(base, this.options.horizontal);\n\t\t_DOMRenderer2["default"].renderItems(this.getItems());\n\t\tthis._renderer.setContainerSize(this._getEdgeValue("end") || margin);\n\t\tbase < 0 && this._watcher.scrollBy(-base);\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._fit = function _fit() {\n\t\t// for caching\n\t\tif (!this._layout) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar base = this._getEdgeValue("start");\n\t\tvar margin = this._getLoadingStatus() === _consts.LOADING_PREPEND && this._status.loadingSize || 0;\n\n\t\tif (!this.options.useRecycle || !this.options.useFit) {\n\t\t\tif (base < margin) {\n\t\t\t\tthis._fitItems(base - margin, margin);\n\t\t\t}\n\t\t\tbase = 0;\n\t\t} else if (base !== 0 || margin) {\n\t\t\tvar isProcessing = this._isProcessing();\n\n\t\t\tthis._process(_consts.PROCESSING);\n\t\t\t// "before" is base > 0\n\t\t\t// "after" is base < 0\n\t\t\tthis._fitItems(base - margin, margin);\n\t\t\tif (!isProcessing) {\n\t\t\t\tthis._process(_consts.PROCESSING, false);\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tthis._isLoading() && this._renderLoading();\n\t\treturn base;\n\t};\n\n\tInfiniteGrid.prototype._getEdgeValue = function _getEdgeValue(cursor) {\n\t\treturn this._infinite.getEdgeValue(cursor);\n\t};\n\t/**\n  * Rearranges a layout.\n  * @ko 레이아웃을 다시 배치한다.\n  * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>카드 엘리먼트 재배치 여부</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.layout = function layout() {\n\t\tvar isRelayout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\tif (!this._layout) {\n\t\t\treturn this;\n\t\t}\n\t\tvar renderer = this._renderer;\n\t\tvar itemManager = this._items;\n\n\t\t// check childElement\n\t\tif (!this._items.size()) {\n\t\t\tthis._insert((0, _utils.toArray)(renderer.container.children), true);\n\t\t\treturn this;\n\t\t}\n\t\tvar data = void 0;\n\t\tvar outline = void 0;\n\n\t\tvar infinite = this._infinite;\n\t\tvar items = this.getItems();\n\t\tvar isEqualSize = this.options.isEqualSize;\n\n\t\tif (!items.length) {\n\t\t\treturn this;\n\t\t}\n\t\tif (isRelayout) {\n\t\t\t// remove cache\n\t\t\tif (isEqualSize) {\n\t\t\t\trenderer.updateSize([items[0]]);\n\t\t\t\tdata = itemManager.get();\n\t\t\t\toutline = itemManager.getOutline(0, "start");\n\t\t\t} else {\n\t\t\t\tdata = infinite.getVisibleData();\n\t\t\t}\n\t\t\tif (renderer.resize()) {\n\t\t\t\tthis._setSize(renderer.getViewportSize());\n\t\t\t\tdata.forEach(function (v) {\n\t\t\t\t\tdata.items = renderer.updateSize(v.items);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tdata = infinite.getVisibleData();\n\t\t\toutline = infinite.getEdgeOutline("start");\n\t\t}\n\t\tif (!data.length) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._layout.layout(data, outline);\n\n\t\tif (isRelayout) {\n\t\t\tif (isEqualSize) {\n\t\t\t\tthis._fit();\n\t\t\t} else {\n\t\t\t\tvar startCursor = infinite.getCursor("start");\n\t\t\t\tvar endCursor = infinite.getCursor("end");\n\n\t\t\t\titemManager._data.forEach(function (group, cursor) {\n\t\t\t\t\tif (startCursor <= cursor && cursor <= endCursor) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tgroup.outlines.start = [];\n\t\t\t\t\tgroup.outlines.end = [];\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tthis._onLayoutComplete({\n\t\t\titems: items,\n\t\t\tisAppend: _consts.APPEND,\n\t\t\tfromCache: _consts.CACHE,\n\t\t\tisTrusted: _consts.NO_TRUSTED,\n\t\t\tuseRecycle: false,\n\t\t\tisLayout: true\n\t\t});\n\t\t_DOMRenderer2["default"].renderItems(items);\n\t\tisRelayout && this._watcher.setScrollPos();\n\n\t\treturn this;\n\t};\n\t/**\n  * Removes a item element on a grid layout.\n  * @ko 그리드 레이아웃의 카드 엘리먼트를 삭제한다.\n  * @param {HTMLElement} item element to be removed <ko>삭제될 아이템 엘리먼트</ko>\n  * @return {Object}  Removed item element <ko>삭제된 아이템 엘리먼트 정보</ko>\n  */\n\n\n\tInfiniteGrid.prototype.remove = function remove(element) {\n\t\tvar isLayout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tif (element) {\n\t\t\tvar items = this._infinite.remove(element);\n\n\t\t\titems && _DOMRenderer2["default"].removeElement(element);\n\t\t\tisLayout && this.layout(false);\n\t\t\treturn items;\n\t\t}\n\t\treturn null;\n\t};\n\t/**\n  * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n  * @ko 현재 유지하고 있는 카드 엘리먼트의 그룹 키 목록을 반환한다. 여러 개의 카드 엘리먼트를 묶어서 관리할 수 있도록 append() 메서드나 prepend() 메서드에서 그룹 키를 지정할 수 있다. append() 메서드나 prepend() 메서드에서 그룹 키를 지정하지 않았다면 자동으로 그룹키가 생성된다.\n  * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>캐싱된 그룹을 포함할지 여부를 나타낸다.</ko>\n  * @return {Array} List of group keys <ko>그룹 키의 목록</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getGroupKeys = function getGroupKeys(includeCached) {\n\t\tvar data = includeCached ? this._items.get() : this._infinite.getVisibleData();\n\n\t\treturn data.map(function (v) {\n\t\t\treturn v.groupKey;\n\t\t});\n\t};\n\t/**\n  * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n  * @ko 카드의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n  * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\toptions: _extends({}, this.options),\n\t\t\t_status: _extends({}, this._status),\n\t\t\t_items: this._items.getStatus(),\n\t\t\t_renderer: this._renderer.getStatus(),\n\t\t\t_watcher: this._watcher.getStatus(),\n\t\t\t_infinite: this._infinite.getStatus()\n\t\t};\n\t};\n\t/**\n  * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n  * @ko getStatue() 메서드가 저장한 정보로 eg.InfiniteGrid 모듈의 상태를 설정한다.\n  * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>스크롤의 위치를 복원할지 결정한다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.setStatus = function setStatus(status) {\n\t\tvar applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tif (!status) {\n\t\t\treturn this;\n\t\t}\n\t\tvar options = status.options,\n\t\t    _status = status._status,\n\t\t    _renderer = status._renderer,\n\t\t    _items = status._items,\n\t\t    _watcher = status._watcher,\n\t\t    _infinite = status._infinite;\n\n\n\t\tif (!_status || !_renderer || !_items || !_watcher || !_infinite) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._watcher.detachEvent();\n\t\t_extends(this.options, options);\n\t\t_extends(this._status, _status);\n\t\tthis._items.setStatus(_items);\n\t\tthis._renderer.setStatus(_renderer);\n\t\tthis._infinite.setStatus(_infinite);\n\t\tthis._renderer.createAndInsert(this.getItems());\n\t\tthis._watcher.setStatus(_watcher, applyScrollPos);\n\t\tthis._watcher.attachEvent();\n\t\treturn this;\n\t};\n\t/**\n  * Clears added card elements and data.\n  * @ko 추가된 카드 엘리먼트와 데이터를 모두 지운다.\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.clear = function clear() {\n\t\tthis._items.clear();\n\t\tthis._renderer.clear();\n\t\tthis._infinite.clear();\n\t\tthis._reset();\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t};\n\t/**\n  * Specifies the Loading Bar to use for append or prepend items.\n  * @ko 아이템을 append 또는 prepend 하기 위해 사용할 로딩 바를 지정한다.\n  * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko> 로딩 바 HTML 또는 element 또는 selector </ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.setLoadingBar = function setLoadingBar() {\n\t\tvar userLoadingBar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\tvar loadingBarObj = (typeof userLoadingBar === "undefined" ? "undefined" : _typeof(userLoadingBar)) === "object" ? userLoadingBar : {\n\t\t\t"append": userLoadingBar,\n\t\t\t"prepend": userLoadingBar\n\t\t};\n\n\t\tthis._status.loadingSize = 0;\n\t\tthis._status.loadingStyle = {};\n\t\tvar loadingBar = this._loadingBar;\n\n\t\tfor (var type in loadingBarObj) {\n\t\t\tloadingBar[type] = (0, _utils.$)(loadingBarObj[type]);\n\t\t\tloadingBar[type].className += " " + _consts.IGNORE_CLASSNAME;\n\t\t}\n\t\tthis._appendLoadingBar();\n\t\treturn this;\n\t};\n\n\tInfiniteGrid.prototype._appendLoadingBar = function _appendLoadingBar() {\n\t\tvar loadingBar = this._loadingBar;\n\t\tvar container = this._renderer.container;\n\n\t\tfor (var type in loadingBar) {\n\t\t\tcontainer.appendChild(loadingBar[type]);\n\t\t}\n\t};\n\t/**\n  * Checks whether a card element or data is being added.\n  * @ko 카드 엘리먼트 추가 또는 데이터 로딩이 진행 중인지 확인한다\n  * @return {Boolean} Indicates whether a card element or data is being added <ko>카드 엘리먼트 추가 또는 데이터 로딩 진행 중 여부</ko>\n  */\n\n\n\tInfiniteGrid.prototype.isProcessing = function isProcessing() {\n\t\treturn this._isProcessing() || this._isLoading();\n\t};\n\n\tInfiniteGrid.prototype._isProcessing = function _isProcessing() {\n\t\treturn (this._status.processingStatus & _consts.PROCESSING) > 0;\n\t};\n\n\tInfiniteGrid.prototype._isLoading = function _isLoading() {\n\t\treturn this._getLoadingStatus() > 0;\n\t};\n\n\tInfiniteGrid.prototype._getLoadingStatus = function _getLoadingStatus() {\n\t\treturn this._status.processingStatus & (_consts.LOADING_APPEND | _consts.LOADING_PREPEND);\n\t};\n\n\tInfiniteGrid.prototype._process = function _process(status) {\n\t\tvar isAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tif (isAdd) {\n\t\t\tthis._status.processingStatus |= status;\n\t\t} else {\n\t\t\tthis._status.processingStatus -= this._status.processingStatus & status;\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._insert = function _insert(elements, isAppend, groupKey) {\n\t\tif (this._isProcessing() || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar key = typeof groupKey === "undefined" ? new Date().getTime() + Math.floor(Math.random() * 1000) : groupKey;\n\t\tvar items = _ItemManager2["default"].from(elements, this.options.itemSelector, {\n\t\t\tisAppend: isAppend,\n\t\t\tgroupKey: key\n\t\t});\n\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._postLayout({\n\t\t\tfromCache: _consts.NO_CACHE,\n\t\t\titems: items,\n\t\t\tisAppend: isAppend,\n\t\t\tisTrusted: _consts.NO_TRUSTED\n\t\t});\n\t};\n\t// add items, and remove items for recycling\n\n\n\tInfiniteGrid.prototype._recycle = function _recycle(_ref) {\n\t\tvar start = _ref.start,\n\t\t    end = _ref.end;\n\n\t\tif (!this.options.useRecycle) {\n\t\t\treturn;\n\t\t}\n\t\t_DOMRenderer2["default"].removeItems(this._items.pluck("items", start, end));\n\t};\n\t/**\n  * Returns the element of loading bar.\n  * @ko 로딩 바의 element를 반환한다.\n  * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n  * @return {Element} The element of loading bar. <ko>로딩 바의 element</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getLoadingBar = function getLoadingBar() {\n\t\tvar isAppend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._getLoadingStatus() !== _consts.LOADING_PREPEND;\n\n\t\treturn this._loadingBar[isAppend ? "append" : "prepend"];\n\t};\n\t/**\n  * Start loading for append/prepend during loading data.\n  * @ko 데이터가 로딩되는 동안 append/prepend하길 위해 로딩을 시작한다.\n  * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>카드 엘리먼트가 append() 메서드로 추가 할 것인지 확인한다.</ko>\n  * @param {Object} [userStyle = {display: "block"}] custom style to apply to this loading bar for start. <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.startLoading = function startLoading(isAppend) {\n\t\tvar userStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { display: "block" };\n\n\t\tif (this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tvar type = isAppend ? "append" : "prepend";\n\n\t\tthis._process(isAppend ? _consts.LOADING_APPEND : _consts.LOADING_PREPEND);\n\t\tif (!this._loadingBar[type]) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._renderLoading(userStyle);\n\t\tthis._status.loadingStyle = userStyle;\n\t\tif (!isAppend) {\n\t\t\tthis._fit();\n\t\t} else {\n\t\t\tthis._renderer.setContainerSize(this._getEdgeValue("end") + this._status.loadingSize);\n\t\t}\n\t\treturn this;\n\t};\n\n\tInfiniteGrid.prototype._renderLoading = function _renderLoading() {\n\t\tvar _extends2;\n\n\t\tvar userStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._status.loadingStyle;\n\n\t\tif (!this._isLoading()) {\n\t\t\treturn;\n\t\t}\n\t\tvar isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;\n\t\tvar el = this._loadingBar[isAppend ? "append" : "prepend"];\n\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\tthis._status.loadingSize = this.options.horizontal ? (0, _utils.innerWidth)(el) : (0, _utils.innerHeight)(el);\n\t\tvar pos = isAppend ? this._getEdgeValue("end") : this._getEdgeValue("start") - this._status.loadingSize;\n\t\tvar style = _extends((_extends2 = {\n\t\t\tposition: "absolute"\n\t\t}, _extends2[this.options.horizontal ? "left" : "top"] = pos + "px", _extends2), userStyle);\n\n\t\tfor (var property in style) {\n\t\t\tel.style[property] = style[property];\n\t\t}\n\t};\n\t/**\n  * End loading after startLoading() for append/prepend\n  * @ko  append/prepend하길 위해 startLoading() 호출해선 걸었던 로딩을 끝낸다.\n  * @param {Object} [userStyle = {display: "none"}] custom style to apply to this loading bar for end <ko> 로딩 시작을 위한 로딩 바에 적용할 커스텀 스타일 </ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.endLoading = function endLoading() {\n\t\tvar userStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { display: "none" };\n\n\t\tif (!this._isLoading()) {\n\t\t\treturn this;\n\t\t}\n\t\tvar isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;\n\t\tvar type = isAppend ? "append" : "prepend";\n\t\tvar el = this._loadingBar[type];\n\t\tvar status = this._status;\n\t\tvar size = status.loadingSize;\n\n\t\tthis._process(_consts.LOADING_APPEND | _consts.LOADING_PREPEND, false);\n\t\tstatus.loadingSize = 0;\n\t\tstatus.loadingStyle = {};\n\t\tif (el) {\n\t\t\tvar _extends3;\n\n\t\t\tvar style = _extends((_extends3 = {}, _extends3[this.options.horizontal ? "left" : "top"] = -size + "px", _extends3), userStyle);\n\n\t\t\tfor (var property in style) {\n\t\t\t\tel.style[property] = style[property];\n\t\t\t}\n\t\t\tif (!isAppend) {\n\t\t\t\tthis._fitItems(size);\n\t\t\t} else {\n\t\t\t\tthis._renderer.setContainerSize(this._getEdgeValue("end"));\n\t\t\t}\n\t\t}\n\t\tif (this.options.useRecycle && !this.isProcessing()) {\n\t\t\tthis._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n\t\t}\n\t\treturn this;\n\t};\n\t/**\n  * Move to some group or item position.\n  * @ko 해당하는 그룹 또는 아이템의 위치로 이동한다.\n  * @param {Number} [index] group\'s index <ko> 그룹의 index</ko>\n  * @param {Number} [itemIndex=-1] item\'s index <ko> 그룹의 index</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.moveTo = function moveTo(index) {\n\t\tvar itemIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n\t\tif (this.isProcessing()) {\n\t\t\treturn this;\n\t\t}\n\t\tvar data = this._items.getData(index);\n\n\t\tif (!data) {\n\t\t\treturn this;\n\t\t}\n\t\tvar infinite = this._infinite;\n\t\tvar outlines = data.outlines;\n\t\tvar item = data.items[itemIndex];\n\t\tvar isResize = outlines.start && outlines.start.length === 0;\n\t\tvar startCursor = infinite.getCursor("start");\n\t\tvar endCursor = infinite.getCursor("end");\n\t\tvar isInCursor = startCursor <= index && index <= endCursor;\n\t\tvar _options = this.options,\n\t\t    useRecycle = _options.useRecycle,\n\t\t    isEqualSize = _options.isEqualSize,\n\t\t    horizontal = _options.horizontal;\n\n\n\t\tif (isInCursor || !useRecycle || isEqualSize || !isResize) {\n\t\t\tvar pos = item && item.rect[horizontal ? "left" : "top"];\n\n\t\t\tif (typeof pos === "undefined") {\n\t\t\t\tpos = Math.max.apply(Math, outlines.start);\n\t\t\t}\n\t\t\tvar fit = Math.min.apply(Math, outlines.start);\n\n\t\t\tif (fit < 0) {\n\t\t\t\t// base < 0\n\t\t\t\tthis._fitItems(fit, 0);\n\t\t\t\tpos -= fit;\n\t\t\t}\n\t\t\tif (!isInCursor && useRecycle) {\n\t\t\t\tvar isAppend = index > startCursor;\n\n\t\t\t\tif (isAppend) {\n\t\t\t\t\t// append\n\t\t\t\t\tif (endCursor + 1 < index) {\n\t\t\t\t\t\tinfinite.setCursor("start", index);\n\t\t\t\t\t\t// prepare append\n\t\t\t\t\t\tinfinite.setCursor("end", index - 1);\n\t\t\t\t\t}\n\t\t\t\t\t// recycle previous items\n\t\t\t\t\tthis._recycle({ start: 0, end: index - 1 });\n\t\t\t\t} else if (index + 1 < startCursor) {\n\t\t\t\t\t// prepare prepend\n\t\t\t\t\tinfinite.setCursor("start", index + 1);\n\t\t\t\t\tinfinite.setCursor("end", index);\n\t\t\t\t}\n\t\t\t\tthis._postCache({\n\t\t\t\t\tisAppend: isAppend,\n\t\t\t\t\toutline: outlines[isAppend ? "start" : "end"],\n\t\t\t\t\tcache: data,\n\t\t\t\t\tisTrusted: _consts.NO_TRUSTED,\n\t\t\t\t\tmoveItem: itemIndex\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tpos = Math.max(Math.min(pos, this._getEdgeValue("end") - this._renderer.getViewSize()), 0);\n\t\t\tthis._scrollTo(pos);\n\t\t} else if (isResize) {\n\t\t\tvar _isAppend = index > endCursor;\n\t\t\tvar outline = [0];\n\n\t\t\tif (_isAppend) {\n\t\t\t\tinfinite.setCursor("start", index);\n\t\t\t\tinfinite.setCursor("end", index - 1);\n\t\t\t\tthis._recycle({ start: 0, end: index - 1 });\n\t\t\t} else {\n\t\t\t\tinfinite.setCursor("start", index + 1);\n\t\t\t\tinfinite.setCursor("end", index);\n\t\t\t\tthis._recycle({ start: index + 1, end: this._items.size() });\n\t\t\t}\n\t\t\tthis._postLayout({\n\t\t\t\toutline: outline,\n\t\t\t\tisAppend: _isAppend,\n\t\t\t\tfromCache: _consts.CACHE,\n\t\t\t\titems: data.items,\n\t\t\t\tisTrusted: _consts.TRUSTED,\n\t\t\t\tmoveItem: itemIndex\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t};\n\n\tInfiniteGrid.prototype._setScrollPos = function _setScrollPos(pos) {\n\t\tthis._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n\t};\n\n\tInfiniteGrid.prototype._scrollTo = function _scrollTo(pos) {\n\t\tthis._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n\t};\n\n\tInfiniteGrid.prototype._postLayoutComplete = function _postLayoutComplete(_ref2) {\n\t\tvar layouted = _ref2.layouted,\n\t\t    isAppend = _ref2.isAppend,\n\t\t    isTrusted = _ref2.isTrusted,\n\t\t    fromCache = _ref2.fromCache,\n\t\t    _ref2$moveItem = _ref2.moveItem,\n\t\t    moveItem = _ref2$moveItem === undefined ? -2 : _ref2$moveItem,\n\t\t    _ref2$useRecycle = _ref2.useRecycle,\n\t\t    useRecycle = _ref2$useRecycle === undefined ? this.options.useRecycle : _ref2$useRecycle;\n\n\t\tvar pos = Math.max.apply(Math, layouted.outlines.start);\n\n\t\tif (moveItem > -2) {\n\t\t\tpos = Math.max(Math.min(pos, this._getEdgeValue("end") - this._renderer.getViewSize()), 0);\n\t\t\tif (!isAppend) {\n\t\t\t\tthis._setScrollPos(pos + 0.1);\n\t\t\t\tthis._scrollTo(pos + 0.1);\n\t\t\t} else if (pos > 0) {\n\t\t\t\tthis._setScrollPos(pos - 0.1);\n\t\t\t}\n\t\t}\n\t\tvar items = layouted.items;\n\n\t\tthis._onLayoutComplete({ items: items, isAppend: isAppend, fromCache: fromCache, isTrusted: isTrusted, useRecycle: useRecycle });\n\t\tif (moveItem > -2) {\n\t\t\t!isAppend && (pos = Math.max.apply(Math, layouted.outlines.start));\n\t\t\tvar movePos = pos;\n\n\t\t\tif (items[moveItem]) {\n\t\t\t\tmovePos = items[moveItem].rect[this.options.horizotnal ? "left" : "top"];\n\t\t\t}\n\t\t\tmovePos = Math.max(Math.min(movePos, this._getEdgeValue("end") - this._renderer.getViewSize()), 0);\n\t\t\tif (isAppend) {\n\t\t\t\tthis._scrollTo(movePos);\n\t\t\t} else {\n\t\t\t\tthis._infinite.scroll(movePos, true);\n\t\t\t\tthis._scrollTo(movePos);\n\t\t\t\tthis._recycle({ start: this._infinite.getCursor("end") + 1, end: this._items.size() - 1 });\n\t\t\t}\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._postImageLoaded = function _postImageLoaded(fromCache, layouted, items, isAppend, isTrusted) {\n\t\tvar moveItem = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -2;\n\n\t\tvar groupKey = layouted.items && layouted.items[0].groupKey || 0;\n\n\t\tlayouted.groupKey = groupKey;\n\t\tif (fromCache) {\n\t\t\tthis._infinite.setData(layouted, isAppend);\n\t\t} else {\n\t\t\tthis._infinite[isAppend ? "append" : "prepend"](layouted);\n\t\t}\n\t\t_DOMRenderer2["default"].renderItems(layouted.items);\n\t\tthis._postLayoutComplete({ layouted: layouted, isAppend: isAppend, fromCache: fromCache, isTrusted: isTrusted, moveItem: moveItem, useRecycle: false });\n\t};\n\n\tInfiniteGrid.prototype._onImageError = function _onImageError(target, item, itemIndex, removeTarget, replaceTarget) {\n\t\tvar element = item.el;\n\t\tvar prefix = this.options.attributePrefix;\n\n\t\titem.content = element.outerHTML;\n\n\t\tvar removeItem = function removeItem() {\n\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveTarget.push(element);\n\t\t\tvar index = replaceTarget.indexOf(itemIndex);\n\n\t\t\tif (index !== -1) {\n\t\t\t\treplaceTarget.splice(index, 1);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * This event is fired when an error occurs in the image.\n   * @ko 이미지 로드에 에러가 날 때 발생하는 이벤트.\n   * @event eg.InfiniteGrid#imageError\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Element} param.target Appending card\'s image element.<ko>추가 되는 카드의 이미지 엘리먼트</ko>\n   * @param {Element} param.elememt The item\'s element with error images.<ko>에러난 이미지를 가지고 있는 아이템의 엘리먼트</ko>\n   * @param {Object} param.item The item with error images.<ko>에러난 이미지를 가지고 있는 아이템</ko>\n   * @param {Number} param.itemIndex The item\'s index with error images.<ko>에러난 이미지를 가지고 있는 아이템의 인덱스</ko>\n   * @param {Function} param.remove In the imageError event, this method expects to remove the error image.<ko>이미지 에러 이벤트에서 이 메서드는 에러난 이미지를 삭제한다.</ko>\n   * @param {Function} param.removeItem In the imageError event, this method expects to remove the item with the error image.<ko>이미지 에러 이벤트에서 이 메서드는 에러난 이미지를 가지고 있는 아이템을 삭제한다.</ko>\n   * @param {Function} param.replace In the imageError event, this method expects to replace the error image\'s source or element.<ko>이미지 에러 이벤트에서 이 메서드는 에러난 이미지의 주소 또는 엘리먼트를 교체한다.</ko>\n   * @param {Function} param.replaceItem In the imageError event, this method expects to replace the item\'s contents with the error image.<ko>이미지 에러 이벤트에서 이 메서드는 에러난 이미지를 가지고 있는 아이템의 내용을 교체한다.</ko>\n   * @example\n  ig.on("imageError", e => {\n  e.remove();\n  e.removeItem();\n  e.replace("http://...jpg");\n  e.replace(imageElement);\n  e.replaceItem("item html");\n  });\n   */\n\t\tthis.trigger("imageError", {\n\t\t\ttarget: target,\n\t\t\telement: element,\n\t\t\titem: item,\n\t\t\titemIndex: itemIndex,\n\t\t\t// remove item\n\t\t\tremoveItem: removeItem,\n\t\t\t// remove image\n\t\t\tremove: function remove() {\n\t\t\t\tif (target === element) {\n\t\t\t\t\tremoveItem();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttarget.parentNode.removeChild(target);\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\tif (hasTarget([replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t},\n\t\t\t// replace image\n\t\t\treplace: function replace(src) {\n\t\t\t\tif (hasTarget([removeTarget, element])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (src) {\n\t\t\t\t\tif ((0, _utils.matchHTML)(src) || (typeof src === "undefined" ? "undefined" : _typeof(src)) === "object") {\n\t\t\t\t\t\tvar parentNode = target.parentNode;\n\n\t\t\t\t\t\tparentNode.insertBefore((0, _utils.$)(src), target);\n\t\t\t\t\t\tparentNode.removeChild(target);\n\t\t\t\t\t\titem.content = element.outerHTML;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.src = src;\n\t\t\t\t\t\tif (target.getAttribute(prefix + "width")) {\n\t\t\t\t\t\t\t_AutoSizer2["default"].remove(target);\n\t\t\t\t\t\t\ttarget.removeAttribute(prefix + "width");\n\t\t\t\t\t\t\ttarget.removeAttribute(prefix + "height");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\tif (hasTarget([replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t},\n\t\t\t// replace item\n\t\t\treplaceItem: function replaceItem(content) {\n\t\t\t\tif (hasTarget([removeTarget, element], [replaceTarget, itemIndex])) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telement.innerHTML = content;\n\t\t\t\titem.content = element.outerHTML;\n\t\t\t\treplaceTarget.push(itemIndex);\n\t\t\t}\n\t\t});\n\t};\n\n\tInfiniteGrid.prototype._postImageLoadedEnd = function _postImageLoadedEnd(items, isAppend, removeTarget, replaceTarget) {\n\t\tvar _this2 = this;\n\n\t\tvar scrollPos = this._watcher.getScrollPos();\n\t\tvar _options2 = this.options,\n\t\t    useRecycle = _options2.useRecycle,\n\t\t    isEqualSize = _options2.isEqualSize,\n\t\t    attributePrefix = _options2.attributePrefix;\n\n\n\t\tif (!removeTarget.length && !replaceTarget.length) {\n\t\t\tif (!this.isProcessing() && useRecycle) {\n\t\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar layoutedItems = replaceTarget.map(function (itemIndex) {\n\t\t\treturn items[itemIndex];\n\t\t});\n\n\t\tremoveTarget.forEach(function (element) {\n\t\t\t_this2.remove(element, false);\n\t\t});\n\t\tif (isEqualSize) {\n\t\t\tif (removeTarget.length > 0) {\n\t\t\t\tthis.layout(false);\n\t\t\t} else if (!this.isProcessing() && useRecycle) {\n\t\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// wait layoutComplete beacause of error event.\n\t\t_ImageLoaded2["default"].check(layoutedItems.map(function (v) {\n\t\t\treturn v.el;\n\t\t}), {\n\t\t\tprefix: attributePrefix,\n\t\t\tcomplete: function complete() {\n\t\t\t\t_this2._renderer.updateSize(layoutedItems);\n\t\t\t\t_this2.layout(false);\n\t\t\t}\n\t\t});\n\t};\n\n\tInfiniteGrid.prototype._postCache = function _postCache(_ref3) {\n\t\tvar cache = _ref3.cache,\n\t\t    isAppend = _ref3.isAppend,\n\t\t    _ref3$isTrusted = _ref3.isTrusted,\n\t\t    isTrusted = _ref3$isTrusted === undefined ? true : _ref3$isTrusted,\n\t\t    _ref3$outline = _ref3.outline,\n\t\t    outline = _ref3$outline === undefined ? this._infinite.getEdgeOutline(isAppend ? "end" : "start") : _ref3$outline,\n\t\t    _ref3$moveItem = _ref3.moveItem,\n\t\t    moveItem = _ref3$moveItem === undefined ? -2 : _ref3$moveItem;\n\n\t\tvar cacheOutline = cache.outlines[isAppend ? "start" : "end"];\n\n\t\tvar fromRelayout = outline.length === cacheOutline.length ? !outline.every(function (v, index) {\n\t\t\treturn v === cacheOutline[index];\n\t\t}) : true;\n\n\t\tif (!fromRelayout) {\n\t\t\tthis._infinite.updateCursor(isAppend ? "end" : "start");\n\t\t\tthis._renderer.createAndInsert(cache.items, isAppend);\n\t\t\tthis._postLayoutComplete({ layouted: cache, isAppend: isAppend, isTrusted: isTrusted, moveItem: moveItem });\n\t\t\treturn;\n\t\t}\n\t\tthis._postLayout({\n\t\t\tfromCache: _consts.CACHE,\n\t\t\titems: cache.items,\n\t\t\toutline: outline,\n\t\t\tisAppend: isAppend,\n\t\t\tisTrusted: isTrusted,\n\t\t\tmoveItem: moveItem\n\t\t});\n\t};\n\n\tInfiniteGrid.prototype._postLayout = function _postLayout(_ref4) {\n\t\tvar _this3 = this;\n\n\t\tvar fromCache = _ref4.fromCache,\n\t\t    items = _ref4.items,\n\t\t    isAppend = _ref4.isAppend,\n\t\t    _ref4$outline = _ref4.outline,\n\t\t    outline = _ref4$outline === undefined ? this._infinite.getEdgeOutline(isAppend ? "end" : "start") : _ref4$outline,\n\t\t    isTrusted = _ref4.isTrusted,\n\t\t    _ref4$moveItem = _ref4.moveItem,\n\t\t    moveItem = _ref4$moveItem === undefined ? -2 : _ref4$moveItem;\n\n\t\tthis._process(_consts.PROCESSING);\n\t\tvar method = isAppend ? "append" : "prepend";\n\n\t\tfromCache && _DOMRenderer2["default"].createElements(items);\n\t\tthis._renderer[method](items);\n\n\t\t// check image sizes after elements are attated on DOM\n\t\tvar type = this.options.isEqualSize && this._renderer._size.item ? _ImageLoaded.CHECK_ONLY_ERROR : _ImageLoaded.CHECK_ALL;\n\t\tvar prefix = this.options.attributePrefix;\n\t\tvar replaceTarget = [];\n\t\tvar removeTarget = [];\n\t\tvar layouted = void 0;\n\n\t\t_ImageLoaded2["default"].check(items.map(function (item) {\n\t\t\treturn item.el;\n\t\t}), {\n\t\t\tprefix: prefix,\n\t\t\ttype: type,\n\t\t\tcomplete: function complete() {\n\t\t\t\tlayouted = _this3._layout[method](_this3._renderer.updateSize(items), outline);\n\t\t\t\t// no recycle\n\t\t\t\t_this3._postImageLoaded(fromCache, layouted, items, isAppend, isTrusted, moveItem);\n\t\t\t},\n\t\t\terror: function error(_ref5) {\n\t\t\t\tvar target = _ref5.target,\n\t\t\t\t    itemIndex = _ref5.itemIndex;\n\n\t\t\t\tvar item = layouted && layouted.items[itemIndex] || items[itemIndex];\n\n\t\t\t\t_this3._onImageError(target, item, itemIndex, removeTarget, replaceTarget);\n\t\t\t},\n\t\t\tend: function end() {\n\t\t\t\t// recycle\n\t\t\t\t_this3._postImageLoadedEnd(items, isAppend, removeTarget, replaceTarget);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._requestAppend = function _requestAppend(_ref6) {\n\t\tvar cache = _ref6.cache;\n\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache) {\n\t\t\tthis._postCache({ cache: cache, isAppend: _consts.APPEND });\n\t\t} else {\n\t\t\t/**\n    * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n    * @ko 카드 엘리먼트가 레이아웃의 아래나 오른쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 아래나 오른쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다\n    * @event eg.InfiniteGrid#append\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 마지막 그룹의 그룹키</ko>\n    * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n    */\n\t\t\tthis.trigger("append", {\n\t\t\t\tisTrusted: _consts.TRUSTED,\n\t\t\t\tgroupKey: this.getGroupKeys().pop()\n\t\t\t});\n\t\t}\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._requestPrepend = function _requestPrepend(_ref7) {\n\t\tvar cache = _ref7.cache,\n\t\t    _ref7$fit = _ref7.fit,\n\t\t    fit = _ref7$fit === undefined ? true : _ref7$fit;\n\n\t\tif (fit) {\n\t\t\tthis._fit();\n\t\t}\n\t\tif (this._isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tif (cache) {\n\t\t\tthis._postCache({ cache: cache, isAppend: _consts.PREPEND });\n\t\t} else {\n\t\t\t/**\n    * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n    * @ko 카드가 레이아웃의 위나 왼쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 위나 왼쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다.\n    * @event eg.InfiniteGrid#prepend\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>화면에 보여지는 첫번째 그룹의 그룹키</ko>\n    * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n    */\n\t\t\tthis.trigger("prepend", {\n\t\t\t\tisTrusted: _consts.TRUSTED,\n\t\t\t\tgroupKey: this.getGroupKeys().shift()\n\t\t\t});\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._onResize = function _onResize() {\n\t\tthis.layout(true);\n\t};\n\n\tInfiniteGrid.prototype._onCheck = function _onCheck(_ref8) {\n\t\tvar isForward = _ref8.isForward,\n\t\t    scrollPos = _ref8.scrollPos,\n\t\t    horizontal = _ref8.horizontal,\n\t\t    orgScrollPos = _ref8.orgScrollPos;\n\n\t\t/**\n   * This event is fired when the user scrolls.\n   * @ko 사용자가 스크롤 할 경우 발생하는 이벤트.\n   * @event eg.InfiniteGrid#change\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>스크롤 진행방향이 앞쪽으로 진행하는 지, 뒤쪽으로 진행하는지를 나타낸다.</ko>\n   * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n   * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n   * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n   */\n\t\tthis.trigger("change", {\n\t\t\tisForward: isForward,\n\t\t\thorizontal: horizontal,\n\t\t\tscrollPos: scrollPos,\n\t\t\torgScrollPos: orgScrollPos\n\t\t});\n\t\tthis._infinite.scroll(scrollPos, isForward);\n\t};\n\n\tInfiniteGrid.prototype._onLayoutComplete = function _onLayoutComplete(_ref9) {\n\t\tvar items = _ref9.items,\n\t\t    isAppend = _ref9.isAppend,\n\t\t    _ref9$isTrusted = _ref9.isTrusted,\n\t\t    isTrusted = _ref9$isTrusted === undefined ? false : _ref9$isTrusted,\n\t\t    _ref9$useRecycle = _ref9.useRecycle,\n\t\t    useRecycle = _ref9$useRecycle === undefined ? this.options.useRecycle : _ref9$useRecycle,\n\t\t    _ref9$fromCache = _ref9.fromCache,\n\t\t    fromCache = _ref9$fromCache === undefined ? false : _ref9$fromCache,\n\t\t    _ref9$isLayout = _ref9.isLayout,\n\t\t    isLayout = _ref9$isLayout === undefined ? false : _ref9$isLayout;\n\n\t\tvar viewSize = this._renderer.getViewSize();\n\n\t\tif (!isAppend) {\n\t\t\tthis._fit();\n\t\t} else {\n\t\t\tthis._isLoading() && this._renderLoading();\n\t\t}\n\n\t\tvar watcher = this._watcher;\n\t\tvar scrollPos = watcher.getScrollPos();\n\n\t\t// recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\t\tif (!isLayout && useRecycle && !this._isLoading()) {\n\t\t\tthis._infinite.recycle(scrollPos, isAppend);\n\t\t}\n\n\t\tvar size = this._getEdgeValue("end");\n\n\t\tisAppend && this._renderer.setContainerSize(size + this._status.loadingSize || 0);\n\t\t!isLayout && this._process(_consts.PROCESSING, false);\n\n\t\t//  @param {Boolean} param.fromCache Check whether these items are cache or not <ko>해당 아이템들이 캐시인지 아닌지 확인한다.</ko>\n\t\t/**\n   * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n   * @ko 레이아웃 배치가 완료됐을 때 발생하는 이벤트. append() 메서드나 prepend() 메서드, layout() 메서드 호출 후 카드의 배치가 완료됐을 때 발생한다\n   * @event eg.InfiniteGrid#layoutComplete\n   *\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Array} param.target Rearranged card elements<ko>재배치된 카드 엘리먼트들</ko>\n   * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>카드 엘리먼트가 append() 메서드로 추가됐는지 확인한다. layout() 메서드가 호출된 후 layoutComplete 이벤트가 발생해도 \'true\'를 반환한다.</ko>\n   * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend 등 호출 후 스크롤이 생겼는지 확인한다.</ko>\n   * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n   * @param {Number} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n   * @param {Number} param.size The size of container element <ko>컨테이너 엘리먼트의 크기</ko>\n   * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   */\n\t\tthis.trigger("layoutComplete", {\n\t\t\ttarget: items.concat(),\n\t\t\tisAppend: isAppend,\n\t\t\tisTrusted: isTrusted,\n\t\t\tisScroll: viewSize < watcher.getContainerOffset() + size,\n\t\t\tscrollPos: scrollPos,\n\t\t\torgScrollPos: watcher.getOrgScrollPos(),\n\t\t\tsize: size\n\t\t});\n\t\tthis._infinite.scroll(scrollPos, isAppend);\n\t};\n\n\tInfiniteGrid.prototype._reset = function _reset() {\n\t\tthis._status = {\n\t\t\tprocessingStatus: _consts.IDLE,\n\t\t\tloadingSize: 0\n\t\t};\n\t};\n\t/**\n  * Destroys elements, properties, and events used on a grid layout.\n  * @ko 그리드 레이아웃에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n  */\n\n\n\tInfiniteGrid.prototype.destroy = function destroy() {\n\t\tthis.off();\n\t\tthis._infinite.clear();\n\t\tthis._watcher.destroy();\n\t\tthis._reset();\n\t\tthis._items.clear();\n\t\tthis._renderer.destroy();\n\t};\n\n\treturn InfiniteGrid;\n}(_component2["default"]);\n\nInfiniteGrid.VERSION = "3.3.1";\n\nexports["default"] = InfiniteGrid;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n// ALIGN\nvar START = _consts.ALIGN.START,\n    CENTER = _consts.ALIGN.CENTER,\n    END = _consts.ALIGN.END,\n    JUSTIFY = _consts.ALIGN.JUSTIFY;\n\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 카드를 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 카드 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>아이템들의 위치의 정렬 (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid("#grid". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n\tmargin: 10,\n\talign: "start",\n\titemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n\tmargin: 10,\n\talign: "center",\n\titemSize: 200,\n\thorizontal: true,\n});\n\n<\/script>\n```\n **/\n\nvar GridLayout = function () {\n\tfunction GridLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, GridLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\talign: START,\n\t\t\titemSize: 0\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._columnSize = 0;\n\t\tthis._columnLength = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.horizontal);\n\t}\n\n\tGridLayout.prototype.getPoints = function getPoints(outlines) {\n\t\tvar pos = this.options.horizontal ? "left" : "top";\n\n\t\treturn outlines.map(function (outline) {\n\t\t\treturn outline[pos];\n\t\t});\n\t};\n\n\tGridLayout.prototype.checkColumn = function checkColumn(item) {\n\t\tvar _options = this.options,\n\t\t    itemSize = _options.itemSize,\n\t\t    margin = _options.margin,\n\t\t    horizontal = _options.horizontal;\n\n\t\tvar sizeName = horizontal ? "height" : "width";\n\t\tvar columnSize = itemSize || item && item.size[sizeName] || 0;\n\n\t\tthis._columnSize = columnSize;\n\t\tif (!columnSize) {\n\t\t\tthis._columnLength = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);\n\t};\n\n\tGridLayout.prototype._layout = function _layout(items, outline, isAppend) {\n\t\tvar length = items.length;\n\t\tvar margin = this.options.margin;\n\t\tvar align = this.options.align;\n\t\tvar style = this._style;\n\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar columnSize = this._columnSize;\n\t\tvar columnLength = this._columnLength;\n\n\t\tvar size = this._size;\n\t\tvar viewDist = size - (columnSize + margin) * columnLength + margin;\n\n\t\tvar pointCaculateName = isAppend ? "min" : "max";\n\t\tvar startOutline = outline.slice();\n\t\tvar endOutline = outline.slice();\n\t\tvar startIndex = 0;\n\t\tvar endIndex = -1;\n\t\tvar endPos = -1;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar _item$rect;\n\n\t\t\tvar point = Math[pointCaculateName].apply(Math, endOutline) || 0;\n\t\t\tvar index = endOutline.indexOf(point);\n\t\t\tvar item = items[isAppend ? i : length - 1 - i];\n\t\t\tvar size1 = item.size[size1Name];\n\t\t\tvar size2 = item.size[size2Name];\n\t\t\tvar pos1 = isAppend ? point : point - margin - size1;\n\t\t\tvar endPos1 = pos1 + size1 + margin;\n\n\t\t\tif (index === -1) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tvar pos2 = (columnSize + margin) * index;\n\n\t\t\t// ALIGN\n\t\t\tif (align === CENTER) {\n\t\t\t\tpos2 += viewDist / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tpos2 += viewDist + columnSize - size2;\n\t\t\t} else if (align === JUSTIFY) {\n\t\t\t\tif (columnLength <= 1) {\n\t\t\t\t\tpos2 += viewDist / 2;\n\t\t\t\t} else {\n\t\t\t\t\tpos2 = (size - columnSize) / (columnLength - 1) * index;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// tetris\n\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect);\n\t\t\titem.column = index;\n\t\t\tendOutline[index] = isAppend ? endPos1 : pos1;\n\t\t\tif (endIndex === -1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t} else if (endPos < endPos1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t}\n\t\t}\n\t\tif (!isAppend) {\n\t\t\titems.sort(function (a, b) {\n\t\t\t\tvar item1pos1 = a.rect[pos1Name];\n\t\t\t\tvar item1pos2 = a.rect[pos2Name];\n\t\t\t\tvar item2pos1 = b.rect[pos1Name];\n\t\t\t\tvar item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\tendIndex = length - 1;\n\t\t}\n\t\t// if append items, startOutline is low, endOutline is high\n\t\t// if prepend items, startOutline is high, endOutline is low\n\t\treturn {\n\t\t\tstart: isAppend ? startOutline : endOutline,\n\t\t\tend: isAppend ? endOutline : startOutline,\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tGridLayout.prototype._insert = function _insert() {\n\t\tvar items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar type = arguments[2];\n\n\t\tvar clone = (0, _utils.cloneItems)(items);\n\n\t\tvar startOutline = outline;\n\n\t\tif (!this._columnLength) {\n\t\t\tthis.checkColumn(items[0]);\n\t\t}\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tstartOutline = (0, _utils.fill)(new Array(this._columnLength), outline.length === 0 ? 0 : Math[type === _consts.APPEND ? "min" : "max"].apply(Math, outline) || 0);\n\t\t}\n\n\t\tvar result = this._layout(clone, startOutline, type);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: result\n\t\t};\n\t};\n\t/**\n  * Adds items at the bottom of a outline.\n  * @ko 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#append\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\t/**\n  * Adds items at the top of a outline.\n  * @ko 아이템을 아웃라인 위에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#prepend\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\t/**\n  * Adds items of groups at the bottom of a outline.\n  * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#layout\n  * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.layout = function layout() {\n\t\tvar _this = this;\n\n\t\tvar groups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n\t\tvar firstItem = groups.length && groups[0].items.length && groups[0].items[0] || 0;\n\n\t\tthis.checkColumn(firstItem);\n\n\t\t// if outlines\' length and columns\' length are now same, re-caculate outlines.\n\t\tvar startOutline = void 0;\n\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tvar pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline);\n\n\t\t\t// re-layout items.\n\t\t\tstartOutline = (0, _utils.fill)(new Array(this._columnLength), pos);\n\t\t} else {\n\t\t\tstartOutline = outline.slice();\n\t\t}\n\t\tgroups.forEach(function (group) {\n\t\t\tvar items = group.items;\n\t\t\tvar result = _this._layout(items, startOutline, _consts.APPEND);\n\n\t\t\tgroup.outlines = result;\n\t\t\tstartOutline = result.end;\n\t\t});\n\n\t\treturn this;\n\t};\n\t/**\n  * Set the viewport size of the layout.\n  * @ko 레이아웃의 가시 사이즈를 설정한다.\n  * @method eg.InfiniteGrid.GridLayout#setSize\n  * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n  * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.setSize(800);\n  */\n\n\n\tGridLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t};\n\n\treturn GridLayout;\n}();\n\nexports["default"] = GridLayout;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _FrameLayout2 = __webpack_require__(9);\n\nvar _FrameLayout3 = _interopRequireDefault(_FrameLayout2);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n\tvar point = Math[isAppend ? "min" : "max"].apply(Math, outline) || 0;\n\n\tif (outline.length !== columnLength) {\n\t\treturn (0, _utils.fill)(new Array(columnLength), 0);\n\t}\n\treturn outline.map(function (l) {\n\t\treturn parseInt((l - point) / itemSize, 10);\n\t});\n}\nfunction getColumn(item) {\n\tif (item.column) {\n\t\treturn item.column;\n\t}\n\tvar column = 0;\n\n\tif (item.el) {\n\t\tvar dataset = item.el.dataset;\n\n\t\tif (dataset) {\n\t\t\tcolumn = dataset.column || 1;\n\t\t} else {\n\t\t\tcolumn = item.el.getAttribute("column") || 1;\n\t\t}\n\t} else {\n\t\tcolumn = 1;\n\t}\n\titem.column = column;\n\treturn column;\n}\n\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout은 바둑판처럼 모든 카드를 정사각형으로 배치하고 중요한 카드는 크기를 N배로 키워서 보여주는 레이아웃이다. 주요 카드를 크게 표시하고, 그 다음에 작은 카드를 배치해 자연스럽게 카드의 관계를 나타낼 수 있습니다.\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko> 아이템의 사이즈. 만약 아이템 사이즈가 0이면, 아이템들의 첫번째 아이템의 사이즈로 계산이 된다. </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid("#grid". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\n\nvar item1 = \'<div data-column="2"></div>\';\nvar item2 = "<div></div>"\nlayout.append([item1, item2]);\n<\/script>\n```\n **/\n\nvar SquareLayout = function (_FrameLayout) {\n\t_inherits(SquareLayout, _FrameLayout);\n\n\tfunction SquareLayout() {\n\t\t_classCallCheck(this, SquareLayout);\n\n\t\treturn _possibleConstructorReturn(this, _FrameLayout.apply(this, arguments));\n\t}\n\n\tSquareLayout.prototype._checkItemSize = function _checkItemSize() {\n\t\tvar column = this.options.column;\n\n\t\tif (!column) {\n\t\t\t_FrameLayout.prototype._checkItemSize.call(this);\n\t\t\treturn;\n\t\t}\n\t\tvar margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / column - margin;\n\t};\n\n\tSquareLayout.prototype._layout = function _layout(items) {\n\t\tvar _shapes;\n\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar itemSize = this._getItemSize();\n\t\tvar margin = this.options.margin;\n\t\tvar columnLength = this.options.column || parseInt((this._size + margin) / (itemSize + margin), 10) || 1;\n\t\tvar length = items.length;\n\t\tvar endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n\t\tvar pointCaculateName = isAppend ? "min" : "max";\n\t\tvar shapes = [];\n\t\tvar sign = isAppend ? 1 : -1;\n\t\tvar style = this._style;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar _shapes$push;\n\n\t\t\tvar point = Math[pointCaculateName].apply(Math, endOutline);\n\t\t\tvar index = endOutline[isAppend ? "indexOf" : "lastIndexOf"](point);\n\t\t\tvar item = items[i];\n\t\t\tvar columnWidth = item.columnWidth;\n\t\t\tvar column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);\n\t\t\tvar columnCount = 1;\n\n\t\t\tif (column > 1) {\n\t\t\t\tfor (var j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {\n\t\t\t\t\tif (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {\n\t\t\t\t\t\t++columnCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!isAppend) {\n\t\t\t\t\tindex -= columnCount - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.columnWidth = [columnLength, columnCount];\n\t\t\tshapes.push((_shapes$push = {\n\t\t\t\twidth: columnCount,\n\t\t\t\theight: columnCount\n\t\t\t}, _shapes$push[pos1Name] = point - (!isAppend ? columnCount : 0), _shapes$push[pos2Name] = index, _shapes$push.index = i, _shapes$push));\n\t\t\tfor (var _j = 0; _j < columnCount; ++_j) {\n\t\t\t\tendOutline[index + _j] = point + sign * columnCount;\n\t\t\t}\n\t\t}\n\t\tthis._shapes = (_shapes = {\n\t\t\tshapes: shapes\n\t\t}, _shapes[style.size2] = columnLength, _shapes);\n\n\t\tvar result = _FrameLayout.prototype._layout.call(this, items, outline, isAppend);\n\n\t\tif (!isAppend) {\n\t\t\tvar lastItem = items[items.length - 1];\n\n\t\t\tshapes.sort(function (shape1, shape2) {\n\t\t\t\tvar item1pos1 = shape1[pos1Name];\n\t\t\t\tvar item1pos2 = shape1[pos2Name];\n\t\t\t\tvar item2pos1 = shape2[pos1Name];\n\t\t\t\tvar item2pos2 = shape2[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\titems.sort(function (a, b) {\n\t\t\t\tvar item1pos1 = a.rect[pos1Name];\n\t\t\t\tvar item1pos2 = a.rect[pos2Name];\n\t\t\t\tvar item2pos1 = b.rect[pos1Name];\n\t\t\t\tvar item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\tresult.startIndex = 0;\n\t\t\tresult.endIndex = items.indexOf(lastItem);\n\t\t}\n\t\treturn result;\n\t};\n\n\treturn SquareLayout;\n}(_FrameLayout3["default"]);\n\nexports["default"] = SquareLayout;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _BoxModel = __webpack_require__(16);\n\nvar _BoxModel2 = _interopRequireDefault(_BoxModel);\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction getCost(originLength, length) {\n\tvar cost = originLength / length;\n\n\tif (cost < 1) {\n\t\tcost = 1 / cost;\n\t}\n\n\treturn cost - 1;\n}\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n\titem.height = itemFitSize.height;\n\titem.width = itemFitSize.width;\n\tbestFitArea.height = containerFitSize.height;\n\tbestFitArea.width = containerFitSize.width;\n\n\tif (layoutVertical) {\n\t\titem.top = bestFitArea.top + bestFitArea.height;\n\t\titem.left = bestFitArea.left;\n\t} else {\n\t\titem.left = bestFitArea.left + bestFitArea.width;\n\t\titem.top = bestFitArea.top;\n\t}\n}\n\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout은 카드의 본래 크기에 따른 비중을 해치지 않으면서 중요한 카드는 더 크게 보여 주는 레이아웃이다. 행과 열이 구분돼 이미지를 정돈되게 배치하는 대신 가로세로 일정 공간 내에서 동적으로 카드를 배치한다.\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko> 그룹의 가로 세로 비 </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko> 이미지를 배치할 때 사이즈 가중치 </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko> 이미지를 배치할 때 비율 가중치 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid("#grid". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n\thorizontal: true,\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n<\/script>\n```\n **/\n\nvar PackingLayout = function () {\n\tfunction PackingLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, PackingLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\taspectRatio: 1,\n\t\t\tsizeWeight: 1,\n\t\t\tratioWeight: 1\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.horizontal);\n\t}\n\n\tPackingLayout.prototype._findBestFitArea = function _findBestFitArea(container, item) {\n\t\tif (container.getRatio() === 0) {\n\t\t\t// 아이템 최초 삽입시 전체영역 지정\n\t\t\tcontainer.originWidth = item.width;\n\t\t\tcontainer.originHeight = item.height;\n\t\t\tcontainer.width = item.width;\n\t\t\tcontainer.height = item.height;\n\t\t\treturn;\n\t\t}\n\n\t\tvar bestFitArea = null;\n\t\tvar minCost = 10000000;\n\t\tvar layoutVertical = false;\n\t\tvar itemFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tvar containerFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tvar _options = this.options,\n\t\t    sizeWeight = _options.sizeWeight,\n\t\t    ratioWeight = _options.ratioWeight;\n\n\n\t\tcontainer.items.forEach(function (v) {\n\t\t\tvar containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n\t\t\tvar containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n\t\t\tvar width = v.width;\n\t\t\tvar height = v.height;\n\t\t\tvar cost = void 0;\n\n\t\t\tfor (var i = 0; i < 2; ++i) {\n\t\t\t\tvar itemWidth = void 0;\n\t\t\t\tvar itemHeight = void 0;\n\t\t\t\tvar containerWidth = void 0;\n\t\t\t\tvar containerHeight = void 0;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// 상하에 아이템 추가\n\t\t\t\t\titemWidth = width;\n\t\t\t\t\titemHeight = height * (item.height / (v.originHeight + item.height));\n\t\t\t\t\tcontainerWidth = width;\n\t\t\t\t\tcontainerHeight = height - itemHeight;\n\t\t\t\t} else {\n\t\t\t\t\t// 좌우에 아이템 추가\n\t\t\t\t\titemHeight = height;\n\t\t\t\t\titemWidth = width * (item.width / (v.originWidth + item.width));\n\t\t\t\t\tcontainerHeight = height;\n\t\t\t\t\tcontainerWidth = width - itemWidth;\n\t\t\t\t}\n\n\t\t\t\tvar itemSize = itemWidth * itemHeight;\n\t\t\t\tvar itemRatio = itemWidth / itemHeight;\n\t\t\t\tvar containerSize = containerWidth * containerHeight;\n\t\t\t\tvar containerRatio = containerHeight / containerHeight;\n\n\t\t\t\tcost = getCost(item.getSize(), itemSize) * sizeWeight;\n\t\t\t\tcost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n\t\t\t\tcost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n\t\t\t\tcost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n\t\t\t\tif (cost === Math.min(cost, minCost)) {\n\t\t\t\t\tminCost = cost;\n\t\t\t\t\tbestFitArea = v;\n\t\t\t\t\tlayoutVertical = i === 0;\n\t\t\t\t\titemFitSize.width = itemWidth;\n\t\t\t\t\titemFitSize.height = itemHeight;\n\t\t\t\t\tcontainerFitSize.width = containerWidth;\n\t\t\t\t\tcontainerFitSize.height = containerHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n\t};\n\n\tPackingLayout.prototype._layout = function _layout(items) {\n\t\tvar _this = this;\n\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar style = this._style;\n\t\tvar _options2 = this.options,\n\t\t    horizontal = _options2.horizontal,\n\t\t    aspectRatio = _options2.aspectRatio,\n\t\t    margin = _options2.margin;\n\n\t\tvar pos1Name = style.pos1;\n\t\tvar size1Name = style.size1;\n\t\tvar containerWidth = this._size * (horizontal ? aspectRatio : 1);\n\t\tvar containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n\t\tvar containerSize1 = horizontal ? containerWidth : containerHeight;\n\t\tvar prevOutline = (0, _utils.toZeroArray)(outline);\n\t\tvar start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;\n\t\tvar end = start + containerSize1 + margin;\n\t\tvar container = new _BoxModel2["default"]({});\n\t\tvar startIndex = -1;\n\t\tvar endIndex = -1;\n\t\tvar startPos = -1;\n\t\tvar endPos = -1;\n\n\t\titems.forEach(function (item) {\n\t\t\tvar _item$orgSize = item.orgSize,\n\t\t\t    width = _item$orgSize.width,\n\t\t\t    height = _item$orgSize.height;\n\n\t\t\tvar model = new _BoxModel2["default"]({\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\toriginWidth: width,\n\t\t\t\toriginHeight: height\n\t\t\t});\n\n\t\t\t_this._findBestFitArea(container, model);\n\t\t\tcontainer.push(model);\n\t\t\tcontainer.scaleTo(containerWidth + margin, containerHeight + margin);\n\t\t});\n\t\titems.forEach(function (item, i) {\n\t\t\tvar boxItem = container.items[i];\n\t\t\tvar width = boxItem.width;\n\t\t\tvar height = boxItem.height;\n\t\t\tvar top = boxItem.top;\n\t\t\tvar left = boxItem.left;\n\n\t\t\titem.rect = { top: top, left: left, width: width - margin, height: height - margin };\n\t\t\titem.rect[pos1Name] += start;\n\n\t\t\tif (startIndex === -1) {\n\t\t\t\tstartIndex = i;\n\t\t\t\tendIndex = i;\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tendPos = startPos;\n\t\t\t}\n\t\t\tif (startPos > item.rect[pos1Name]) {\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tstartIndex = i;\n\t\t\t}\n\t\t\tif (endPos < item.rect[pos1Name] + item.rect[size1Name] + margin) {\n\t\t\t\tendPos = item.rect[pos1Name] + item.rect[size1Name] + margin;\n\t\t\t\tendIndex = i;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tstart: [start],\n\t\t\tend: [end],\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tPackingLayout.prototype._insert = function _insert() {\n\t\tvar items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar type = arguments[2];\n\n\t\t// this only needs the size of the item.\n\t\tvar clone = (0, _utils.cloneItems)(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\t/**\n  * Adds items at the bottom of a outline.\n  * @ko 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.PackingLayout#append\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tPackingLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\t/**\n  * Adds items at the top of a outline.\n  * @ko 아이템을 아웃라인 위에 추가한다.\n  * @method eg.InfiniteGrid.PackingLayout#prepend\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tPackingLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\t/**\n  * Adds items of groups at the bottom of a outline.\n  * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.PackingLayout#layout\n  * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100, 200, 300, 400]);\n  */\n\n\n\tPackingLayout.prototype.layout = function layout() {\n\t\tvar groups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n\t\tvar length = groups.length;\n\t\tvar point = outline;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t};\n\t/**\n  * Set the viewport size of the layout.\n  * @ko 레이아웃의 가시 사이즈를 설정한다.\n  * @method eg.InfiniteGrid.PackingLayout#setSize\n  * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n  * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.setSize(800);\n  */\n\n\n\tPackingLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t};\n\n\treturn PackingLayout;\n}();\n\nexports["default"] = PackingLayout;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar BoxModel = function () {\n\tfunction BoxModel(options) {\n\t\t_classCallCheck(this, BoxModel);\n\n\t\t_extends(this, {\n\t\t\toriginWidth: 0,\n\t\t\toriginHeight: 0,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tleft: 0,\n\t\t\ttop: 0,\n\t\t\titems: []\n\t\t}, options);\n\t}\n\n\tBoxModel.prototype.scaleTo = function scaleTo(width, height) {\n\t\tvar scaleX = this.width ? width / this.width : 0;\n\t\tvar scaleY = this.height ? height / this.height : 0;\n\n\t\tthis.items.forEach(function (v) {\n\t\t\tif (scaleX !== 0) {\n\t\t\t\tv.left *= scaleX;\n\t\t\t\tv.width *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 0) {\n\t\t\t\tv.top *= scaleY;\n\t\t\t\tv.height *= scaleY;\n\t\t\t}\n\t\t});\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t};\n\n\tBoxModel.prototype.push = function push(item) {\n\t\tthis.items.push(item);\n\t};\n\n\tBoxModel.prototype.getOriginSize = function getOriginSize() {\n\t\treturn this.originWidth * this.originHeight;\n\t};\n\n\tBoxModel.prototype.getSize = function getSize() {\n\t\treturn this.width * this.height;\n\t};\n\n\tBoxModel.prototype.getOriginRatio = function getOriginRatio() {\n\t\treturn this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n\t};\n\n\tBoxModel.prototype.getRatio = function getRatio() {\n\t\treturn this.height === 0 ? 0 : this.width / this.height;\n\t};\n\n\treturn BoxModel;\n}();\n\nmodule.exports = BoxModel;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _dijkstra = __webpack_require__(18);\n\nvar _dijkstra2 = _interopRequireDefault(_dijkstra);\n\nvar _consts = __webpack_require__(1);\n\nvar _utils = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @classdesc \'justified\' is a printing term with the meaning that \'it fits in one row wide\'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko \'justified\'는 \'1행의 너비에 맞게 꼭 들어찬\'이라는 의미를 가진 인쇄 용어다. 용어의 의미대로 너비가 주어진 사이즈를 기준으로 카드가 가득 차도록 배치하는 레이아웃이다.\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>스크롤 이동 방향 (false: 세로방향, true: 가로방향)</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko> 아이템이 조정되는 최소 크기 </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko> 아이템이 조정되는 최대 크기 </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko> 한 줄에 들어가는 아이템의 개수 </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid("#grid". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n\tcolumn: 5,\n\thorizontal: true,\n});\n\n<\/script>\n```\n **/\nvar JustifiedLayout = function () {\n\tfunction JustifiedLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, JustifiedLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\tmargin: 0,\n\t\t\thorizontal: false,\n\t\t\tminSize: 0,\n\t\t\tmaxSize: 0,\n\t\t\tcolumn: [1, 8]\n\t\t}, options);\n\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.horizontal);\n\t\tthis._size = 0;\n\t}\n\n\tJustifiedLayout.prototype._layout = function _layout(items, outline, isAppend) {\n\t\tvar _this = this;\n\n\t\tvar style = this._style;\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar startIndex = 0;\n\t\tvar endIndex = items.length;\n\t\tvar column = this.options.column;\n\n\t\tif ((typeof column === "undefined" ? "undefined" : _typeof(column)) !== "object") {\n\t\t\tcolumn = [column, column];\n\t\t}\n\n\t\tvar graph = function graph(_start) {\n\t\t\tvar results = {};\n\t\t\tvar start = +_start.replace(/[^0-9]/g, "");\n\t\t\tvar length = endIndex + 1;\n\n\t\t\tfor (var i = Math.min(start + column[0], length - 1); i < length; ++i) {\n\t\t\t\tif (i - start > column[1]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar cost = _this._getCost(items, start, i, size1Name, size2Name);\n\n\t\t\t\tif (cost === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cost < 0 && i === length - 1) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tresults["" + i] = Math.pow(cost, 2);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\t// shortest path for items\' total height.\n\t\tvar path = _dijkstra2["default"].find_path(graph, "" + startIndex, "" + endIndex);\n\n\t\treturn this._setStyle(items, path, outline, isAppend);\n\t};\n\n\tJustifiedLayout.prototype._getSize = function _getSize(items, size1Name, size2Name) {\n\t\tvar margin = this.options.margin;\n\t\tvar size = items.reduce(function (sum, item) {\n\t\t\treturn sum + item.size[size2Name] / item.size[size1Name];\n\t\t}, 0);\n\n\t\treturn (this._size - margin * (items.length - 1)) / size;\n\t};\n\n\tJustifiedLayout.prototype._getCost = function _getCost(items, i, j, size1Name, size2Name) {\n\t\tvar size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\t\tvar min = this.options.minSize || 0;\n\t\tvar max = this.options.maxSize || Infinity;\n\n\t\tif (isFinite(max)) {\n\t\t\t// if this size is not in range, the cost increases sharply.\n\t\t\tif (size < min) {\n\t\t\t\treturn Math.pow(size - min, 2) + Math.pow(max, 2);\n\t\t\t} else if (size > max) {\n\t\t\t\treturn Math.pow(size - max, 2) + Math.pow(max, 2);\n\t\t\t} else {\n\t\t\t\t// if this size in range, the cost is negative or low.\n\t\t\t\treturn Math.min(size - max, min - size);\n\t\t\t}\n\t\t}\n\t\t// if max is infinite type, caculate cost only with "min".\n\t\tif (size < min) {\n\t\t\treturn Math.max(Math.pow(min, 2), Math.pow(size, 2));\n\t\t}\n\t\treturn size - min;\n\t};\n\n\tJustifiedLayout.prototype._setStyle = function _setStyle(items, path) {\n\t\tvar outline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\tvar isAppend = arguments[3];\n\n\t\tvar style = this._style;\n\t\t// if direction is vertical\n\t\t// pos1 : top, pos11 : bottom\n\t\t// size1 : height\n\t\t// pos2 : left, pos22 : right\n\t\t// size2 : width\n\n\t\t// if direction is horizontal\n\t\t// pos1 : left, pos11 : right\n\t\t// size1 : width\n\t\t// pos2 : top, pos22 : bottom\n\t\t// size2 : height\n\t\tvar pos1Name = style.pos1;\n\t\tvar size1Name = style.size1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar size2Name = style.size2;\n\t\tvar length = path.length;\n\t\tvar margin = this.options.margin;\n\t\tvar startPoint = outline[0] || 0;\n\t\tvar endPoint = startPoint;\n\t\tvar height = 0;\n\n\t\tfor (var i = 0; i < length - 1; ++i) {\n\t\t\tvar path1 = parseInt(path[i], 10);\n\t\t\tvar path2 = parseInt(path[i + 1], 10);\n\t\t\t// pathItems(path1 to path2) are in 1 line.\n\t\t\tvar pathItems = items.slice(path1, path2);\n\t\t\tvar pathItemsLength = pathItems.length;\n\t\t\tvar size1 = this._getSize(pathItems, size1Name, size2Name);\n\t\t\tvar pos1 = endPoint;\n\n\t\t\tfor (var j = 0; j < pathItemsLength; ++j) {\n\t\t\t\tvar _item$rect;\n\n\t\t\t\tvar item = pathItems[j];\n\t\t\t\tvar size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1;\n\t\t\t\t// item has margin bottom and right.\n\t\t\t\t// first item has not margin.\n\t\t\t\tvar prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n\t\t\t\tvar pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n\n\t\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n\t\t\t}\n\t\t\theight += margin + size1;\n\t\t\tendPoint = startPoint + height;\n\t\t}\n\t\tvar itemsLength = items.length;\n\t\tvar startIndex = itemsLength ? 0 : -1;\n\t\tvar endIndex = itemsLength ? itemsLength - 1 : -1;\n\n\t\tif (isAppend) {\n\t\t\t// previous group\'s end outline is current group\'s start outline\n\t\t\treturn {\n\t\t\t\tstart: [startPoint],\n\t\t\t\tend: [endPoint],\n\t\t\t\tstartIndex: startIndex,\n\t\t\t\tendIndex: endIndex\n\t\t\t};\n\t\t}\n\t\t// for prepend, only substract height from position.\n\t\t// always start is lower than end.\n\n\t\tfor (var _i = 0; _i < itemsLength; ++_i) {\n\t\t\tvar _item = items[_i];\n\n\t\t\t// move items as long as height for prepend\n\t\t\t_item.rect[pos1Name] -= height;\n\t\t}\n\t\treturn {\n\t\t\tstart: [startPoint - height],\n\t\t\tend: [startPoint], // endPoint - height = startPoint\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tJustifiedLayout.prototype._insert = function _insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tvar clone = (0, _utils.cloneItems)(items);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\t/**\n  * Set the viewport size of the layout.\n  * @ko 레이아웃의 가시 사이즈를 설정한다.\n  * @method eg.InfiniteGrid.JustifiedLayout#setSize\n  * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n  * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.setSize(800);\n  */\n\n\n\tJustifiedLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t};\n\t/**\n  * Adds items at the bottom of a outline.\n  * @ko 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.JustifiedLayout#append\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tJustifiedLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\t/**\n  * Adds items at the top of a outline.\n  * @ko 아이템을 아웃라인 위에 추가한다.\n  * @method eg.InfiniteGrid.JustifiedLayout#prepend\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} [outline=[]] Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100]);\n  */\n\n\n\tJustifiedLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\t/**\n  * Adds items of groups at the bottom of a outline.\n  * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.JustifiedLayout#layout\n  * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100]);\n  */\n\n\n\tJustifiedLayout.prototype.layout = function layout(groups, outlines) {\n\t\tvar length = groups.length;\n\t\tvar point = outlines;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t\treturn this;\n\t};\n\n\treturn JustifiedLayout;\n}();\n\nexports["default"] = JustifiedLayout;\nmodule.exports = exports["default"];\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\n/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\n(function () {\n  var dijkstra = {\n    single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {\n      // Predecessor map for each node that has been encountered.\n      // node ID => predecessor node ID\n      var predecessors = {};\n\n      // Costs of shortest paths from s to all nodes encountered.\n      // node ID => cost\n      var costs = {};\n      costs[s] = 0;\n\n      // Costs of shortest paths from s to all nodes encountered; differs from\n      // `costs` in that it provides easy access to the node that currently has\n      // the known shortest path from s.\n      // XXX: Do we actually need both `costs` and `open`?\n      var open = new BinaryHeap(function (x) {\n        return x.cost;\n      });\n      open.push({ value: s, cost: 0 });\n\n      var closest, u, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n      while (open.size()) {\n        // In the nodes remaining in graph that have a known cost from s,\n        // find the node, u, that currently has the shortest path from s.\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost;\n\n        // Get nodes adjacent to u...\n        adjacent_nodes = graph(u) || {};\n\n        // ...and explore the edges that connect u to those nodes, updating\n        // the cost of the shortest paths to any or all of those nodes as\n        // necessary. v is the node across the current edge from u.\n        for (var v in adjacent_nodes) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven\'t visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v\'s cost in the cost list and\n          // update v\'s predecessor in the predecessor list (it\'s now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = typeof costs[v] === \'undefined\';\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });\n            predecessors[v] = u;\n          }\n        }\n      }\n\n      if (typeof costs[d] === \'undefined\') {\n        var msg = [\'Could not find a path from \', s, \' to \', d, \'.\'].join(\'\');\n        throw new Error(msg);\n      }\n\n      return predecessors;\n    },\n\n    extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {\n      var nodes = [];\n      var u = d;\n      var predecessor;\n      while (u) {\n        nodes.push(u);\n        predecessor = predecessors[u];\n        u = predecessors[u];\n      }\n      nodes.reverse();\n      return nodes;\n    },\n\n    find_path: function find_path(graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    }\n\n  };\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function push(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function pop() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n    size: function size() {\n      return this.content.length;\n    },\n\n    bubbleUp: function bubbleUp(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element\'s index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n            parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update \'n\' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n            break;\n          }\n      }\n    },\n    sinkDown: function sinkDown(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n          element = this.content[n],\n          elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n            child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n              child1Score = this.scoreFunction(child1);\n          // If the score is less than our element\'s, we need to swap.\n          if (child1Score < elemScore) {\n            swap = child1N;\n          }\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n              child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) {\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap !== null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n            break;\n          }\n      }\n    }\n  };\n\n  /**\n   * Browserify 지원을 위한 모듈화 코드\n   */\n  if (typeof module !== \'undefined\' && module.exports) {\n    module.exports = dijkstra;\n  } else {\n    window.dijkstra = dijkstra;\n  }\n})();\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=infinitegrid.module.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvaW5maW5pdGVncmlkL2Rpc3QvaW5maW5pdGVncmlkLm1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZWdqcy9pbmZpbml0ZWdyaWQvZGlzdC9pbmZpbml0ZWdyaWQubW9kdWxlLmpzPzRkYzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgTkFWRVIgQ29ycC5cclxuICogQGVnanMvaW5maW5pdGVncmlkIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIFxyXG4gKiBAZWdqcy9pbmZpbml0ZWdyaWQgSmF2YVNjcmlwdCBsaWJyYXJ5XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWluZmluaXRlZ3JpZFxyXG4gKiBcclxuICogQHZlcnNpb24gMy4zLjFcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiQGVnanMvY29tcG9uZW50XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIkBlZ2pzL2NvbXBvbmVudFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJJbmZpbml0ZUdyaWRcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAZWdqcy9jb21wb25lbnRcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVnXCJdID0gcm9vdFtcImVnXCJdIHx8IHt9LCByb290W1wiZWdcIl1bXCJJbmZpbml0ZUdyaWRcIl0gPSBmYWN0b3J5KHJvb3RbXCJlZ1wiXVtcIkNvbXBvbmVudFwiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMl9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuU1RZTEUgPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmV4cG9ydHMubWF0Y2hIVE1MID0gbWF0Y2hIVE1MO1xuZXhwb3J0cy4kID0gJDtcbmV4cG9ydHMuYWRkRXZlbnQgPSBhZGRFdmVudDtcbmV4cG9ydHMucmVtb3ZlRXZlbnQgPSByZW1vdmVFdmVudDtcbmV4cG9ydHMuc2Nyb2xsID0gc2Nyb2xsO1xuZXhwb3J0cy5zY3JvbGxUbyA9IHNjcm9sbFRvO1xuZXhwb3J0cy5zY3JvbGxCeSA9IHNjcm9sbEJ5O1xuZXhwb3J0cy5nZXRTdHlsZXMgPSBnZXRTdHlsZXM7XG5leHBvcnRzLmlubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuZXhwb3J0cy5pbm5lckhlaWdodCA9IGlubmVySGVpZ2h0O1xuZXhwb3J0cy5nZXRTdHlsZU5hbWVzID0gZ2V0U3R5bGVOYW1lcztcbmV4cG9ydHMuYXNzaWduT3B0aW9ucyA9IGFzc2lnbk9wdGlvbnM7XG5leHBvcnRzLnRvWmVyb0FycmF5ID0gdG9aZXJvQXJyYXk7XG5leHBvcnRzLmNsb25lSXRlbXMgPSBjbG9uZUl0ZW1zO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5maWxsID0gZmlsbDtcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxudmFyIF9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiB0b0FycmF5KG5vZGVzKSB7XG5cdC8vIFNDUklQVDUwMTQgaW4gSUU4XG5cdHZhciBhcnJheSA9IFtdO1xuXG5cdGlmIChub2Rlcykge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyYXkucHVzaChub2Rlc1tpXSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIG1hdGNoSFRNTChodG1sKSB7XG5cdHJldHVybiBodG1sLm1hdGNoKC9ePChbQS16XSspXFxzKihbXj5dKik+Lyk7XG59XG4vKipcbiAqIFNlbGVjdCBvciBjcmVhdGUgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8alF1ZXJ5fSBwYXJhbVxuICogIHdoZW4gc3RyaW5nIGdpdmVuIGlzIGFzIEhUTUwgdGFnLCB0aGVuIGNyZWF0ZSBlbGVtZW50XG4gKiAgb3RoZXJ3aXNlIGl0IHJldHVybnMgc2VsZWN0ZWQgZWxlbWVudHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gJChwYXJhbSkge1xuXHR2YXIgbXVsdGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG5cdHZhciBlbCA9IHZvaWQgMDtcblxuXHRpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG5cdFx0Ly8gU3RyaW5nIChIVE1MLCBTZWxlY3Rvcilcblx0XHQvLyBjaGVjayBpZiBzdHJpbmcgaXMgSFRNTCB0YWcgZm9ybWF0XG5cdFx0dmFyIG1hdGNoID0gbWF0Y2hIVE1MKHBhcmFtKTtcblxuXHRcdC8vIGNyZWF0aW5nIGVsZW1lbnRcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdC8vIEhUTUxcblx0XHRcdHZhciBkdW1teSA9IF9icm93c2VyLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0XHRcdGR1bW15LmlubmVySFRNTCA9IHBhcmFtO1xuXHRcdFx0ZWwgPSBkdW1teS5jaGlsZE5vZGVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBTZWxlY3RvclxuXHRcdFx0ZWwgPSBfYnJvd3Nlci5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtKTtcblx0XHR9XG5cdFx0aWYgKG11bHRpKSB7XG5cdFx0XHRlbCA9IHRvQXJyYXkoZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbCA9IGVsICYmIGVsLmxlbmd0aCA+IDAgJiYgZWxbMF0gfHwgdW5kZWZpbmVkO1xuXHRcdH1cblx0fSBlbHNlIGlmIChwYXJhbSA9PT0gX2Jyb3dzZXIud2luZG93KSB7XG5cdFx0Ly8gd2luZG93XG5cdFx0ZWwgPSBwYXJhbTtcblx0fSBlbHNlIGlmIChwYXJhbS5ub2RlTmFtZSAmJiAocGFyYW0ubm9kZVR5cGUgPT09IDEgfHwgcGFyYW0ubm9kZVR5cGUgPT09IDkpKSB7XG5cdFx0Ly8gSFRNTEVsZW1lbnQsIERvY3VtZW50XG5cdFx0ZWwgPSBwYXJhbTtcblx0fSBlbHNlIGlmIChcImpRdWVyeVwiIGluIF9icm93c2VyLndpbmRvdyAmJiBwYXJhbSBpbnN0YW5jZW9mIF9icm93c2VyLndpbmRvdy5qUXVlcnkgfHwgcGFyYW0uY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuXHRcdC8vIGpRdWVyeVxuXHRcdGVsID0gJChtdWx0aSA/IHBhcmFtLnRvQXJyYXkoKSA6IHBhcmFtLmdldCgwKSwgbXVsdGkpO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG5cdFx0ZWwgPSBwYXJhbS5tYXAoZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiAkKHYpO1xuXHRcdH0pO1xuXHRcdGlmICghbXVsdGkpIHtcblx0XHRcdGVsID0gZWwubGVuZ3RoID49IDEgPyBlbFswXSA6IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpIHtcblx0aWYgKF9jb25zdHMuU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBldmVudExpc3RlbmVyT3B0aW9ucyB8fCBmYWxzZTtcblxuXHRcdGlmICgodHlwZW9mIGV2ZW50TGlzdGVuZXJPcHRpb25zID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXZlbnRMaXN0ZW5lck9wdGlvbnMpKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0b3B0aW9ucyA9IF9jb25zdHMuU1VQUE9SVF9QQVNTSVZFID8gZXZlbnRMaXN0ZW5lck9wdGlvbnMgOiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcblx0XHRlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnRbXCJvblwiICsgdHlwZV0gPSBoYW5kbGVyO1xuXHR9XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuXHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcblx0XHRlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnRbXCJvblwiICsgdHlwZV0gPSBudWxsO1xuXHR9XG59XG5mdW5jdGlvbiBzY3JvbGwoZWwpIHtcblx0dmFyIGhvcml6b250YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG5cdHZhciBwcm9wID0gXCJzY3JvbGxcIiArIChob3Jpem9udGFsID8gXCJMZWZ0XCIgOiBcIlRvcFwiKTtcblxuXHRpZiAoZWwgPT09IF9icm93c2VyLndpbmRvdykge1xuXHRcdHJldHVybiBfYnJvd3Nlci53aW5kb3dbaG9yaXpvbnRhbCA/IFwicGFnZVhPZmZzZXRcIiA6IFwicGFnZVlPZmZzZXRcIl0gfHwgX2Jyb3dzZXIuZG9jdW1lbnQuYm9keVtwcm9wXSB8fCBfYnJvd3Nlci5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbcHJvcF07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGVsW3Byb3BdO1xuXHR9XG59XG5mdW5jdGlvbiBzY3JvbGxUbyhlbCwgeCwgeSkge1xuXHRpZiAoZWwgPT09IF9icm93c2VyLndpbmRvdykge1xuXHRcdGVsLnNjcm9sbCh4LCB5KTtcblx0fSBlbHNlIHtcblx0XHRlbC5zY3JvbGxMZWZ0ID0geDtcblx0XHRlbC5zY3JvbGxUb3AgPSB5O1xuXHR9XG59XG5mdW5jdGlvbiBzY3JvbGxCeShlbCwgeCwgeSkge1xuXHRpZiAoZWwgPT09IF9icm93c2VyLndpbmRvdykge1xuXHRcdGVsLnNjcm9sbEJ5KHgsIHkpO1xuXHR9IGVsc2Uge1xuXHRcdGVsLnNjcm9sbExlZnQgKz0geDtcblx0XHRlbC5zY3JvbGxUb3AgKz0geTtcblx0fVxufVxuZnVuY3Rpb24gZ2V0U3R5bGVzKGVsKSB7XG5cdHJldHVybiBfY29uc3RzLlNVUFBPUlRfQ09NUFVURURTVFlMRSA/IF9icm93c2VyLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSA6IGVsLmN1cnJlbnRTdHlsZTtcbn1cbmZ1bmN0aW9uIF9nZXRTaXplKGVsLCBuYW1lKSB7XG5cdGlmIChlbCA9PT0gX2Jyb3dzZXIud2luZG93KSB7XG5cdFx0Ly8gV0lORE9XXG5cdFx0cmV0dXJuIF9icm93c2VyLndpbmRvd1tcImlubmVyXCIgKyBuYW1lXSB8fCBfYnJvd3Nlci5kb2N1bWVudC5ib2R5W1wiY2xpZW50XCIgKyBuYW1lXTtcblx0fSBlbHNlIGlmIChlbC5ub2RlVHlwZSA9PT0gOSkge1xuXHRcdC8vIERPQ1VNRU5UX05PREVcblx0XHR2YXIgZG9jID0gZWwuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIE1hdGgubWF4KGVsLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIG5hbWVdLCBlbC5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wiY2xpZW50XCIgKyBuYW1lXSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gTk9ERVxuXHRcdHZhciBzdHlsZSA9IGdldFN0eWxlcyhlbCk7XG5cdFx0dmFyIHZhbHVlID0gc3R5bGVbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblxuXHRcdHJldHVybiBwYXJzZUZsb2F0KC9hdXRvfCUvLnRlc3QodmFsdWUpID8gZWxbXCJvZmZzZXRcIiArIG5hbWVdIDogc3R5bGVbbmFtZS50b0xvd2VyQ2FzZSgpXSk7XG5cdH1cbn1cbmZ1bmN0aW9uIGlubmVyV2lkdGgoZWwpIHtcblx0cmV0dXJuIF9nZXRTaXplKGVsLCBcIldpZHRoXCIpO1xufVxuZnVuY3Rpb24gaW5uZXJIZWlnaHQoZWwpIHtcblx0cmV0dXJuIF9nZXRTaXplKGVsLCBcIkhlaWdodFwiKTtcbn1cbnZhciBTVFlMRSA9IGV4cG9ydHMuU1RZTEUgPSB7XG5cdHZlcnRpY2FsOiB7XG5cdFx0cG9zMTogXCJ0b3BcIixcblx0XHRlbmRQb3MxOiBcImJvdHRvbVwiLFxuXHRcdHNpemUxOiBcImhlaWdodFwiLFxuXHRcdHBvczI6IFwibGVmdFwiLFxuXHRcdGVuZFBvczI6IFwicmlnaHRcIixcblx0XHRzaXplMjogXCJ3aWR0aFwiXG5cdH0sXG5cdGhvcml6b250YWw6IHtcblx0XHRwb3MxOiBcImxlZnRcIixcblx0XHRlbmRQb3MxOiBcInJpZ2h0XCIsXG5cdFx0c2l6ZTE6IFwid2lkdGhcIixcblx0XHRwb3MyOiBcInRvcFwiLFxuXHRcdGVuZFBvczI6IFwiYm90dG9tXCIsXG5cdFx0c2l6ZTI6IFwiaGVpZ2h0XCJcblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0U3R5bGVOYW1lcyhpc0hvcml6b250YWwpIHtcblx0cmV0dXJuIFNUWUxFW2lzSG9yaXpvbnRhbCA/IF9jb25zdHMuSE9SSVpPTlRBTCA6IF9jb25zdHMuVkVSVElDQUxdO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25PcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSB7XG5cdHJldHVybiBfZXh0ZW5kcyh7fSwgX2NvbnN0cy5ERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdG9aZXJvQXJyYXkob3V0bGluZSkge1xuXHRpZiAoIW91dGxpbmUgfHwgIW91dGxpbmUubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFswXTtcblx0fVxuXHRyZXR1cm4gb3V0bGluZTtcbn1cbmZ1bmN0aW9uIGNsb25lSXRlbXMoaXRlbXMpIHtcblx0cmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBfZXh0ZW5kcyh7fSwgaXRlbSk7XG5cdH0pO1xufVxuZnVuY3Rpb24gaXNXaW5kb3coZWwpIHtcblx0cmV0dXJuIGVsID09PSBfYnJvd3Nlci53aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGZpbGwoYXJyLCB2YWx1ZSkge1xuXHR2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRhcnJbaV0gPSB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHRhcmdldCkge1xuXHRyZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkRFRkVOU0VfQlJPV1NFUiA9IGV4cG9ydHMuV0VCS0lUX1ZFUlNJT04gPSBleHBvcnRzLlBST0NFU1NJTkcgPSBleHBvcnRzLkxPQURJTkdfUFJFUEVORCA9IGV4cG9ydHMuTE9BRElOR19BUFBFTkQgPSBleHBvcnRzLklETEUgPSBleHBvcnRzLkFMSUdOID0gZXhwb3J0cy5pc01vYmlsZSA9IGV4cG9ydHMuYWdlbnQgPSBleHBvcnRzLkRFRkFVTFRfT1BUSU9OUyA9IGV4cG9ydHMuR1JPVVBLRVlfQVRUID0gZXhwb3J0cy5EVU1NWV9QT1NJVElPTiA9IGV4cG9ydHMuU0lOR0xFID0gZXhwb3J0cy5NVUxUSSA9IGV4cG9ydHMuTk9fVFJVU1RFRCA9IGV4cG9ydHMuVFJVU1RFRCA9IGV4cG9ydHMuTk9fQ0FDSEUgPSBleHBvcnRzLkNBQ0hFID0gZXhwb3J0cy5IT1JJWk9OVEFMID0gZXhwb3J0cy5WRVJUSUNBTCA9IGV4cG9ydHMuUFJFUEVORCA9IGV4cG9ydHMuQVBQRU5EID0gZXhwb3J0cy5JR05PUkVfQ0xBU1NOQU1FID0gZXhwb3J0cy5DT05UQUlORVJfQ0xBU1NOQU1FID0gZXhwb3J0cy5SRVRSWSA9IGV4cG9ydHMuSVNfQU5EUk9JRDIgPSBleHBvcnRzLklTX0lPUyA9IGV4cG9ydHMuSVNfSUUgPSBleHBvcnRzLlNVUFBPUlRfUEFTU0lWRSA9IGV4cG9ydHMuU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSID0gZXhwb3J0cy5TVVBQT1JUX0NPTVBVVEVEU1RZTEUgPSB1bmRlZmluZWQ7XG5cbnZhciBfYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciB1YSA9IF9icm93c2VyLndpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG52YXIgU1VQUE9SVF9DT01QVVRFRFNUWUxFID0gZXhwb3J0cy5TVVBQT1JUX0NPTVBVVEVEU1RZTEUgPSAhIShcImdldENvbXB1dGVkU3R5bGVcIiBpbiBfYnJvd3Nlci53aW5kb3cpO1xudmFyIFNVUFBPUlRfQURERVZFTlRMSVNURU5FUiA9IGV4cG9ydHMuU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSID0gISEoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gZG9jdW1lbnQpO1xudmFyIFNVUFBPUlRfUEFTU0lWRSA9IGV4cG9ydHMuU1VQUE9SVF9QQVNTSVZFID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRpZiAoU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xufSgpO1xuXG52YXIgSVNfSUUgPSBleHBvcnRzLklTX0lFID0gL01TSUV8VHJpZGVudHxXaW5kb3dzIFBob25lfEVkZ2UvLnRlc3QodWEpO1xudmFyIElTX0lPUyA9IGV4cG9ydHMuSVNfSU9TID0gL2lQaG9uZXxpUGFkLy50ZXN0KHVhKTtcbnZhciBJU19BTkRST0lEMiA9IGV4cG9ydHMuSVNfQU5EUk9JRDIgPSAvQW5kcm9pZCAyXFwuLy50ZXN0KHVhKTtcbnZhciBSRVRSWSA9IGV4cG9ydHMuUkVUUlkgPSAzO1xudmFyIENPTlRBSU5FUl9DTEFTU05BTUUgPSBleHBvcnRzLkNPTlRBSU5FUl9DTEFTU05BTUUgPSBcIl9lZy1pbmZpbml0ZWdyaWQtY29udGFpbmVyX1wiO1xudmFyIElHTk9SRV9DTEFTU05BTUUgPSBleHBvcnRzLklHTk9SRV9DTEFTU05BTUUgPSBcIl9lZy1pbmZpbml0ZWdyaWQtaWdub3JlX1wiO1xuXG52YXIgQVBQRU5EID0gZXhwb3J0cy5BUFBFTkQgPSB0cnVlO1xudmFyIFBSRVBFTkQgPSBleHBvcnRzLlBSRVBFTkQgPSBmYWxzZTtcbnZhciBWRVJUSUNBTCA9IGV4cG9ydHMuVkVSVElDQUwgPSBcInZlcnRpY2FsXCI7XG52YXIgSE9SSVpPTlRBTCA9IGV4cG9ydHMuSE9SSVpPTlRBTCA9IFwiaG9yaXpvbnRhbFwiO1xudmFyIENBQ0hFID0gZXhwb3J0cy5DQUNIRSA9IHRydWU7XG52YXIgTk9fQ0FDSEUgPSBleHBvcnRzLk5PX0NBQ0hFID0gZmFsc2U7XG52YXIgVFJVU1RFRCA9IGV4cG9ydHMuVFJVU1RFRCA9IHRydWU7XG52YXIgTk9fVFJVU1RFRCA9IGV4cG9ydHMuTk9fVFJVU1RFRCA9IGZhbHNlO1xudmFyIE1VTFRJID0gZXhwb3J0cy5NVUxUSSA9IHRydWU7XG52YXIgU0lOR0xFID0gZXhwb3J0cy5TSU5HTEUgPSBmYWxzZTtcbnZhciBEVU1NWV9QT1NJVElPTiA9IGV4cG9ydHMuRFVNTVlfUE9TSVRJT04gPSAtMTAwMDAwO1xudmFyIEdST1VQS0VZX0FUVCA9IGV4cG9ydHMuR1JPVVBLRVlfQVRUID0gXCJkYXRhLWdyb3Vwa2V5XCI7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfT1BUSU9OUyA9IHtcblx0aG9yaXpvbnRhbDogZmFsc2UsXG5cdG1hcmdpbjogMFxufTtcblxudmFyIGFnZW50ID0gZXhwb3J0cy5hZ2VudCA9IHVhLnRvTG93ZXJDYXNlKCk7XG52YXIgaXNNb2JpbGUgPSBleHBvcnRzLmlzTW9iaWxlID0gL21vYml8aW9zfGFuZHJvaWQvLnRlc3QoYWdlbnQpO1xuXG52YXIgQUxJR04gPSBleHBvcnRzLkFMSUdOID0ge1xuXHRTVEFSVDogXCJzdGFydFwiLFxuXHRDRU5URVI6IFwiY2VudGVyXCIsXG5cdEVORDogXCJlbmRcIixcblx0SlVTVElGWTogXCJqdXN0aWZ5XCJcbn07XG5cbnZhciBJRExFID0gZXhwb3J0cy5JRExFID0gMDtcbnZhciBMT0FESU5HX0FQUEVORCA9IGV4cG9ydHMuTE9BRElOR19BUFBFTkQgPSAxO1xudmFyIExPQURJTkdfUFJFUEVORCA9IGV4cG9ydHMuTE9BRElOR19QUkVQRU5EID0gMjtcbnZhciBQUk9DRVNTSU5HID0gZXhwb3J0cy5QUk9DRVNTSU5HID0gNDtcblxudmFyIHdlYmtpdCA9IC9hcHBsZXdlYmtpdFxcLyhbXFxkfC5dKikvZy5leGVjKGFnZW50KTtcblxudmFyIFdFQktJVF9WRVJTSU9OID0gZXhwb3J0cy5XRUJLSVRfVkVSU0lPTiA9IHdlYmtpdCAmJiBwYXJzZUludCh3ZWJraXRbMV0sIDEwKSB8fCAwO1xudmFyIERFRkVOU0VfQlJPV1NFUiA9IGV4cG9ydHMuREVGRU5TRV9CUk9XU0VSID0gV0VCS0lUX1ZFUlNJT04gJiYgV0VCS0lUX1ZFUlNJT04gPCA1Mzc7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG52YXIgd2luID0gd2luZG93O1xuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxuZXhwb3J0cy53aW5kb3cgPSB3aW47XG52YXIgZG9jdW1lbnQgPSBleHBvcnRzLmRvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlbGVtZW50cyA9IFtdO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIG9uUmVzaXplKGUpIHtcblx0QXV0b1NpemVyLnJlc2l6ZUFsbCgpO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgQXV0b1NpemVyID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBBdXRvU2l6ZXIoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1dG9TaXplcik7XG5cdH1cblxuXHRBdXRvU2l6ZXIuYWRkID0gZnVuY3Rpb24gYWRkKGVsZW1lbnQpIHtcblx0XHR2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImRhdGEtXCI7XG5cblx0XHRpZiAoIWVsZW1lbnQubGVuZ3RoKSB7XG5cdFx0XHQoMCwgX3V0aWxzLmFkZEV2ZW50KShfYnJvd3Nlci53aW5kb3csIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblx0XHR9XG5cdFx0ZWxlbWVudC5fX1BSRUZJWF9fID0gcHJlZml4O1xuXHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0QXV0b1NpemVyLnJlc2l6ZShlbGVtZW50KTtcblx0fTtcblxuXHRBdXRvU2l6ZXIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQpIHtcblx0XHR2YXIgaXNGaXhlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cblx0XHR2YXIgZml4ZWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShlbGVtZW50Ll9fUFJFRklYX18gKyBcImZpeGVkXCIpIHx8IFwid2lkdGhcIjtcblxuXHRcdGlmICghaXNGaXhlZCkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZVtmaXhlZCA9PT0gXCJ3aWR0aFwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl0gPSBcIlwiO1xuXHRcdH1cblx0XHR2YXIgaW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuXG5cdFx0aWYgKCF+aW5kZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0KDAsIF91dGlscy5yZW1vdmVFdmVudCkoX2Jyb3dzZXIud2luZG93LCBcInJlaXN6ZVwiLCBvblJlc2l6ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dG9TaXplci5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoZWxlbWVudCkge1xuXHRcdHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiZGF0YS1cIjtcblxuXHRcdHZhciBlbGVtZW50UHJlZml4ID0gdHlwZW9mIGVsZW1lbnQuX19QUkVGSVhfXyA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQuX19QUkVGSVhfXyA6IHByZWZpeDtcblx0XHR2YXIgZGF0YVdpZHRoID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoZWxlbWVudFByZWZpeCArIFwid2lkdGhcIik7XG5cdFx0dmFyIGRhdGFIZWlnaHQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShlbGVtZW50UHJlZml4ICsgXCJoZWlnaHRcIik7XG5cdFx0dmFyIGZpeGVkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoZWxlbWVudFByZWZpeCArIFwiZml4ZWRcIik7XG5cblx0XHRpZiAoZml4ZWQgPT09IFwiaGVpZ2h0XCIpIHtcblx0XHRcdHZhciBzaXplID0gKDAsIF91dGlscy5pbm5lckhlaWdodCkoZWxlbWVudCkgfHwgZGF0YUhlaWdodDtcblxuXHRcdFx0ZWxlbWVudC5zdHlsZS53aWR0aCA9IGRhdGFXaWR0aCAvIGRhdGFIZWlnaHQgKiBzaXplICsgXCJweFwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX3NpemUgPSAoMCwgX3V0aWxzLmlubmVyV2lkdGgpKGVsZW1lbnQpIHx8IGRhdGFXaWR0aDtcblxuXHRcdFx0ZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBkYXRhSGVpZ2h0IC8gZGF0YVdpZHRoICogX3NpemUgKyBcInB4XCI7XG5cdFx0fVxuXHR9O1xuXG5cdEF1dG9TaXplci5yZXNpemVBbGwgPSBmdW5jdGlvbiByZXNpemVBbGwoKSB7XG5cdFx0ZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIEF1dG9TaXplci5yZXNpemUoZWxlbWVudCk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIEF1dG9TaXplcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBdXRvU2l6ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NvbnN0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSXRlbU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdEl0ZW1NYW5hZ2VyLmZyb20gPSBmdW5jdGlvbiBmcm9tKGVsZW1lbnRzLCBzZWxlY3RvciwgX3JlZikge1xuXHRcdHZhciBncm91cEtleSA9IF9yZWYuZ3JvdXBLZXksXG5cdFx0ICAgIGlzQXBwZW5kID0gX3JlZi5pc0FwcGVuZDtcblxuXHRcdHZhciBmaWx0ZWQgPSBJdGVtTWFuYWdlci5zZWxlY3RJdGVtcygoMCwgX3V0aWxzLiQpKGVsZW1lbnRzLCBfY29uc3RzLk1VTFRJKSwgc2VsZWN0b3IpO1xuXG5cdFx0Ly8gSXRlbSBTdHJ1Y3R1cmVcblx0XHRyZXR1cm4gKDAsIF91dGlscy50b0FycmF5KShmaWx0ZWQpLm1hcChmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVsOiBlbCxcblx0XHRcdFx0Z3JvdXBLZXk6IGdyb3VwS2V5LFxuXHRcdFx0XHRjb250ZW50OiBlbC5vdXRlckhUTUxcblx0XHRcdH07XG5cdFx0fSk7XG5cdH07XG5cblx0SXRlbU1hbmFnZXIuc2VsZWN0SXRlbXMgPSBmdW5jdGlvbiBzZWxlY3RJdGVtcyhlbGVtZW50cykge1xuXHRcdHZhciBzZWxlY3RvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCIqXCI7XG5cblx0XHRyZXR1cm4gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lcyA9IHYuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0aWYgKGNsYXNzTmFtZXMuc29tZShmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRyZXR1cm4gYyA9PT0gX2NvbnN0cy5JR05PUkVfQ0xBU1NOQU1FO1xuXHRcdFx0fSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKlwiKSB7XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZXMuc29tZShmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHJldHVybiBjID09PSBzZWxlY3Rvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0SXRlbU1hbmFnZXIucGx1Y2sgPSBmdW5jdGlvbiBwbHVjayhkYXRhLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBkYXRhLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG5cdFx0XHRyZXR1cm4gYWNjLmNvbmNhdCh2W3Byb3BlcnR5XSk7XG5cdFx0fSwgW10pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEl0ZW1NYW5hZ2VyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJdGVtTWFuYWdlcik7XG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdHVzID0gZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRfZGF0YTogdGhpcy5fZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0dmFyIGl0ZW1zID0gZGF0YS5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0XHR2YXIgaXRlbTIgPSBfZXh0ZW5kcyh7fSwgaXRlbSk7XG5cblx0XHRcdFx0XHRkZWxldGUgaXRlbTIuZWw7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0yO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dmFyIGRhdGEyID0gX2V4dGVuZHMoe30sIGRhdGEpO1xuXG5cdFx0XHRcdGRhdGEyLml0ZW1zID0gaXRlbXM7XG5cdFx0XHRcdHJldHVybiBkYXRhMjtcblx0XHRcdH0pXG5cdFx0fTtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24gc2V0U3RhdHVzKHN0YXR1cykge1xuXHRcdHZhciBkYXRhID0gc3RhdHVzLl9kYXRhO1xuXG5cdFx0dGhpcy5zZXQoZGF0YSk7XG5cdH07XG5cblx0SXRlbU1hbmFnZXIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gZml0KGJhc2UsIGhvcml6b250YWwpIHtcblx0XHRpZiAoIXRoaXMuX2RhdGEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBwcm9wZXJ0eSA9IGhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCI7XG5cblx0XHRpZiAoYmFzZSAhPT0gMCkge1xuXHRcdFx0dGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEubWFwKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdHYuaXRlbXMgPSB2Lml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRcdGl0ZW0ucmVjdFtwcm9wZXJ0eV0gLT0gYmFzZTtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHYub3V0bGluZXMuc3RhcnQgPSB2Lm91dGxpbmVzLnN0YXJ0Lm1hcChmdW5jdGlvbiAoc3RhcnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhcnQgLSBiYXNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0di5vdXRsaW5lcy5lbmQgPSB2Lm91dGxpbmVzLmVuZC5tYXAoZnVuY3Rpb24gKGVuZCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmQgLSBiYXNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0SXRlbU1hbmFnZXIucHJvdG90eXBlLnBsdWNrID0gZnVuY3Rpb24gcGx1Y2socHJvcGVydHksIHN0YXJ0LCBlbmQpIHtcblx0XHR2YXIgZGF0YSA9ICgwLCBfdXRpbHMuaXNVbmRlZmluZWQpKHN0YXJ0KSA/IHRoaXMuX2RhdGEgOiB0aGlzLl9kYXRhLnNsaWNlKHN0YXJ0LCAoKDAsIF91dGlscy5pc1VuZGVmaW5lZCkoZW5kKSA/IHN0YXJ0IDogZW5kKSArIDEpO1xuXG5cdFx0cmV0dXJuIEl0ZW1NYW5hZ2VyLnBsdWNrKGRhdGEsIHByb3BlcnR5KTtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuZ2V0T3V0bGluZSA9IGZ1bmN0aW9uIGdldE91dGxpbmUoaW5kZXgsIHByb3BlcnR5KSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGF0YVtpbmRleF0ub3V0bGluZXNbcHJvcGVydHldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9O1xuXG5cdEl0ZW1NYW5hZ2VyLnByb3RvdHlwZS5nZXRFZGdlSW5kZXggPSBmdW5jdGlvbiBnZXRFZGdlSW5kZXgoY3Vyc29yLCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIHByb3AgPSBjdXJzb3IgPT09IFwic3RhcnRcIiA/IFwibWluXCIgOiBcIm1heFwiO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB0YXJnZXRWYWx1ZSA9IGN1cnNvciA9PT0gXCJzdGFydFwiID8gSW5maW5pdHkgOiAtSW5maW5pdHk7XG5cblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcblx0XHRcdHZhciB2YWx1ZSA9IE1hdGhbcHJvcF0uYXBwbHkoTWF0aCwgdGhpcy5nZXRPdXRsaW5lKGksIGN1cnNvcikpO1xuXG5cdFx0XHRpZiAoY3Vyc29yID09PSBcInN0YXJ0XCIgJiYgdGFyZ2V0VmFsdWUgPiB2YWx1ZSB8fCBjdXJzb3IgPT09IFwiZW5kXCIgJiYgdGFyZ2V0VmFsdWUgPCB2YWx1ZSkge1xuXHRcdFx0XHR0YXJnZXRWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIGdldEVkZ2UoY3Vyc29yLCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGRhdGFJZHggPSB0aGlzLmdldEVkZ2VJbmRleChjdXJzb3IsIHN0YXJ0LCBlbmQpO1xuXHRcdHZhciBpdGVtcyA9IHRoaXMucGx1Y2soXCJpdGVtc1wiLCBkYXRhSWR4KTtcblxuXHRcdGlmIChpdGVtcy5sZW5ndGgpIHtcblx0XHRcdHZhciBpdGVtSWR4ID0gdGhpcy5nZXRPdXRsaW5lKGRhdGFJZHgsIGN1cnNvciArIFwiSW5kZXhcIik7XG5cblx0XHRcdHJldHVybiBpdGVtcy5sZW5ndGggPiBpdGVtSWR4ID8gaXRlbXNbaXRlbUlkeF0gOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuZ2V0RWRnZVZhbHVlID0gZnVuY3Rpb24gZ2V0RWRnZVZhbHVlKGN1cnNvciwgc3RhcnQsIGVuZCkge1xuXHRcdHZhciBvdXRsaW5lcyA9IHRoaXMucGx1Y2soXCJvdXRsaW5lc1wiLCB0aGlzLmdldEVkZ2VJbmRleChjdXJzb3IsIHN0YXJ0LCBlbmQpKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdikge1xuXHRcdFx0cmV0dXJuIGFjYy5jb25jYXQodltjdXJzb3JdKTtcblx0XHR9LCBbXSk7XG5cblx0XHRyZXR1cm4gb3V0bGluZXMubGVuZ3RoID8gTWF0aFtjdXJzb3IgPT09IFwic3RhcnRcIiA/IFwibWluXCIgOiBcIm1heFwiXS5hcHBseShNYXRoLCBvdXRsaW5lcykgOiAwO1xuXHR9O1xuXG5cdEl0ZW1NYW5hZ2VyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobGF5b3V0ZWQpIHtcblx0XHR0aGlzLl9kYXRhLnB1c2gobGF5b3V0ZWQpO1xuXHRcdHJldHVybiBsYXlvdXRlZC5pdGVtcztcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQobGF5b3V0ZWQpIHtcblx0XHR0aGlzLl9kYXRhLnVuc2hpZnQobGF5b3V0ZWQpO1xuXHRcdHJldHVybiBsYXlvdXRlZC5pdGVtcztcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcblx0XHR0aGlzLl9kYXRhID0gW107XG5cdH07XG5cblx0SXRlbU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50LCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0dmFyIGtleSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKF9jb25zdHMuR1JPVVBLRVlfQVRUKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0KHN0YXJ0LCBlbmQpLmZpbHRlcihmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIFN0cmluZyh2Lmdyb3VwS2V5KSA9PT0ga2V5O1xuXHRcdH0pO1xuXG5cdFx0aWYgKCFkYXRhLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0XHRkYXRhID0gZGF0YVswXTtcblxuXHRcdHZhciBsZW4gPSBkYXRhLml0ZW1zLmxlbmd0aDtcblx0XHR2YXIgaWR4ID0gLTE7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZGF0YS5pdGVtc1tpXS5lbCA9PT0gZWxlbWVudCkge1xuXHRcdFx0XHRpZHggPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKH5pZHgpIHtcblx0XHRcdC8vIHJlbW92ZSBpdGVtIGluZm9ybWF0aW9uXG5cdFx0XHRkYXRhLml0ZW1zLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0dGhpcy5zZXQoZGF0YSwga2V5KTtcblx0XHRcdGl0ZW1zID0gZGF0YS5pdGVtcztcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9O1xuXG5cdEl0ZW1NYW5hZ2VyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihkYXRhKSB7XG5cdFx0dmFyIGdyb3VwS2V5ID0gKHR5cGVvZiBkYXRhID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZGF0YSkpID09PSBcIm9iamVjdFwiID8gZGF0YS5ncm91cEtleSA6IGRhdGE7XG5cdFx0dmFyIGRhdGFzID0gdGhpcy5fZGF0YTtcblx0XHR2YXIgbGVuZ3RoID0gZGF0YXMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKGdyb3VwS2V5ID09PSBkYXRhc1tpXS5ncm91cEtleSkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9O1xuXG5cdEl0ZW1NYW5hZ2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoc3RhcnQsIGVuZCkge1xuXHRcdGlmICgoMCwgX3V0aWxzLmlzVW5kZWZpbmVkKShzdGFydCkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kYXRhLmNvbmNhdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGF0YS5zbGljZShzdGFydCwgKCgwLCBfdXRpbHMuaXNVbmRlZmluZWQpKGVuZCkgPyBzdGFydCA6IGVuZCkgKyAxKTtcblx0fTtcblxuXHRJdGVtTWFuYWdlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGRhdGEsIGtleSkge1xuXHRcdGlmICghKDAsIF91dGlscy5pc1VuZGVmaW5lZCkoa2V5KSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMuX2RhdGEubGVuZ3RoO1xuXHRcdFx0dmFyIGlkeCA9IC0xO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kYXRhW2ldLmdyb3VwS2V5ID09PSBrZXkpIHtcblx0XHRcdFx0XHRpZHggPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR+aWR4ICYmICh0aGlzLl9kYXRhW2lkeF0gPSBkYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZGF0YSA9IGRhdGEuY29uY2F0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdEl0ZW1NYW5hZ2VyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YShpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW2luZGV4XTtcblx0fTtcblxuXHRyZXR1cm4gSXRlbU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSXRlbU1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmVuc2UoZWxlbWVudCkge1xuXHR2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRjb250YWluZXIuY2xhc3NOYW1lID0gX2NvbnN0cy5DT05UQUlORVJfQ0xBU1NOQU1FO1xuXHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblxuXHR2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuXHR2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyAvLyBmb3IgSUU4XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZHJlblswXSk7XG5cdH1cblxuXHRlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdHJldHVybiBjb250YWluZXI7XG59XG5cbnZhciBET01SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0RE9NUmVuZGVyZXIucmVuZGVySXRlbSA9IGZ1bmN0aW9uIHJlbmRlckl0ZW0oaXRlbSwgc3R5bGVzKSB7XG5cdFx0dmFyIGVsID0gaXRlbS5lbDtcblxuXHRcdGlmIChlbCkge1xuXHRcdFx0dmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcblxuXHRcdFx0Ly8gZm9yIGRlYnVnZ2luZ1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKF9jb25zdHMuR1JPVVBLRVlfQVRULCBpdGVtLmdyb3VwS2V5KTtcblx0XHRcdGVsU3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRbXCJsZWZ0XCIsIFwidG9wXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0uZm9yRWFjaChmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRwIGluIHN0eWxlcyAmJiAoZWxTdHlsZVtwXSA9IHN0eWxlc1twXSArIFwicHhcIik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucmVuZGVySXRlbXMgPSBmdW5jdGlvbiByZW5kZXJJdGVtcyhpdGVtcykge1xuXHRcdGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdERPTVJlbmRlcmVyLnJlbmRlckl0ZW0oaXRlbSwgaXRlbS5yZWN0KTtcblx0XHR9KTtcblx0fTtcblxuXHRET01SZW5kZXJlci5yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW1zKGl0ZW1zKSB7XG5cdFx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0uZWwpIHtcblx0XHRcdFx0RE9NUmVuZGVyZXIucmVtb3ZlRWxlbWVudChpdGVtLmVsKTtcblx0XHRcdFx0aXRlbS5lbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuXHRcdHZhciBwYXJlbnROb2RlID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG5cblx0XHRpZiAoIXBhcmVudE5vZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0fTtcblxuXHRET01SZW5kZXJlci5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKGl0ZW1zKSB7XG5cdFx0aWYgKCFpdGVtcy5sZW5ndGggfHwgaXRlbXNbMF0uZWwpIHtcblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdFx0dmFyIGVsZW1lbnRzID0gKDAsIF91dGlscy4kKShpdGVtcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcblx0XHRcdHZhciBjb250ZW50ID0gX3JlZi5jb250ZW50O1xuXHRcdFx0cmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXltcXHNcXHVGRUZGXSt8W1xcc1xcdUZFRkZdKyQvZywgXCJcIik7XG5cdFx0fSkuam9pbihcIlwiKSwgX2NvbnN0cy5NVUxUSSk7XG5cblx0XHRyZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuXHRcdFx0aXRlbS5lbCA9IGVsZW1lbnRzW2luZGV4XTtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTVJlbmRlcmVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NUmVuZGVyZXIpO1xuXG5cdFx0X2V4dGVuZHModGhpcy5vcHRpb25zID0ge1xuXHRcdFx0aXNPdmVyZmxvd1Njcm9sbDogZmFsc2UsXG5cdFx0XHRpc0VxdWFsU2l6ZTogZmFsc2UsXG5cdFx0XHRob3Jpem9udGFsOiBmYWxzZVxuXHRcdH0sIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NpemUgPSB7XG5cdFx0XHRjb250YWluZXI6IC0xLFxuXHRcdFx0dmlldzogLTEsXG5cdFx0XHR2aWV3cG9ydDogLTEsXG5cdFx0XHRpdGVtOiBudWxsXG5cdFx0fTtcblx0XHR0aGlzLl9pbml0KGVsZW1lbnQpO1xuXHRcdHRoaXMucmVzaXplKCk7XG5cdH1cblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuZ2V0U3RhdHVzID0gZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjc3NUZXh0OiB0aGlzLmNvbnRhaW5lci5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0b3B0aW9uczogX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucyksXG5cdFx0XHRfc2l6ZTogX2V4dGVuZHMoe30sIHRoaXMuX3NpemUpXG5cdFx0fTtcblx0fTtcblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24gc2V0U3RhdHVzKHN0YXR1cykge1xuXHRcdHRoaXMuY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBzdGF0dXMuY3NzVGV4dDtcblx0XHRfZXh0ZW5kcyh0aGlzLm9wdGlvbnMsIHN0YXR1cy5vcHRpb25zKTtcblx0XHRfZXh0ZW5kcyh0aGlzLl9zaXplLCBzdGF0dXMuX3NpemUpO1xuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gdXBkYXRlU2l6ZShpdGVtcykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRyZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5lbCkge1xuXHRcdFx0XHRpZiAoX3RoaXMub3B0aW9ucy5pc0VxdWFsU2l6ZSkge1xuXHRcdFx0XHRcdF90aGlzLl9zaXplLml0ZW0gPSBfdGhpcy5fc2l6ZS5pdGVtIHx8IHtcblx0XHRcdFx0XHRcdHdpZHRoOiAoMCwgX3V0aWxzLmlubmVyV2lkdGgpKGl0ZW0uZWwpLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiAoMCwgX3V0aWxzLmlubmVySGVpZ2h0KShpdGVtLmVsKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aXRlbS5zaXplID0gX2V4dGVuZHMoe30sIF90aGlzLl9zaXplLml0ZW0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZW0uc2l6ZSA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiAoMCwgX3V0aWxzLmlubmVyV2lkdGgpKGl0ZW0uZWwpLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiAoMCwgX3V0aWxzLmlubmVySGVpZ2h0KShpdGVtLmVsKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpdGVtLm9yZ1NpemUpIHtcblx0XHRcdFx0XHRpdGVtLm9yZ1NpemUgPSBfZXh0ZW5kcyh7fSwgaXRlbS5zaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSk7XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoZWwpIHtcblx0XHR2YXIgZWxlbWVudCA9ICgwLCBfdXRpbHMuJCkoZWwpO1xuXHRcdHZhciBzdHlsZSA9ICgwLCBfdXRpbHMuZ2V0U3R5bGVzKShlbGVtZW50KTtcblx0XHR2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIGlzT3ZlcmZsb3dTY3JvbGwgPSBfb3B0aW9ucy5pc092ZXJmbG93U2Nyb2xsLFxuXHRcdCAgICBob3Jpem9udGFsID0gX29wdGlvbnMuaG9yaXpvbnRhbDtcblxuXG5cdFx0dGhpcy5fb3JnU3R5bGUgPSB7fTtcblxuXHRcdGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuXHRcdFx0dGhpcy5fb3JnU3R5bGUucG9zaXRpb24gPSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cdFx0aWYgKGlzT3ZlcmZsb3dTY3JvbGwpIHtcblx0XHRcdHZhciB0YXJnZXQgPSBob3Jpem9udGFsID8gW1wiWFwiLCBcIllcIl0gOiBbXCJZXCIsIFwiWFwiXTtcblxuXHRcdFx0dGhpcy5fb3JnU3R5bGUub3ZlcmZsb3dYID0gZWxlbWVudC5zdHlsZS5vdmVyZmxvd1g7XG5cdFx0XHR0aGlzLl9vcmdTdHlsZS5vdmVyZmxvd1kgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93WTtcblx0XHRcdGVsZW1lbnQuc3R5bGVbXCJvdmVyZmxvd1wiICsgdGFyZ2V0WzBdXSA9IFwic2Nyb2xsXCI7XG5cdFx0XHRlbGVtZW50LnN0eWxlW1wib3ZlcmZsb3dcIiArIHRhcmdldFsxXV0gPSBcImhpZGRlblwiO1xuXHRcdFx0dGhpcy52aWV3ID0gZWxlbWVudDtcblx0XHRcdC8vIGRlZmVuc2UgY29kZSBmb3IgYW5kcm9pZCA8IDQuNCBvciB3ZWJraXQgPCA1Mzdcblx0XHRcdHRoaXMuY29udGFpbmVyID0gaG9yaXpvbnRhbCAmJiBfY29uc3RzLkRFRkVOU0VfQlJPV1NFUiA/IF9kZWZlbnNlKGVsZW1lbnQpIDogZWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3ID0gd2luZG93O1xuXHRcdFx0dGhpcy5jb250YWluZXIgPSBlbGVtZW50O1xuXHRcdH1cblx0fTtcblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGl0ZW1zKSB7XG5cdFx0dGhpcy5faW5zZXJ0KGl0ZW1zLCBfY29uc3RzLkFQUEVORCwge1xuXHRcdFx0dG9wOiBfY29uc3RzLkRVTU1ZX1BPU0lUSU9OLFxuXHRcdFx0bGVmdDogX2NvbnN0cy5EVU1NWV9QT1NJVElPTlxuXHRcdH0pO1xuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZChpdGVtcykge1xuXHRcdHRoaXMuX2luc2VydChpdGVtcywgX2NvbnN0cy5QUkVQRU5ELCB7XG5cdFx0XHR0b3A6IF9jb25zdHMuRFVNTVlfUE9TSVRJT04sXG5cdFx0XHRsZWZ0OiBfY29uc3RzLkRVTU1ZX1BPU0lUSU9OXG5cdFx0fSk7XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0dGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pc092ZXJmbG93U2Nyb2xsKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5zdHlsZVt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gXCJcIjtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IHtcblx0XHRcdGl0ZW06IG51bGwsXG5cdFx0XHR2aWV3cG9ydDogLTEsXG5cdFx0XHRjb250YWluZXI6IC0xLFxuXHRcdFx0dmlldzogLTFcblx0XHR9O1xuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVBbmRJbnNlcnQgPSBmdW5jdGlvbiBjcmVhdGVBbmRJbnNlcnQoaXRlbXMsIGlzQXBwZW5kKSB7XG5cdFx0dmFyIGl0ZW1zV2l0aEVsZW1lbnQgPSBET01SZW5kZXJlci5jcmVhdGVFbGVtZW50cyhpdGVtcyk7XG5cblx0XHRET01SZW5kZXJlci5yZW5kZXJJdGVtcyhpdGVtc1dpdGhFbGVtZW50KTtcblx0XHR0aGlzLl9pbnNlcnQoaXRlbXNXaXRoRWxlbWVudCwgaXNBcHBlbmQpO1xuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gX2luc2VydChpdGVtcywgaXNBcHBlbmQsIHN0eWxlcykge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblx0XHR2YXIgZGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRzdHlsZXMgJiYgRE9NUmVuZGVyZXIucmVuZGVySXRlbShpdGVtLCBzdHlsZXMpO1xuXHRcdFx0aXNBcHBlbmQgPyBkZi5hcHBlbmRDaGlsZChpdGVtLmVsKSA6IGRmLmluc2VydEJlZm9yZShpdGVtLmVsLCBkZi5maXJzdENoaWxkKTtcblx0XHR9KTtcblx0XHRpc0FwcGVuZCA/IGNvbnRhaW5lci5hcHBlbmRDaGlsZChkZikgOiBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGRmLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucHJvdG90eXBlLl9jYWxjU2l6ZSA9IGZ1bmN0aW9uIF9jYWxjU2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyAoMCwgX3V0aWxzLmlubmVySGVpZ2h0KSh0aGlzLmNvbnRhaW5lcikgOiAoMCwgX3V0aWxzLmlubmVyV2lkdGgpKHRoaXMuY29udGFpbmVyKTtcblx0fTtcblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuZ2V0Vmlld1NpemUgPSBmdW5jdGlvbiBnZXRWaWV3U2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS52aWV3O1xuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRWaWV3cG9ydFNpemUgPSBmdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUudmlld3BvcnQ7XG5cdH07XG5cblx0RE9NUmVuZGVyZXIucHJvdG90eXBlLnNldENvbnRhaW5lclNpemUgPSBmdW5jdGlvbiBzZXRDb250YWluZXJTaXplKHNpemUpIHtcblx0XHR2YXIgX29wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuXHRcdCAgICBpc092ZXJmbG93U2Nyb2xsID0gX29wdGlvbnMyLmlzT3ZlcmZsb3dTY3JvbGwsXG5cdFx0ICAgIGhvcml6b250YWwgPSBfb3B0aW9uczIuaG9yaXpvbnRhbDtcblxuXG5cdFx0aWYgKCFpc092ZXJmbG93U2Nyb2xsIHx8IGhvcml6b250YWwgJiYgX2NvbnN0cy5ERUZFTlNFX0JST1dTRVIpIHtcblx0XHRcdHRoaXMuY29udGFpbmVyLnN0eWxlW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IHNpemUgKyBcInB4XCI7XG5cdFx0fVxuXHR9O1xuXG5cdERPTVJlbmRlcmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoKSB7XG5cdFx0dmFyIGhvcml6b250YWwgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbDtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgaXNSZXNpemUgPSB0aGlzLmlzTmVlZGVkUmVzaXplKCk7XG5cblx0XHRpZiAoaXNSZXNpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSB7XG5cdFx0XHRcdHZpZXdwb3J0OiB0aGlzLl9jYWxjU2l6ZSgpLFxuXHRcdFx0XHRpdGVtOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLl9zaXplLnZpZXcgPSBob3Jpem9udGFsID8gKDAsIF91dGlscy5pbm5lcldpZHRoKSh2aWV3KSA6ICgwLCBfdXRpbHMuaW5uZXJIZWlnaHQpKHZpZXcpO1xuXHRcdHJldHVybiBpc1Jlc2l6ZTtcblx0fTtcblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuaXNOZWVkZWRSZXNpemUgPSBmdW5jdGlvbiBpc05lZWRlZFJlc2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FsY1NpemUoKSAhPT0gdGhpcy5fc2l6ZS52aWV3cG9ydDtcblx0fTtcblxuXHRET01SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fc2l6ZSA9IHtcblx0XHRcdHZpZXdwb3J0OiAtMSxcblx0XHRcdHZpZXc6IC0xLFxuXHRcdFx0aXRlbTogbnVsbFxuXHRcdH07XG5cdFx0dGhpcy5jb250YWluZXIuc3R5bGVbdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IFwiXCI7XG5cdFx0Zm9yICh2YXIgcCBpbiB0aGlzLl9vcmdTdHlsZSkge1xuXHRcdFx0dGhpc1t0aGlzLm9wdGlvbnMuaXNPdmVyZmxvd1Njcm9sbCA/IFwidmlld1wiIDogXCJjb250YWluZXJcIl0uc3R5bGVbcF0gPSB0aGlzLl9vcmdTdHlsZVtwXTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIERPTVJlbmRlcmVyO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERPTVJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkNIRUNLX09OTFlfRVJST1IgPSBleHBvcnRzLkNIRUNLX0FMTCA9IHVuZGVmaW5lZDtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9BdXRvU2l6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX0F1dG9TaXplcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdXRvU2l6ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENIRUNLX0FMTCA9IGV4cG9ydHMuQ0hFQ0tfQUxMID0gMTtcbnZhciBDSEVDS19PTkxZX0VSUk9SID0gZXhwb3J0cy5DSEVDS19PTkxZX0VSUk9SID0gMjtcblxuZnVuY3Rpb24gaXNEYXRhQXR0cmlidXRlKHRhcmdldCwgcHJlZml4KSB7XG5cdHJldHVybiAhIXRhcmdldC5nZXRBdHRyaWJ1dGUocHJlZml4ICsgXCJ3aWR0aFwiKTtcbn1cblxudmFyIEltYWdlTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBJbWFnZUxvYWRlZCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VMb2FkZWQpO1xuXHR9XG5cblx0SW1hZ2VMb2FkZWQud2FpdEltYWdlTG9hZGVkID0gZnVuY3Rpb24gd2FpdEltYWdlTG9hZGVkKG5lZWRDaGVjaywgX3JlZikge1xuXHRcdHZhciBfcmVmJHByZWZpeCA9IF9yZWYucHJlZml4LFxuXHRcdCAgICBwcmVmaXggPSBfcmVmJHByZWZpeCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9yZWYkcHJlZml4LFxuXHRcdCAgICBsZW5ndGggPSBfcmVmLmxlbmd0aCxcblx0XHQgICAgdHlwZSA9IF9yZWYudHlwZSxcblx0XHQgICAgY29tcGxldGUgPSBfcmVmLmNvbXBsZXRlLFxuXHRcdCAgICBlcnJvciA9IF9yZWYuZXJyb3IsXG5cdFx0ICAgIGVuZCA9IF9yZWYuZW5kO1xuXG5cdFx0dmFyIGNoZWNrQ291bnQgPSAwO1xuXHRcdHZhciBlbmRDb3VudCA9IGxlbmd0aDtcblxuXHRcdGlmICh0eXBlICE9PSBDSEVDS19PTkxZX0VSUk9SKSB7XG5cdFx0XHRjaGVja0NvdW50ID0gZW5kQ291bnQ7XG5cdFx0fVxuXHRcdHZhciBjaGVja0VuZCA9IGZ1bmN0aW9uIGNoZWNrRW5kKCkge1xuXHRcdFx0aWYgKC0tZW5kQ291bnQgIT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZW5kICYmIGVuZCgpO1xuXHRcdH07XG5cdFx0dmFyIGNoZWNrSW1hZ2UgPSBmdW5jdGlvbiBjaGVja0ltYWdlKCkge1xuXHRcdFx0Y2hlY2tDb3VudC0tO1xuXHRcdFx0aWYgKGNoZWNrQ291bnQgIT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29tcGxldGUgJiYgY29tcGxldGUoKTtcblx0XHR9O1xuXHRcdHZhciBvbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcih0YXJnZXQpIHtcblx0XHRcdHZhciBpdGVtSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRhcmdldC5fX0lURU1fSU5ERVhfXztcblxuXHRcdFx0ZXJyb3IgJiYgZXJyb3Ioe1xuXHRcdFx0XHR0YXJnZXQ6IHRhcmdldCxcblx0XHRcdFx0aXRlbUluZGV4OiBpdGVtSW5kZXhcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0dmFyIG9uQ2hlY2sgPSBmdW5jdGlvbiBvbkNoZWNrKGUpIHtcblx0XHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cblx0XHRcdCgwLCBfdXRpbHMucmVtb3ZlRXZlbnQpKHRhcmdldCwgXCJlcnJvclwiLCBvbkNoZWNrKTtcblx0XHRcdCgwLCBfdXRpbHMucmVtb3ZlRXZlbnQpKHRhcmdldCwgXCJsb2FkXCIsIG9uQ2hlY2spO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gQ0hFQ0tfQUxMICYmIGlzRGF0YUF0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkpIHtcblx0XHRcdFx0X0F1dG9TaXplcjJbXCJkZWZhdWx0XCJdLnJlbW92ZSh0YXJnZXQsIGUudHlwZSA9PT0gXCJlcnJvclwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoZWNrSW1hZ2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0XHRvbkVycm9yKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgdGFyZ2V0Ll9fSVRFTV9JTkRFWF9fO1xuXHRcdFx0Y2hlY2tFbmQoKTtcblx0XHR9O1xuXG5cdFx0bmVlZENoZWNrLmZvckVhY2goZnVuY3Rpb24gKGltYWdlcywgaSkge1xuXHRcdFx0aW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgSUVcblx0XHRcdFx0aWYgKHYuY29tcGxldGUgJiYgKCFfY29uc3RzLklTX0lFIHx8IF9jb25zdHMuSVNfSUUgJiYgdi5uYXR1cmFsV2lkdGgpKSB7XG5cdFx0XHRcdFx0aWYgKCF2Lm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRcdFx0b25FcnJvcih2LCBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hlY2tJbWFnZSgpO1xuXHRcdFx0XHRcdGNoZWNrRW5kKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHYuX19JVEVNX0lOREVYX18gPSBpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gQ0hFQ0tfQUxMICYmIGlzRGF0YUF0dHJpYnV0ZSh2LCBwcmVmaXgpKSB7XG5cdFx0XHRcdFx0X0F1dG9TaXplcjJbXCJkZWZhdWx0XCJdLmFkZCh2LCBwcmVmaXgpO1xuXHRcdFx0XHRcdGNoZWNrSW1hZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQoMCwgX3V0aWxzLmFkZEV2ZW50KSh2LCBcImxvYWRcIiwgb25DaGVjayk7XG5cdFx0XHRcdCgwLCBfdXRpbHMuYWRkRXZlbnQpKHYsIFwiZXJyb3JcIiwgb25DaGVjayk7XG5cblx0XHRcdFx0X2NvbnN0cy5JU19JRSAmJiB2LnNldEF0dHJpYnV0ZShcInNyY1wiLCB2LmdldEF0dHJpYnV0ZShcInNyY1wiKSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcblxuXHRJbWFnZUxvYWRlZC5jaGVja0ltYWdlTG9hZGVkID0gZnVuY3Rpb24gY2hlY2tJbWFnZUxvYWRlZChlbCkge1xuXHRcdGlmIChlbC50YWdOYW1lID09PSBcIklNR1wiKSB7XG5cdFx0XHRyZXR1cm4gZWwuY29tcGxldGUgPyBbXSA6IFtlbF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoMCwgX3V0aWxzLnRvQXJyYXkpKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpO1xuXHRcdH1cblx0fTtcblxuXHRJbWFnZUxvYWRlZC5jaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGVsZW1lbnRzLCBfcmVmMikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHR2YXIgcHJlZml4ID0gX3JlZjIucHJlZml4LFxuXHRcdCAgICBfcmVmMiR0eXBlID0gX3JlZjIudHlwZSxcblx0XHQgICAgdHlwZSA9IF9yZWYyJHR5cGUgPT09IHVuZGVmaW5lZCA/IENIRUNLX0FMTCA6IF9yZWYyJHR5cGUsXG5cdFx0ICAgIGNvbXBsZXRlID0gX3JlZjIuY29tcGxldGUsXG5cdFx0ICAgIGVycm9yID0gX3JlZjIuZXJyb3IsXG5cdFx0ICAgIGVuZCA9IF9yZWYyLmVuZDtcblxuXHRcdHZhciBpbWFnZXMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBfdGhpcy5jaGVja0ltYWdlTG9hZGVkKGVsZW1lbnQpO1xuXHRcdH0pO1xuXHRcdHZhciBsZW5ndGggPSBpbWFnZXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBzdW0gKyBlbGVtZW50Lmxlbmd0aDtcblx0XHR9LCAwKTtcblxuXHRcdGlmICh0eXBlID09PSBDSEVDS19PTkxZX0VSUk9SIHx8IGxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gY29udmVydCB0byBhc3luY1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbXBsZXRlICYmIGNvbXBsZXRlKCk7XG5cdFx0XHRcdGlmIChsZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRlbmQgJiYgZW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDApO1xuXHRcdH1cblx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzLndhaXRJbWFnZUxvYWRlZChpbWFnZXMsIHsgcHJlZml4OiBwcmVmaXgsIGxlbmd0aDogbGVuZ3RoLCB0eXBlOiB0eXBlLCBjb21wbGV0ZTogY29tcGxldGUsIGVycm9yOiBlcnJvciwgZW5kOiBlbmQgfSk7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEltYWdlTG9hZGVkO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEltYWdlTG9hZGVkO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFdhdGNoZXIodmlldywgb3B0aW9ucykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYXRjaGVyKTtcblxuXHRcdF9leHRlbmRzKHRoaXMub3B0aW9ucyA9IHtcblx0XHRcdGNvbnRhaW5lcjogdmlldyxcblx0XHRcdHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge30sXG5cdFx0XHRjaGVjazogZnVuY3Rpb24gY2hlY2soKSB7fSxcblx0XHRcdGlzT3ZlcmZsb3dTY3JvbGw6IGZhbHNlLFxuXHRcdFx0aG9yaXpvbnRhbDogZmFsc2Vcblx0XHR9LCBvcHRpb25zKTtcblx0XHR0aGlzLl90aW1lciA9IHtcblx0XHRcdHJlc2l6ZTogbnVsbFxuXHRcdFx0Ly8gZG91YmxlQ2hlY2s6IG51bGwsXG5cdFx0XHQvLyBkb3VibGVDaGVja0NvdW50OiBSRVRSWSxcblx0XHR9O1xuXHRcdHRoaXMucmVzZXQoKTtcblx0XHR0aGlzLl9jb250YWluZXJPZmZzZXQgPSAwO1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHRcdHRoaXMuX29uQ2hlY2sgPSB0aGlzLl9vbkNoZWNrLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25SZXNpemUgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuYXR0YWNoRXZlbnQoKTtcblx0XHR0aGlzLnNldFNjcm9sbFBvcygpO1xuXHRcdHRoaXMuX3NldENvbnRhaW5lck9mZnNldCgpO1xuXHR9XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuZ2V0U3RhdHVzID0gZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRfcHJldlBvczogdGhpcy5fcHJldlBvcyxcblx0XHRcdHNjcm9sbFBvczogdGhpcy5nZXRPcmdTY3JvbGxQb3MoKVxuXHRcdH07XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24gc2V0U3RhdHVzKHN0YXR1cykge1xuXHRcdHZhciBhcHBseVNjcm9sbFBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuXHRcdHRoaXMuX3ByZXZQb3MgPSBzdGF0dXMuX3ByZXZQb3M7XG5cdFx0YXBwbHlTY3JvbGxQb3MgJiYgdGhpcy5zY3JvbGxUbyhzdGF0dXMuc2Nyb2xsUG9zKTtcblx0fTtcblxuXHRXYXRjaGVyLnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uIHNjcm9sbEJ5KHBvcykge1xuXHRcdHZhciBhcnJQb3MgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFtwb3MsIDBdIDogWzAsIHBvc107XG5cblx0XHRfdXRpbHMuc2Nyb2xsQnkuYXBwbHkodW5kZWZpbmVkLCBbdGhpcy5fdmlld10uY29uY2F0KGFyclBvcykpO1xuXHRcdHRoaXMuc2V0U2Nyb2xsUG9zKCk7XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbiBzY3JvbGxUbyhwb3MpIHtcblx0XHR2YXIgYXJyUG9zID0gdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBbcG9zLCAwXSA6IFswLCBwb3NdO1xuXG5cdFx0X3V0aWxzLnNjcm9sbFRvLmFwcGx5KHVuZGVmaW5lZCwgW3RoaXMuX3ZpZXddLmNvbmNhdChhcnJQb3MpKTtcblx0fTtcblxuXHRXYXRjaGVyLnByb3RvdHlwZS5nZXRTY3JvbGxQb3MgPSBmdW5jdGlvbiBnZXRTY3JvbGxQb3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ByZXZQb3M7XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuc2V0U2Nyb2xsUG9zID0gZnVuY3Rpb24gc2V0U2Nyb2xsUG9zKHBvcykge1xuXHRcdHZhciByYXdQb3MgPSBwb3M7XG5cblx0XHRpZiAodHlwZW9mIHBvcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0cmF3UG9zID0gdGhpcy5nZXRPcmdTY3JvbGxQb3MoKTtcblx0XHR9XG5cdFx0dGhpcy5fcHJldlBvcyA9IHJhd1BvcyAtIHRoaXMuZ2V0Q29udGFpbmVyT2Zmc2V0KCk7XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuYXR0YWNoRXZlbnQgPSBmdW5jdGlvbiBhdHRhY2hFdmVudCgpIHtcblx0XHQoMCwgX3V0aWxzLmFkZEV2ZW50KSh0aGlzLl92aWV3LCBcInNjcm9sbFwiLCB0aGlzLl9vbkNoZWNrKTtcblx0XHQoMCwgX3V0aWxzLmFkZEV2ZW50KSh3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uUmVzaXplKTtcblx0fTtcblxuXHRXYXRjaGVyLnByb3RvdHlwZS5nZXRPcmdTY3JvbGxQb3MgPSBmdW5jdGlvbiBnZXRPcmdTY3JvbGxQb3MoKSB7XG5cdFx0cmV0dXJuICgwLCBfdXRpbHMuc2Nyb2xsKSh0aGlzLl92aWV3LCB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCk7XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0XHR0aGlzLl9wcmV2UG9zID0gbnVsbDtcblx0fTtcblxuXHRXYXRjaGVyLnByb3RvdHlwZS5fb25DaGVjayA9IGZ1bmN0aW9uIF9vbkNoZWNrKCkge1xuXHRcdHZhciBwcmV2UG9zID0gdGhpcy5nZXRTY3JvbGxQb3MoKTtcblx0XHR2YXIgb3JnU2Nyb2xsUG9zID0gdGhpcy5nZXRPcmdTY3JvbGxQb3MoKTtcblxuXHRcdHRoaXMuc2V0U2Nyb2xsUG9zKG9yZ1Njcm9sbFBvcyk7XG5cdFx0dmFyIHNjcm9sbFBvcyA9IHRoaXMuZ2V0U2Nyb2xsUG9zKCk7XG5cblx0XHRpZiAocHJldlBvcyA9PT0gbnVsbCB8fCBfY29uc3RzLklTX0lPUyAmJiBvcmdTY3JvbGxQb3MgPT09IDAgfHwgcHJldlBvcyA9PT0gc2Nyb2xsUG9zKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zLmNoZWNrKHtcblx0XHRcdGlzRm9yd2FyZDogcHJldlBvcyA8IHNjcm9sbFBvcyxcblx0XHRcdHNjcm9sbFBvczogc2Nyb2xsUG9zLFxuXHRcdFx0b3JnU2Nyb2xsUG9zOiBvcmdTY3JvbGxQb3MsXG5cdFx0XHRob3Jpem9udGFsOiB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFxuXHRcdH0pO1xuXHR9O1xuXG5cdFdhdGNoZXIucHJvdG90eXBlLmdldENvbnRhaW5lck9mZnNldCA9IGZ1bmN0aW9uIGdldENvbnRhaW5lck9mZnNldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyT2Zmc2V0O1xuXHR9O1xuXG5cdFdhdGNoZXIucHJvdG90eXBlLl9zZXRDb250YWluZXJPZmZzZXQgPSBmdW5jdGlvbiBfc2V0Q29udGFpbmVyT2Zmc2V0KCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lck9mZnNldCA9IHRoaXMub3B0aW9ucy5pc092ZXJmbG93U2Nyb2xsID8gMCA6IHRoaXMub3B0aW9ucy5jb250YWluZXJbXCJvZmZzZXRcIiArICh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwiTGVmdFwiIDogXCJUb3BcIildO1xuXHR9O1xuXG5cdFdhdGNoZXIucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMuX3RpbWVyLnJlc2l6ZSkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyLnJlc2l6ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX3RpbWVyLnJlc2l6ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0X3RoaXMuX3NldENvbnRhaW5lck9mZnNldCgpO1xuXHRcdFx0X3RoaXMub3B0aW9ucy5yZXNpemUoKTtcblx0XHRcdF90aGlzLl90aW1lci5yZXNpemUgPSBudWxsO1xuXHRcdFx0X3RoaXMucmVzZXQoKTtcblx0XHR9LCAxMDApO1xuXHR9O1xuXG5cdFdhdGNoZXIucHJvdG90eXBlLmRldGFjaEV2ZW50ID0gZnVuY3Rpb24gZGV0YWNoRXZlbnQoKSB7XG5cdFx0KDAsIF91dGlscy5yZW1vdmVFdmVudCkod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9vblJlc2l6ZSk7XG5cdH07XG5cblx0V2F0Y2hlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5kZXRhY2hFdmVudCgpO1xuXHRcdHRoaXMucmVzZXQoKTtcblx0fTtcblxuXHRyZXR1cm4gV2F0Y2hlcjtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBXYXRjaGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGlzVmlzaWJsZShncm91cCwgdGhyZXNob2xkLCBzY3JvbGxQb3MsIGVuZFNjcm9sbFBvcykge1xuXHR2YXIgaXRlbXMgPSBncm91cC5pdGVtcyxcblx0ICAgIG91dGxpbmVzID0gZ3JvdXAub3V0bGluZXM7XG5cblx0dmFyIHN0YXJ0ID0gb3V0bGluZXMuc3RhcnQ7XG5cdHZhciBlbmQgPSBvdXRsaW5lcy5lbmQ7XG5cblx0aWYgKHN0YXJ0LmxlZ250aCA9PT0gMCB8fCBlbmQubGVuZ3RoID09PSAwIHx8ICFpdGVtcy5sZW5ndGggfHwgIWl0ZW1zWzBdLmVsKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblx0dmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHN0YXJ0KTtcblx0dmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGVuZCk7XG5cblx0aWYgKGVuZFNjcm9sbFBvcyArIHRocmVzaG9sZCA8IG1pbikge1xuXHRcdHJldHVybiArMTtcblx0fSBlbHNlIGlmIChzY3JvbGxQb3MgLSB0aHJlc2hvbGQgPiBtYXgpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblx0cmV0dXJuIDA7XG59XG5cbnZhciBJbmZpbml0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gSW5maW5pdGUoaXRlbU1hbmdlciwgb3B0aW9ucykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmZpbml0ZSk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7XG5cdFx0XHR1c2VSZWN5Y2xlOiB0cnVlLFxuXHRcdFx0dGhyZXNob2xkOiAxMDAsXG5cdFx0XHRhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCgpIHt9LFxuXHRcdFx0cHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHt9LFxuXHRcdFx0cmVjeWNsZTogZnVuY3Rpb24gcmVjeWNsZSgpIHt9XG5cdFx0fSwgb3B0aW9ucyk7XG5cdFx0dGhpcy5faXRlbXMgPSBpdGVtTWFuZ2VyO1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXG5cdEluZmluaXRlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZShzaXplKSB7XG5cdFx0dGhpcy5fc3RhdHVzLnNpemUgPSBzaXplO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gcmVjeWNsZShzY3JvbGxQb3MsIGlzRm9yd2FyZCkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnVzZVJlY3ljbGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIF9zdGF0dXMgPSB0aGlzLl9zdGF0dXMsXG5cdFx0ICAgIHN0YXJ0Q3Vyc29yID0gX3N0YXR1cy5zdGFydEN1cnNvcixcblx0XHQgICAgZW5kQ3Vyc29yID0gX3N0YXR1cy5lbmRDdXJzb3IsXG5cdFx0ICAgIHNpemUgPSBfc3RhdHVzLnNpemU7XG5cblxuXHRcdGlmIChzdGFydEN1cnNvciA9PT0gLTEgfHwgZW5kQ3Vyc29yID09PSAtMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZW5kU2Nyb2xsUG9zID0gc2Nyb2xsUG9zICsgc2l6ZTtcblx0XHR2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIHRocmVzaG9sZCA9IF9vcHRpb25zLnRocmVzaG9sZCxcblx0XHQgICAgcmVjeWNsZSA9IF9vcHRpb25zLnJlY3ljbGU7XG5cblx0XHR2YXIgdmlzaWJsZXMgPSB0aGlzLl9pdGVtcy5nZXQoc3RhcnRDdXJzb3IsIGVuZEN1cnNvcikubWFwKGZ1bmN0aW9uIChncm91cCkge1xuXHRcdFx0cmV0dXJuIGlzVmlzaWJsZShncm91cCwgdGhyZXNob2xkLCBzY3JvbGxQb3MsIGVuZFNjcm9sbFBvcyk7XG5cdFx0fSk7XG5cdFx0dmFyIGxlbmd0aCA9IHZpc2libGVzLmxlbmd0aDtcblx0XHR2YXIgc3RhcnQgPSBpc0ZvcndhcmQgPyAwIDogdmlzaWJsZXMubGFzdEluZGV4T2YoMCk7XG5cdFx0dmFyIGVuZCA9IGlzRm9yd2FyZCA/IHZpc2libGVzLmluZGV4T2YoMCkgLSAxIDogdmlzaWJsZXMubGVuZ3RoIC0gMTtcblxuXHRcdGlmICghaXNGb3J3YXJkICYmIHN0YXJ0ICE9PSAtMSkge1xuXHRcdFx0c3RhcnQgKz0gMTtcblx0XHR9XG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCAwIHx8IHN0YXJ0ID4gZW5kIHx8IGVuZCAtIHN0YXJ0ICsgMSA+PSBsZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c3RhcnQgPSBzdGFydEN1cnNvciArIHN0YXJ0O1xuXHRcdGVuZCA9IHN0YXJ0Q3Vyc29yICsgZW5kO1xuXG5cdFx0cmVjeWNsZSh7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG5cdFx0aWYgKGlzRm9yd2FyZCkge1xuXHRcdFx0dGhpcy5zZXRDdXJzb3IoXCJzdGFydFwiLCBlbmQgKyAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRDdXJzb3IoXCJlbmRcIiwgc3RhcnQgLSAxKTtcblx0XHR9XG5cdH07XG5cblx0SW5maW5pdGUucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbChzY3JvbGxQb3MsIGlzRm9yd2FyZCkge1xuXHRcdHZhciBfc3RhdHVzMiA9IHRoaXMuX3N0YXR1cyxcblx0XHQgICAgc3RhcnRDdXJzb3IgPSBfc3RhdHVzMi5zdGFydEN1cnNvcixcblx0XHQgICAgZW5kQ3Vyc29yID0gX3N0YXR1czIuZW5kQ3Vyc29yLFxuXHRcdCAgICBzaXplID0gX3N0YXR1czIuc2l6ZTtcblxuXG5cdFx0aWYgKHN0YXJ0Q3Vyc29yID09PSAtMSB8fCBlbmRDdXJzb3IgPT09IC0xKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBfb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIGFwcGVuZCA9IF9vcHRpb25zMi5hcHBlbmQsXG5cdFx0ICAgIHByZXBlbmQgPSBfb3B0aW9uczIucHJlcGVuZCxcblx0XHQgICAgdGhyZXNob2xkID0gX29wdGlvbnMyLnRocmVzaG9sZDtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXHRcdHZhciBsZW5ndGggPSBpdGVtcy5zaXplKCk7XG5cdFx0dmFyIGVuZFNjcm9sbFBvcyA9IHNjcm9sbFBvcyArIHNpemU7XG5cdFx0dmFyIHRhcmdldEl0ZW0gPSBpdGVtcy5nZXREYXRhKGlzRm9yd2FyZCA/IGVuZEN1cnNvciA6IHN0YXJ0Q3Vyc29yKTtcblx0XHR2YXIgb3V0bGluZXMgPSB0YXJnZXRJdGVtLm91dGxpbmVzW2lzRm9yd2FyZCA/IFwiZW5kXCIgOiBcInN0YXJ0XCJdO1xuXHRcdHZhciBlZGdlUG9zID0gTWF0aFtpc0ZvcndhcmQgPyBcIm1pblwiIDogXCJtYXhcIl0uYXBwbHkoTWF0aCwgb3V0bGluZXMpO1xuXG5cdFx0aWYgKGlzRm9yd2FyZCkge1xuXHRcdFx0aWYgKGVuZFNjcm9sbFBvcyA+PSBlZGdlUG9zIC0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdGFwcGVuZCh7IGNhY2hlOiBsZW5ndGggPiBlbmRDdXJzb3IgKyAxICYmIGl0ZW1zLmdldERhdGEoZW5kQ3Vyc29yICsgMSkgfSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzY3JvbGxQb3MgPD0gZWRnZVBvcyArIHRocmVzaG9sZCkge1xuXHRcdFx0cHJlcGVuZCh7IGNhY2hlOiBzdGFydEN1cnNvciA+IDAgJiYgaXRlbXMuZ2V0RGF0YShzdGFydEN1cnNvciAtIDEpIH0pO1xuXHRcdH1cblx0fTtcblxuXHRJbmZpbml0ZS5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGN1cnNvciwgaW5kZXgpIHtcblx0XHR2YXIgc3RhdHVzID0gdGhpcy5fc3RhdHVzO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXNlUmVjeWNsZSkge1xuXHRcdFx0c3RhdHVzLnN0YXJ0Q3Vyc29yID0gMDtcblx0XHRcdHN0YXR1cy5lbmRDdXJzb3IgPSB0aGlzLl9pdGVtcy5zaXplKCkgLSAxO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoY3Vyc29yID09PSBcInN0YXJ0XCIpIHtcblx0XHRcdHN0YXR1cy5zdGFydEN1cnNvciA9IGluZGV4O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGF0dXMuZW5kQ3Vyc29yID0gTWF0aC5taW4odGhpcy5faXRlbXMuc2l6ZSgpIC0gMSwgaW5kZXgpO1xuXHRcdH1cblx0XHRzdGF0dXMuc3RhcnRDdXJzb3IgPSBNYXRoLm1heCgwLCBzdGF0dXMuc3RhcnRDdXJzb3IpO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS51cGRhdGVDdXJzb3IgPSBmdW5jdGlvbiB1cGRhdGVDdXJzb3IoY3Vyc29yKSB7XG5cdFx0dmFyIF9zdGF0dXMzID0gdGhpcy5fc3RhdHVzLFxuXHRcdCAgICBzdGFydEN1cnNvciA9IF9zdGF0dXMzLnN0YXJ0Q3Vyc29yLFxuXHRcdCAgICBlbmRDdXJzb3IgPSBfc3RhdHVzMy5lbmRDdXJzb3I7XG5cblxuXHRcdGlmIChjdXJzb3IgPT09IFwic3RhcnRcIikge1xuXHRcdFx0aWYgKHN0YXJ0Q3Vyc29yIDw9IDApIHtcblx0XHRcdFx0dGhpcy5zZXRDdXJzb3IoXCJzdGFydFwiLCAwKTtcblx0XHRcdFx0dGhpcy5zZXRDdXJzb3IoXCJlbmRcIiwgZW5kQ3Vyc29yICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldEN1cnNvcihjdXJzb3IsIHN0YXJ0Q3Vyc29yIC0gMSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0Q3Vyc29yKGN1cnNvciwgZW5kQ3Vyc29yICsgMSk7XG5cdFx0fVxuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShpdGVtKSB7XG5cdFx0dmFyIGlzQXBwZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdFx0dGhpcy5faXRlbXMuc2V0KGl0ZW0sIGl0ZW0uZ3JvdXBLZXkpO1xuXHRcdHRoaXMuc2V0Q3Vyc29yKGlzQXBwZW5kID8gXCJlbmRcIiA6IFwic3RhcnRcIiwgdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKSk7XG5cdH07XG5cblx0SW5maW5pdGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbXMuYXBwZW5kKGl0ZW0pO1xuXHRcdHRoaXMudXBkYXRlQ3Vyc29yKFwiZW5kXCIpO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbXMucHJlcGVuZChpdGVtKTtcblx0XHR0aGlzLnVwZGF0ZUN1cnNvcihcInN0YXJ0XCIpO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG5cdFx0dGhpcy5fc3RhdHVzID0gX2V4dGVuZHModGhpcy5fc3RhdHVzLCBzdGF0dXMpO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG5cdFx0dmFyIF9zdGF0dXM0ID0gdGhpcy5fc3RhdHVzLFxuXHRcdCAgICBzdGFydEN1cnNvciA9IF9zdGF0dXM0LnN0YXJ0Q3Vyc29yLFxuXHRcdCAgICBlbmRDdXJzb3IgPSBfc3RhdHVzNC5lbmRDdXJzb3IsXG5cdFx0ICAgIHNpemUgPSBfc3RhdHVzNC5zaXplO1xuXG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnRDdXJzb3I6IHN0YXJ0Q3Vyc29yLFxuXHRcdFx0ZW5kQ3Vyc29yOiBlbmRDdXJzb3IsXG5cdFx0XHRzaXplOiBzaXplXG5cdFx0fTtcblx0fTtcblxuXHRJbmZpbml0ZS5wcm90b3R5cGUuZ2V0RWRnZU91dGxpbmUgPSBmdW5jdGlvbiBnZXRFZGdlT3V0bGluZShjdXJzb3IpIHtcblx0XHR2YXIgX3N0YXR1czUgPSB0aGlzLl9zdGF0dXMsXG5cdFx0ICAgIHN0YXJ0Q3Vyc29yID0gX3N0YXR1czUuc3RhcnRDdXJzb3IsXG5cdFx0ICAgIGVuZEN1cnNvciA9IF9zdGF0dXM1LmVuZEN1cnNvcjtcblxuXG5cdFx0aWYgKHN0YXJ0Q3Vyc29yID09PSAtMSB8fCBlbmRDdXJzb3IgPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtcy5nZXRPdXRsaW5lKGN1cnNvciA9PT0gXCJzdGFydFwiID8gc3RhcnRDdXJzb3IgOiBlbmRDdXJzb3IsIGN1cnNvcik7XG5cdH07XG5cblx0SW5maW5pdGUucHJvdG90eXBlLmdldEVkZ2VWYWx1ZSA9IGZ1bmN0aW9uIGdldEVkZ2VWYWx1ZShjdXJzb3IpIHtcblx0XHR2YXIgb3V0bGluZXMgPSB0aGlzLmdldEVkZ2VPdXRsaW5lKGN1cnNvcik7XG5cblx0XHRyZXR1cm4gb3V0bGluZXMubGVuZ3RoID8gTWF0aFtjdXJzb3IgPT09IFwic3RhcnRcIiA/IFwibWluXCIgOiBcIm1heFwiXS5hcHBseShNYXRoLCBvdXRsaW5lcykgOiAwO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbiBnZXRWaXNpYmxlSXRlbXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW1zLnBsdWNrKFwiaXRlbXNcIiwgdGhpcy5fc3RhdHVzLnN0YXJ0Q3Vyc29yLCB0aGlzLl9zdGF0dXMuZW5kQ3Vyc29yKTtcblx0fTtcblxuXHRJbmZpbml0ZS5wcm90b3R5cGUuZ2V0Q3Vyc29yID0gZnVuY3Rpb24gZ2V0Q3Vyc29yKGN1cnNvcikge1xuXHRcdHJldHVybiB0aGlzLl9zdGF0dXNbY3Vyc29yID09PSBcInN0YXJ0XCIgPyBcInN0YXJ0Q3Vyc29yXCIgOiBcImVuZEN1cnNvclwiXTtcblx0fTtcblxuXHRJbmZpbml0ZS5wcm90b3R5cGUuZ2V0VmlzaWJsZURhdGEgPSBmdW5jdGlvbiBnZXRWaXNpYmxlRGF0YSgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3N0YXR1cy5zdGFydEN1cnNvciwgdGhpcy5fc3RhdHVzLmVuZEN1cnNvcik7XG5cdH07XG5cblx0SW5maW5pdGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW1zLnJlbW92ZShlbGVtZW50LCB0aGlzLl9zdGF0dXMuc3RhcnRDdXJzb3IsIHRoaXMuX3N0YXR1cy5lbmRDdXJzb3IpO1xuXHR9O1xuXG5cdEluZmluaXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdHRoaXMuX3N0YXR1cyA9IHtcblx0XHRcdHN0YXJ0Q3Vyc29yOiAtMSxcblx0XHRcdGVuZEN1cnNvcjogLTEsXG5cdFx0XHRzaXplOiAtMVxuXHRcdH07XG5cdH07XG5cblx0cmV0dXJuIEluZmluaXRlO1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEluZmluaXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbkZyYW1lXG5bXG5bMSwgMSwgMSwgMSwgMV0sXG5bMCwgMCwgMiwgMiwgMl0sXG5bMCwgMCwgMiwgMiwgMl0sXG5bMywgNCwgNSwgNSwgNV0sXG5dXG4qL1xuZnVuY3Rpb24gZGlzYWJsZUZyYW1lKGZyYW1lLCB0eXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdGZvciAodmFyIGkgPSB5OyBpIDwgeSArIGhlaWdodDsgKytpKSB7XG5cdFx0Zm9yICh2YXIgaiA9IHg7IGogPCB4ICsgd2lkdGg7ICsraikge1xuXHRcdFx0aWYgKHR5cGUgIT09IGZyYW1lW2ldW2pdKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZnJhbWVbaV1bal0gPSAwO1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gc2VhcmNoU2hhcGVJbkZyYW1lKGZyYW1lLCB0eXBlLCB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0dmFyIHNpemUgPSB7XG5cdFx0bGVmdDogbGVmdCxcblx0XHR0b3A6IHRvcCxcblx0XHR0eXBlOiB0eXBlLFxuXHRcdHdpZHRoOiAxLFxuXHRcdGhlaWdodDogMVxuXHR9O1xuXG5cdGZvciAodmFyIGkgPSBsZWZ0OyBpIDwgd2lkdGg7ICsraSkge1xuXHRcdGlmIChmcmFtZVt0b3BdW2ldID09PSB0eXBlKSB7XG5cdFx0XHRzaXplLndpZHRoID0gaSAtIGxlZnQgKyAxO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHR9XG5cdGZvciAodmFyIF9pID0gdG9wOyBfaSA8IGhlaWdodDsgKytfaSkge1xuXHRcdGlmIChmcmFtZVtfaV1bbGVmdF0gPT09IHR5cGUpIHtcblx0XHRcdHNpemUuaGVpZ2h0ID0gX2kgLSB0b3AgKyAxO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHR9XG5cdC8vIEFmdGVyIGZpbmRpbmcgdGhlIHNoYXBlLCBpdCB3aWxsIG5vdCBmaW5kIGFnYWluLlxuXHRkaXNhYmxlRnJhbWUoZnJhbWUsIHR5cGUsIGxlZnQsIHRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRyZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGdldFNoYXBlcyhmcmFtZSkge1xuXHR2YXIgaGVpZ2h0ID0gZnJhbWUubGVuZ3RoO1xuXHR2YXIgd2lkdGggPSBoZWlnaHQgPyBmcmFtZVswXS5sZW5ndGggOiAwO1xuXHR2YXIgc2hhcGVzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xuXHRcdFx0dmFyIHR5cGUgPSBmcmFtZVtpXVtqXTtcblxuXHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2VwYXJhdGUgc2hhcGVzIHdpdGggb3RoZXIgbnVtYmVycy5cblx0XHRcdHNoYXBlcy5wdXNoKHNlYXJjaFNoYXBlSW5GcmFtZShmcmFtZSwgdHlwZSwgaSwgaiwgd2lkdGgsIGhlaWdodCkpO1xuXHRcdH1cblx0fVxuXHRzaGFwZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdHJldHVybiBhLnR5cGUgPCBiLnR5cGUgPyAtMSA6IDE7XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodFxuXHR9O1xufVxuLyoqXG4gKiBAY2xhc3NkZXNjIEZyYW1lTGF5b3V0IGlzIGEgbGF5b3V0IHRoYXQgYWxsb3dzIHlvdSB0byBwbGFjZSBjYXJkcyBpbiBhIGdpdmVuIGZyYW1lLiBJdCBpcyBhIGxheW91dCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgbGV2ZWwgaW50ZXJtZWRpYXRlIGJldHdlZW4gdGhlIHBsYWNlbWVudCBvZiB0aGUgaW1hZ2UgZGlyZWN0bHkgYnkgdGhlIGRlc2lnbmVyIGFuZCB0aGUgbGF5b3V0IHVzaW5nIHRoZSBhbGdvcml0aG0uXG4gKiBAa28gRnJhbWVMYXlvdXTsnYAg7KO87Ja07KeEIO2UhOugiOyehOyXkCDrp57strAg7Lm065Oc66W8IOuwsOy5mO2VmOuKlCDroIjsnbTslYTsm4PsnoXri4jri6QuIOuUlOyekOydtOuEiOqwgCDsp4HsoJEg7J2066+47KeA66W8IOuwsOy5mO2VmOuKlCDqsoPqs7wg7JWM6rOg66as7KaY7J2EIOyCrOyaqe2VnCDrsLDsuZjsnZgg7KSR6rCEIOygleuPhCDsiJjspIDsl5Ag7ZW064u57ZWY64qUIOugiOydtOyVhOybg+ydtOuLpC5cbiAqIEBjbGFzcyBlZy5JbmZpbml0ZUdyaWQuRnJhbWVMYXlvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Qgb2YgZWcuSW5maW5pdGVHcmlkLkZyYW1lTGF5b3V0IG1vZHVsZSA8a28+ZWcuSW5maW5pdGVHcmlkLkZyYW1lTGF5b3V0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0PC9rbz5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tYXJnaW49MF0gTWFyZ2luIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGFyb3VuZCBpdGVtcyA8a28+7JWE7J207YWc65OkIOyCrOydtOydmCDqs7XqsIQ8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ob3Jpem9udGFsPWZhbHNlXSBEaXJlY3Rpb24gb2YgdGhlIHNjcm9sbCBtb3ZlbWVudCAoZmFsc2U6IHZlcnRpY2FsLCB0cnVlOiBob3Jpem9udGFsKSA8a28+7Iqk7YGs66GkIOydtOuPmSDrsKntlqUgKGZhbHNlOiDshLjroZzrsKntlqUsIHRydWU6IOqwgOuhnOuwqe2WpSk8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pdGVtU2l6ZT0wXSBUaGUgc2l6ZSBvZiB0aGUgaXRlbXMuIElmIGl0IGlzIDAsIGl0IGlzIGNhbGN1bGF0ZWQgYXMgdGhlIHNpemUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gaXRlbXMuIDxrbz4g7JWE7J207YWc7J2YIOyCrOydtOymiC4g66eM7JW9IOyVhOydtO2FnCDsgqzsnbTspojqsIAgMOydtOuptCwg7JWE7J207YWc65Ok7J2YIOyyq+uyiOynuCDslYTsnbTthZzsnZgg7IKs7J207KaI66GcIOqzhOyCsOydtCDrkJzri6QuIDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZyYW1lPVtdXSBUaGUgc2l6ZSBvZiB0aGUgaXRlbXMuIElmIGl0IGlzIDAsIGl0IGlzIGNhbGN1bGF0ZWQgYXMgdGhlIHNpemUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gaXRlbXMuIDxrbz4g7JWE7J207YWc7J2YIOyCrOydtOymiC4g66eM7JW9IOyVhOydtO2FnCDsgqzsnbTspojqsIAgMOydtOuptCwg7JWE7J207YWc65Ok7J2YIOyyq+uyiOynuCDslYTsnbTthZzsnZgg7IKs7J207KaI66GcIOqzhOyCsOydtCDrkJzri6QuIDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZyYW1lRmlsbD10cnVlXSBNYWtlIHN1cmUgdGhhdCB0aGUgZnJhbWUgY2FuIGJlIGF0dGFjaGVkIGFmdGVyIHRoZSBwcmV2aW91cyBmcmFtZS4gPGtvPiDri6TsnYwg7ZSE66CI7J6E7J20IOyghCDtlITroIjsnoTsl5Ag7J207Ja0IOu2meydvCDsiJgg7J6I64qU7KeAIOyeiOuKlOyngCDtmZXsnbjtlZzri6QuIDwva28+XG4gKiBAZXhhbXBsZVxuYGBgXG48c2NyaXB0PlxudmFyIGlnID0gbmV3IGVnLkluZmluaXRlR3JpZChcIiNncmlkXCIuIHtcblx0aG9yaXpvbnRhbDogdHJ1ZSxcbn0pO1xuXG5pZy5zZXRMYXlvdXQoZWcuSW5maW5pdGVHcmlkLkZyYW1lTGF5b3V0LCB7XG5cdG1hcmdpbjogMTAsXG5cdGl0ZW1TaXplOiAyMDAsXG5cdGZyYW1lOiBbXG5cdFx0WzEsIDEsIDEsIDEsIDFdLFxuXHRcdFswLCAwLCAyLCAyLCAyXSxcblx0XHRbMCwgMCwgMiwgMiwgMl0sXG5cdFx0WzMsIDQsIDUsIDUsIDVdLFxuXHRdLFxufSk7XG5cbi8vIG9yXG5cbnZhciBsYXlvdXQgPSBuZXcgZWcuSW5maW5pdGVHcmlkLkZyYW1lTGF5b3V0KHtcblx0bWFyZ2luOiAxMCxcblx0aXRlbVNpemU6IDIwMCxcblx0aG9yaXpvbnRhbDogdHJ1ZSxcblx0ZnJhbWU6IFtcblx0XHRbMSwgMSwgMSwgMSwgMV0sXG5cdFx0WzAsIDAsIDIsIDIsIDJdLFxuXHRcdFswLCAwLCAyLCAyLCAyXSxcblx0XHRbMywgNCwgNSwgNSwgNV0sXG5cdF0sXG59KTtcblxuPC9zY3JpcHQ+XG5gYGBcbiAqKi9cblxudmFyIEZyYW1lTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBGcmFtZUxheW91dCgpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhbWVMYXlvdXQpO1xuXG5cdFx0dGhpcy5vcHRpb25zID0gKDAsIF91dGlscy5hc3NpZ25PcHRpb25zKSh7XG5cdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRob3Jpem9udGFsOiBmYWxzZSxcblx0XHRcdGl0ZW1TaXplOiAwLFxuXHRcdFx0ZnJhbWU6IFtdLFxuXHRcdFx0ZnJhbWVGaWxsOiB0cnVlXG5cdFx0fSwgb3B0aW9ucyk7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5vcHRpb25zLmZyYW1lLm1hcChmdW5jdGlvbiAocm93KSB7XG5cdFx0XHRyZXR1cm4gcm93LnNsaWNlKCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9pdGVtU2l6ZSA9IHRoaXMub3B0aW9ucy5pdGVtU2l6ZSB8fCAwO1xuXHRcdC8vIGRpdmlkZSBmcmFtZSBpbnRvIHNoYXBlcy5cblx0XHR0aGlzLl9zaGFwZXMgPSBnZXRTaGFwZXMoZnJhbWUpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHRcdHRoaXMuX3N0eWxlID0gKDAsIF91dGlscy5nZXRTdHlsZU5hbWVzKSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCk7XG5cdH1cblxuXHRGcmFtZUxheW91dC5wcm90b3R5cGUuX2dldEl0ZW1TaXplID0gZnVuY3Rpb24gX2dldEl0ZW1TaXplKCkge1xuXHRcdHRoaXMuX2NoZWNrSXRlbVNpemUoKTtcblxuXHRcdHJldHVybiB0aGlzLl9pdGVtU2l6ZTtcblx0fTtcblxuXHRGcmFtZUxheW91dC5wcm90b3R5cGUuX2NoZWNrSXRlbVNpemUgPSBmdW5jdGlvbiBfY2hlY2tJdGVtU2l6ZSgpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLml0ZW1TaXplKSB7XG5cdFx0XHR0aGlzLl9pdGVtU2l6ZSA9IHRoaXMub3B0aW9ucy5pdGVtU2l6ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0dmFyIHNpemUgPSBzdHlsZS5zaXplMjtcblx0XHR2YXIgbWFyZ2luID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcblxuXHRcdC8vIGlmIGl0ZW1TaXplIGlzIG5vdCBpbiBvcHRpb25zLCBjYWN1bGF0ZSBpdGVtU2l6ZSBmcm9tIHNpemUuXG5cdFx0dGhpcy5faXRlbVNpemUgPSAodGhpcy5fc2l6ZSArIG1hcmdpbikgLyB0aGlzLl9zaGFwZXNbc2l6ZV0gLSBtYXJnaW47XG5cdH07XG5cblx0RnJhbWVMYXlvdXQucHJvdG90eXBlLl9sYXlvdXQgPSBmdW5jdGlvbiBfbGF5b3V0KGl0ZW1zKSB7XG5cdFx0dmFyIG91dGxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXHRcdHZhciBpc0FwcGVuZCA9IGFyZ3VtZW50c1syXTtcblxuXHRcdHZhciBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0dmFyIF9vcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdCAgICBtYXJnaW4gPSBfb3B0aW9ucy5tYXJnaW4sXG5cdFx0ICAgIGZyYW1lRmlsbCA9IF9vcHRpb25zLmZyYW1lRmlsbDtcblxuXHRcdHZhciBzaXplMU5hbWUgPSBzdHlsZS5zaXplMTtcblx0XHR2YXIgc2l6ZTJOYW1lID0gc3R5bGUuc2l6ZTI7XG5cdFx0dmFyIHBvczFOYW1lID0gc3R5bGUucG9zMTtcblx0XHR2YXIgcG9zMk5hbWUgPSBzdHlsZS5wb3MyO1xuXHRcdHZhciBpdGVtU2l6ZSA9IHRoaXMuX2dldEl0ZW1TaXplKCk7XG5cdFx0dmFyIGlzSXRlbU9iamVjdCA9ICh0eXBlb2YgaXRlbVNpemUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihpdGVtU2l6ZSkpID09PSBcIm9iamVjdFwiO1xuXHRcdHZhciBpdGVtU2l6ZTIgPSBpc0l0ZW1PYmplY3QgPyBpdGVtU2l6ZVtzaXplMk5hbWVdIDogaXRlbVNpemU7XG5cdFx0dmFyIGl0ZW1TaXplMSA9IGlzSXRlbU9iamVjdCA/IGl0ZW1TaXplW3NpemUxTmFtZV0gOiBpdGVtU2l6ZTtcblx0XHR2YXIgc2hhcGVzU2l6ZSA9IHRoaXMuX3NoYXBlc1tzaXplMk5hbWVdO1xuXHRcdHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXMuc2hhcGVzO1xuXHRcdHZhciBzaGFwZXNMZW5ndGggPSBzaGFwZXMubGVuZ3RoO1xuXHRcdHZhciBzdGFydE91dGxpbmUgPSAoMCwgX3V0aWxzLmZpbGwpKG5ldyBBcnJheShzaGFwZXNTaXplKSwgX2NvbnN0cy5EVU1NWV9QT1NJVElPTik7XG5cdFx0dmFyIGVuZE91dGxpbmUgPSAoMCwgX3V0aWxzLmZpbGwpKG5ldyBBcnJheShzaGFwZXNTaXplKSwgX2NvbnN0cy5EVU1NWV9QT1NJVElPTik7XG5cdFx0dmFyIGRpc3QgPSAwO1xuXHRcdHZhciBlbmQgPSAwO1xuXHRcdHZhciBzdGFydEluZGV4ID0gLTE7XG5cdFx0dmFyIGVuZEluZGV4ID0gLTE7XG5cdFx0dmFyIG1pblBvcyA9IC0xO1xuXHRcdHZhciBtYXhQb3MgPSAtMTtcblxuXHRcdGlmICghc2hhcGVzTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4geyBzdGFydDogb3V0bGluZSwgZW5kOiBvdXRsaW5lLCBzdGFydEluZGV4OiBzdGFydEluZGV4LCBlbmRJbmRleDogZW5kSW5kZXggfTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gc2hhcGVzTGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNoYXBlc0xlbmd0aCAmJiBpICsgaiA8IGxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBfaXRlbSRyZWN0O1xuXG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaSArIGpdO1xuXHRcdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbal07XG5cdFx0XHRcdHZhciBzaGFwZVBvczEgPSBzaGFwZVtwb3MxTmFtZV07XG5cdFx0XHRcdHZhciBzaGFwZVBvczIgPSBzaGFwZVtwb3MyTmFtZV07XG5cdFx0XHRcdHZhciBzaGFwZVNpemUxID0gc2hhcGVbc2l6ZTFOYW1lXTtcblx0XHRcdFx0dmFyIHNoYXBlU2l6ZTIgPSBzaGFwZVtzaXplMk5hbWVdO1xuXHRcdFx0XHR2YXIgcG9zMSA9IGVuZCAtIGRpc3QgKyBzaGFwZVBvczEgKiAoaXRlbVNpemUxICsgbWFyZ2luKTtcblx0XHRcdFx0dmFyIHBvczIgPSBzaGFwZVBvczIgKiAoaXRlbVNpemUyICsgbWFyZ2luKTtcblx0XHRcdFx0dmFyIHNpemUxID0gc2hhcGVTaXplMSAqIChpdGVtU2l6ZTEgKyBtYXJnaW4pIC0gbWFyZ2luO1xuXHRcdFx0XHR2YXIgc2l6ZTIgPSBzaGFwZVNpemUyICogKGl0ZW1TaXplMiArIG1hcmdpbikgLSBtYXJnaW47XG5cblx0XHRcdFx0Zm9yICh2YXIgayA9IHNoYXBlUG9zMjsgayA8IHNoYXBlUG9zMiArIHNoYXBlU2l6ZTIgJiYgayA8IHNoYXBlc1NpemU7ICsraykge1xuXHRcdFx0XHRcdGlmIChzdGFydE91dGxpbmVba10gPT09IF9jb25zdHMuRFVNTVlfUE9TSVRJT04pIHtcblx0XHRcdFx0XHRcdHN0YXJ0T3V0bGluZVtrXSA9IHBvczE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzdGFydEluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0bWluUG9zID0gcG9zMTtcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBpICsgajtcblx0XHRcdFx0XHRcdG1heFBvcyA9IHBvczEgKyBzaXplMSArIG1hcmdpbjtcblx0XHRcdFx0XHRcdGVuZEluZGV4ID0gaSArIGo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaW5Qb3MgPiBwb3MxKSB7XG5cdFx0XHRcdFx0XHRtaW5Qb3MgPSBwb3MxO1xuXHRcdFx0XHRcdFx0c3RhcnRJbmRleCA9IGkgKyBqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF4UG9zIDwgcG9zMSArIHNpemUxICsgbWFyZ2luKSB7XG5cdFx0XHRcdFx0XHRtYXhQb3MgPSBwb3MxICsgc2l6ZTEgKyBtYXJnaW47XG5cdFx0XHRcdFx0XHRlbmRJbmRleCA9IGkgKyBqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFydE91dGxpbmVba10gPSBNYXRoLm1pbihzdGFydE91dGxpbmVba10sIHBvczEpO1xuXHRcdFx0XHRcdGVuZE91dGxpbmVba10gPSBNYXRoLm1heChlbmRPdXRsaW5lW2tdLCBwb3MxICsgc2l6ZTEgKyBtYXJnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGl0ZW0ucmVjdCA9IChfaXRlbSRyZWN0ID0ge30sIF9pdGVtJHJlY3RbcG9zMU5hbWVdID0gcG9zMSwgX2l0ZW0kcmVjdFtwb3MyTmFtZV0gPSBwb3MyLCBfaXRlbSRyZWN0W3NpemUxTmFtZV0gPSBzaXplMSwgX2l0ZW0kcmVjdFtzaXplMk5hbWVdID0gc2l6ZTIsIF9pdGVtJHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0ZW5kID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgZW5kT3V0bGluZSk7XG5cdFx0XHQvLyBjaGVjayBkaXN0IG9uY2Vcblx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCAmIGZpbGwgZW1wdHkgYmxvY2tcblx0XHRcdGlmICghZnJhbWVGaWxsKSB7XG5cdFx0XHRcdGRpc3QgPSAwO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGRpc3QgPSBlbmQ7XG5cblx0XHRcdGZvciAodmFyIF9qID0gMDsgX2ogPCBzaGFwZXNTaXplOyArK19qKSB7XG5cdFx0XHRcdGlmIChzdGFydE91dGxpbmVbX2pdID09PSBfY29uc3RzLkRVTU1ZX1BPU0lUSU9OKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdGhlIGRpc3QgYmV0d2VlbiBmcmFtZSdzIGVuZCBvdXRsaW5lIGFuZCBuZXh0IGZyYW1lJ3Mgc3RhcnQgb3V0bGluZVxuXHRcdFx0XHQvLyBleHBlY3QgdGhhdCBuZXh0IGZyYW1lJ3Mgc3RhcnQgb3V0bGluZSBpcyBzdGFydE91dGxpbmVbal0gKyBlbmRcblx0XHRcdFx0ZGlzdCA9IE1hdGgubWluKHN0YXJ0T3V0bGluZVtfal0gKyBlbmQgLSBlbmRPdXRsaW5lW19qXSwgZGlzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNoYXBlc1NpemU7ICsrX2kyKSB7XG5cdFx0XHRpZiAoc3RhcnRPdXRsaW5lW19pMl0gIT09IF9jb25zdHMuRFVNTVlfUE9TSVRJT04pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRzdGFydE91dGxpbmVbX2kyXSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHN0YXJ0T3V0bGluZSk7XG5cdFx0XHRlbmRPdXRsaW5lW19pMl0gPSBzdGFydE91dGxpbmVbX2kyXTtcblx0XHR9XG5cdFx0Ly8gVGhlIHRhcmdldCBvdXRsaW5lIGlzIHN0YXJ0IG91dGxpbmUgd2hlbiB0eXBlIGlzIEFQUEVORElOR1xuXHRcdHZhciB0YXJnZXRPdXRsaW5lID0gaXNBcHBlbmQgPyBzdGFydE91dGxpbmUgOiBlbmRPdXRsaW5lO1xuXHRcdHZhciBwcmV2T3V0bGluZUVuZCA9IG91dGxpbmUubGVuZ3RoID09PSAwID8gMCA6IE1hdGhbaXNBcHBlbmQgPyBcIm1heFwiIDogXCJtaW5cIl0uYXBwbHkoTWF0aCwgb3V0bGluZSk7XG5cdFx0dmFyIHByZXZPdXRsaW5lRGlzdCA9IGlzQXBwZW5kID8gMCA6IGVuZDtcblxuXHRcdGlmIChmcmFtZUZpbGwgJiYgb3V0bGluZS5sZW5ndGggPT09IHNoYXBlc1NpemUpIHtcblx0XHRcdHByZXZPdXRsaW5lRGlzdCA9IC1fY29uc3RzLkRVTU1ZX1BPU0lUSU9OO1xuXHRcdFx0Zm9yICh2YXIgX2kzID0gMDsgX2kzIDwgc2hhcGVzU2l6ZTsgKytfaTMpIHtcblx0XHRcdFx0aWYgKHN0YXJ0T3V0bGluZVtfaTNdID09PSBlbmRPdXRsaW5lW19pM10pIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiBhcHBlbmRpbmcgdHlwZSBpcyBQUkVQRU5ELCBzdWJ0cmFjdCBkaXN0IGZyb20gYXBwZW5kaW5nIGdyb3VwJ3MgaGVpZ2h0LlxuXG5cdFx0XHRcdHByZXZPdXRsaW5lRGlzdCA9IE1hdGgubWluKHRhcmdldE91dGxpbmVbX2kzXSArIHByZXZPdXRsaW5lRW5kIC0gb3V0bGluZVtfaTNdLCBwcmV2T3V0bGluZURpc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBzaGFwZXNTaXplOyArK19pNCkge1xuXHRcdFx0c3RhcnRPdXRsaW5lW19pNF0gKz0gcHJldk91dGxpbmVFbmQgLSBwcmV2T3V0bGluZURpc3Q7XG5cdFx0XHRlbmRPdXRsaW5lW19pNF0gKz0gcHJldk91dGxpbmVFbmQgLSBwcmV2T3V0bGluZURpc3Q7XG5cdFx0fVxuXHRcdGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGl0ZW0ucmVjdFtwb3MxTmFtZV0gKz0gcHJldk91dGxpbmVFbmQgLSBwcmV2T3V0bGluZURpc3Q7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBzdGFydE91dGxpbmUsXG5cdFx0XHRlbmQ6IGVuZE91dGxpbmUsXG5cdFx0XHRzdGFydEluZGV4OiBzdGFydEluZGV4LFxuXHRcdFx0ZW5kSW5kZXg6IGVuZEluZGV4XG5cdFx0fTtcblx0fTtcblxuXHRGcmFtZUxheW91dC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uIF9pbnNlcnQoaXRlbXMsIG91dGxpbmUsIHR5cGUpIHtcblx0XHQvLyB0aGlzIG9ubHkgbmVlZHMgdGhlIHNpemUgb2YgdGhlIGl0ZW0uXG5cdFx0dmFyIGNsb25lID0gKDAsIF91dGlscy5jbG9uZUl0ZW1zKShpdGVtcyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aXRlbXM6IGNsb25lLFxuXHRcdFx0b3V0bGluZXM6IHRoaXMuX2xheW91dChjbG9uZSwgb3V0bGluZSwgdHlwZSlcblx0XHR9O1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIG9mIGdyb3VwcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g6re466O565Ok7J2YIOyVhOydtO2FnOuTpOydhCDslYTsm4Prnbzsnbgg7JWE656Y7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5GcmFtZUxheW91dCNsYXlvdXRcbiAgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgQXJyYXkgb2YgZ3JvdXBzIHRvIGJlIGxheW91dGVkIDxrbz7roIjsnbTslYTsm4PtlaAg6re466O565Ok7J2YIOuwsOyXtDwva28+XG4gICogQHBhcmFtIHtBcnJheX0gb3V0bGluZSBBcnJheSBvZiBvdXRsaW5lIHBvaW50cyB0byBiZSByZWZlcmVuY2UgcG9pbnRzIDxrbz7quLDspIDsoJDsnbQg65CY64qUIOyVhOybg+udvOyduCDsoJDrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5JbmZpbml0ZUdyaWQuRnJhbWVMYXlvdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZjxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQubGF5b3V0KGdyb3VwcywgWzEwMCwgMjAwLCAzMDAsIDQwMF0pO1xuICAqL1xuXG5cblx0RnJhbWVMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIGxheW91dChncm91cHMsIG91dGxpbmVzKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0dmFyIHBvaW50ID0gb3V0bGluZXM7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cblx0XHRcdHBvaW50ID0gdGhpcy5fbGF5b3V0KGdyb3VwLml0ZW1zLCBwb2ludCwgX2NvbnN0cy5BUFBFTkQpO1xuXHRcdFx0Z3JvdXAub3V0bGluZXMgPSBwb2ludDtcblx0XHRcdHBvaW50ID0gcG9pbnQuZW5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG4gICogU2V0IHRoZSB2aWV3cG9ydCBzaXplIG9mIHRoZSBsYXlvdXQuXG4gICogQGtvIOugiOydtOyVhOybg+ydmCDqsIDsi5wg7IKs7J207KaI66W8IOyEpOygle2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5GcmFtZUxheW91dCNzZXRTaXplXG4gICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIHZpZXdwb3J0IHNpemUgb2YgY29udGFpbmVyIGFyZWEgd2hlcmUgaXRlbXMgYXJlIGFkZGVkIHRvIGEgbGF5b3V0IDxrbz7roIjsnbTslYTsm4Psl5Ag7JWE7J207YWc7J2EIOy2lOqwgO2VmOuKlCDsu6jthYzsnbTrhIgg7JiB7Jet7J2YIOqwgOyLnCDsgqzsnbTspog8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZC5GcmFtZUxheW91dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAZXhhbXBsZVxuICAqIGxheW91dC5zZXRTaXplKDgwMCk7XG4gICovXG5cblxuXHRGcmFtZUxheW91dC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUoc2l6ZSkge1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIGF0IHRoZSBib3R0b20gb2YgYSBvdXRsaW5lLlxuICAqIEBrbyDslYTsnbTthZzrk6TsnYQg7JWE7JuD65287J24IOyVhOuemOyXkCDstpTqsIDtlZzri6QuXG4gICogQG1ldGhvZCBlZy5JbmZpbml0ZUdyaWQuRnJhbWVMYXlvdXQjYXBwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMF0pO1xuICAqL1xuXG5cblx0RnJhbWVMYXlvdXQucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChpdGVtcywgb3V0bGluZSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnQoaXRlbXMsIG91dGxpbmUsIF9jb25zdHMuQVBQRU5EKTtcblx0fTtcblx0LyoqXG4gICogQWRkcyBpdGVtcyBhdCB0aGUgdG9wIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g7JWE7J207YWc7J2EIOyVhOybg+udvOyduCDsnITsl5Ag7LaU6rCA7ZWc64ukLlxuICAqIEBtZXRob2QgZWcuSW5maW5pdGVHcmlkLkZyYW1lTGF5b3V0I3ByZXBlbmRcbiAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBBcnJheSBvZiBpdGVtcyB0byBiZSBsYXlvdXRlZCA8a28+66CI7J207JWE7JuD7ZWgIOyVhOydtO2FnOuTpOydmCDrsLDsl7Q8L2tvPlxuICAqIEBwYXJhbSB7QXJyYXl9IFtvdXRsaW5lPVtdXSBBcnJheSBvZiBvdXRsaW5lIHBvaW50cyB0byBiZSByZWZlcmVuY2UgcG9pbnRzIDxrbz7quLDspIDsoJDsnbQg65CY64qUIOyVhOybg+udvOyduCDsoJDrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcmV0dXJuIHtPYmplY3R9IExheW91dGVkIGl0ZW1zIGFuZCBvdXRsaW5lIG9mIHN0YXJ0IGFuZCBlbmQgPGtvPiDroIjsnbTslYTsm4PsnbQg65CcIOyVhOydtO2FnOqzvCDsi5zsnpHqs7wg64Gd7J2YIOyVhOybg+udvOyduOydtCDri7TquLQg7KCV67O0PC9rbz5cbiAgKiBAZXhhbXBsZVxuICAqIGxheW91dC5wcmVwZW5kKGl0ZW1zLCBbMTAwXSk7XG4gICovXG5cblxuXHRGcmFtZUxheW91dC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoaXRlbXMsIG91dGxpbmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KGl0ZW1zLCBvdXRsaW5lLCBfY29uc3RzLlBSRVBFTkQpO1xuXHR9O1xuXG5cdHJldHVybiBGcmFtZUxheW91dDtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBGcmFtZUxheW91dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuSXRlbU1hbmFnZXIgPSBleHBvcnRzLldhdGNoZXIgPSBleHBvcnRzLkRPTVJlbmRlcmVyID0gZXhwb3J0cy5BdXRvU2l6ZXIgPSBleHBvcnRzLkltYWdlTG9hZGVkID0gZXhwb3J0cy5JbmZpbml0ZSA9IGV4cG9ydHMuSnVzdGlmaWVkTGF5b3V0ID0gZXhwb3J0cy5QYWNraW5nTGF5b3V0ID0gZXhwb3J0cy5TcXVhcmVMYXlvdXQgPSBleHBvcnRzLkZyYW1lTGF5b3V0ID0gZXhwb3J0cy5HcmlkTGF5b3V0ID0gdW5kZWZpbmVkO1xuXG52YXIgX0luZmluaXRlR3JpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgX0luZmluaXRlR3JpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmZpbml0ZUdyaWQpO1xuXG52YXIgX0dyaWRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9HcmlkTGF5b3V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0dyaWRMYXlvdXQpO1xuXG52YXIgX0ZyYW1lTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9GcmFtZUxheW91dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9GcmFtZUxheW91dCk7XG5cbnZhciBfU3F1YXJlTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfU3F1YXJlTGF5b3V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NxdWFyZUxheW91dCk7XG5cbnZhciBfUGFja2luZ0xheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX1BhY2tpbmdMYXlvdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFja2luZ0xheW91dCk7XG5cbnZhciBfSnVzdGlmaWVkTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfSnVzdGlmaWVkTGF5b3V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0p1c3RpZmllZExheW91dCk7XG5cbnZhciBfSW1hZ2VMb2FkZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX0ltYWdlTG9hZGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ltYWdlTG9hZGVkKTtcblxudmFyIF9BdXRvU2l6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX0F1dG9TaXplcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdXRvU2l6ZXIpO1xuXG52YXIgX0RPTVJlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9ET01SZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ET01SZW5kZXJlcik7XG5cbnZhciBfV2F0Y2hlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfV2F0Y2hlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XYXRjaGVyKTtcblxudmFyIF9JdGVtTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfSXRlbU1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSXRlbU1hbmFnZXIpO1xuXG52YXIgX0luZmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9JbmZpbml0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmZpbml0ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbiAqIGVnanMtaW5maW5pdGVncmlkIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuZXhwb3J0cy5HcmlkTGF5b3V0ID0gX0dyaWRMYXlvdXQyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuRnJhbWVMYXlvdXQgPSBfRnJhbWVMYXlvdXQyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuU3F1YXJlTGF5b3V0ID0gX1NxdWFyZUxheW91dDJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5QYWNraW5nTGF5b3V0ID0gX1BhY2tpbmdMYXlvdXQyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuSnVzdGlmaWVkTGF5b3V0ID0gX0p1c3RpZmllZExheW91dDJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5JbmZpbml0ZSA9IF9JbmZpbml0ZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5JbWFnZUxvYWRlZCA9IF9JbWFnZUxvYWRlZDJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5BdXRvU2l6ZXIgPSBfQXV0b1NpemVyMltcImRlZmF1bHRcIl07XG5leHBvcnRzLkRPTVJlbmRlcmVyID0gX0RPTVJlbmRlcmVyMltcImRlZmF1bHRcIl07XG5leHBvcnRzLldhdGNoZXIgPSBfV2F0Y2hlcjJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5JdGVtTWFuYWdlciA9IF9JdGVtTWFuYWdlcjJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfSW5maW5pdGVHcmlkMltcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBOQVZFUiBDb3JwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBfY29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBfY29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvbmVudCk7XG5cbnZhciBfSXRlbU1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX0l0ZW1NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0l0ZW1NYW5hZ2VyKTtcblxudmFyIF9ET01SZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfRE9NUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRE9NUmVuZGVyZXIpO1xuXG52YXIgX0ltYWdlTG9hZGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9JbWFnZUxvYWRlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbWFnZUxvYWRlZCk7XG5cbnZhciBfV2F0Y2hlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfV2F0Y2hlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9XYXRjaGVyKTtcblxudmFyIF9BdXRvU2l6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX0F1dG9TaXplcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BdXRvU2l6ZXIpO1xuXG52YXIgX2NvbnN0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfSW5maW5pdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX0luZmluaXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZmluaXRlKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIElFOFxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDMyMTY2NTkvYmFiZWwtaWU4LWluaGVyaXQtaXNzdWUtd2l0aC1vYmplY3QtY3JlYXRlXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0T2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvLCBwcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKCh0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG8pKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Q6IFwiICsgbyk7XG5cdFx0fSBlbHNlIGlmIChvID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGJyb3dzZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuY3JlYXRlIGlzIGEgc2hpbSBhbmQgZG9lc24ndCBzdXBwb3J0ICdudWxsJyBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXCIpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBGKCkge31cblx0XHRGLnByb3RvdHlwZSA9IG87XG5cdFx0cmV0dXJuIG5ldyBGKCk7XG5cdH07XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmZ1bmN0aW9uIGhhc1RhcmdldCgpIHtcblx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhcmdldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0XHR0YXJnZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldHMuZXZlcnkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHJldHVybiB+dGFyZ2V0WzBdLmluZGV4T2YodGFyZ2V0WzFdKTtcblx0fSk7XG59XG5cbi8qKlxuICogQSBtb2R1bGUgdXNlZCB0byBhcnJhbmdlIGNhcmQgZWxlbWVudHMgaW5jbHVkaW5nIGNvbnRlbnQgaW5maW5pdGVseSBhY2NvcmRpbmcgdG8gbGF5b3V0IHR5cGUuIFdpdGggdGhpcyBtb2R1bGUsIHlvdSBjYW4gaW1wbGVtZW50IHZhcmlvdXMgbGF5b3V0cyBjb21wb3NlZCBvZiBkaWZmZXJlbnQgY2FyZCBlbGVtZW50cyB3aG9zZSBzaXplcyB2YXJ5LiBJdCBndWFyYW50ZWVzIHBlcmZvcm1hbmNlIGJ5IG1haW50YWluaW5nIHRoZSBudW1iZXIgb2YgRE9NcyB0aGUgbW9kdWxlIGlzIGhhbmRsaW5nIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VcbiAqIEBrbyDsvZjthZDsuKDqsIAg7J6I64qUIOy5tOuTnCDsl5jrpqzrqLztirjrpbwg66CI7J207JWE7JuDIO2DgOyeheyXkCDrlLDrnbwg66y07ZWc7Jy866GcIOuwsOy5mO2VmOuKlCDrqqjrk4guIOuLpOyWke2VnCDtgazquLDsnZgg7Lm065OcIOyXmOumrOuovO2KuOulvCDri6TslpHtlZwg66CI7J207JWE7JuD7Jy866GcIOuwsOy5mO2VoCDsiJgg7J6I64ukLiDsubTrk5wg7JeY66as66i87Yq47J2YIOqwnOyImOqwgCDqs4Tsho0g64qY7Ja064KY64+EIOuqqOuTiOydtCDsspjrpqztlZjripQgRE9N7J2YIOqwnOyImOulvCDsnbzsoJXtlZjqsowg7Jyg7KeA7ZW0IOy1nOyggeydmCDshLHriqXsnYQg67O07J6l7ZWc64ukXG4gKiBAYWxpYXMgZWcuSW5maW5pdGVHcmlkXG4gKiBAZXh0ZW5kcyBlZy5Db21wb25lbnRcbiAqXG4gKiBAZXhhbXBsZVxuYGBgXG48dWwgaWQ9XCJncmlkXCI+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3QxPC9kaXY+XG5cdDwvbGk+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3QyPC9kaXY+XG5cdDwvbGk+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3QzPC9kaXY+XG5cdDwvbGk+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3Q0PC9kaXY+XG5cdDwvbGk+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3Q1PC9kaXY+XG5cdDwvbGk+XG5cdDxsaSBjbGFzcz1cImNhcmRcIj5cblx0XHQ8ZGl2PnRlc3Q2PC9kaXY+XG5cdDwvbGk+XG48L3VsPlxuPHNjcmlwdD5cbnZhciBzb21lID0gbmV3IGVnLkluZmluaXRlR3JpZChcIiNncmlkXCIpLm9uKFwibGF5b3V0Q29tcGxldGVcIiwgZnVuY3Rpb24oZSkge1xuXHQvLyAuLi5cbn0pO1xuPC9zY3JpcHQ+XG5gYGBcbiAqXG4gKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjgrXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4xKyAoZXhjZXB0IDMueClcIn1cbiAqKi9cblxudmFyIEluZmluaXRlR3JpZCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG5cdF9pbmhlcml0cyhJbmZpbml0ZUdyaWQsIF9Db21wb25lbnQpO1xuXG5cdC8qKlxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfGpRdWVyeX0gZWxlbWVudCBBIGJhc2UgZWxlbWVudCBmb3IgYSBtb2R1bGUgPGtvPuuqqOuTiOydhCDsoIHsmqntlaAg6riw7KSAIOyXmOumrOuovO2KuDwva28+XG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuSW5maW5pdGVHcmlkIG1vZHVsZSA8a28+ZWcuSW5maW5pdGVHcmlkIOuqqOuTiOydmCDsmLXshZgg6rCd7LK0PC9rbz5cbiAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaXRlbVNlbGVjdG9yXSBBIHNlbGVjdG9yIHRvIHNlbGVjdCBjYXJkIGVsZW1lbnRzIHRoYXQgbWFrZSB1cCB0aGUgbGF5b3V0PGtvPuugiOydtOyVhOybg+ydhCDqtazshLHtlZjripQg7Lm065OcIOyXmOumrOuovO2KuOulvCDshKDtg53tlaAg7ISg7YOd7J6QKHNlbGVjdG9yKTwva28+XG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VSZWN5Y2xlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIGtlZXAgdGhlIG51bWJlciBvZiBET01zIGlzIG1haW50YWluZWQuIElmIHRoZSB1c2VSZWN5Y2xlIHZhbHVlIGlzICd0cnVlJywga2VlcCB0aGUgbnVtYmVyIG9mIERPTXMgaXMgbWFpbnRhaW5lZC4gSWYgdGhlIHVzZVJlY3ljbGUgdmFsdWUgaXMgJ2ZhbHNlJywgdGhlIG51bWJlciBvZiBET01zIHdpbGwgaW5jcmVhc2UgYXMgY2FyZCBlbGVtZW50cyBhcmUgYWRkZWQuIDxrbz5ET03snZgg7IiY66W8IOycoOyngO2VoOyngCDsl6zrtoDrpbwg64KY7YOA64K464ukLiB1c2VSZWN5Y2xlIOqwkuydtCAndHJ1ZSfsnbTrqbQgRE9NIOqwnOyImOulvCDsnbzsoJXtlZjqsowg7Jyg7KeA7ZWc64ukLiB1c2VSZWN5Y2xlIOqwkuydtCAnZmFsc2UnIOydtOuptCDsubTrk5wg7JeY66as66i87Yq46rCAIOy2lOqwgOuQoOyImOuhnSBET00g6rCc7IiY6rCAIOqzhOyGjSDspp3qsIDtlZzri6QuPC9rbz5cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzT3ZlcmZsb3dTY3JvbGw9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG92ZXJmbG93OnNjcm9sbCBpcyBhcHBsaWVkPGtvPm92ZXJmbG93OnNjcm9sbCDsoIHsmqnsl6zrtoDrpbwg6rKw7KCV7ZWc64ukLjwva28+XG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ob3Jpem9udGFsPWZhbHNlXSBEaXJlY3Rpb24gb2YgdGhlIHNjcm9sbCBtb3ZlbWVudCAodHJ1ZTogaG9yaXpvbnRhbCwgZmFsc2U6IHZlcnRpY2FsKSA8a28+7Iqk7YGs66GkIOydtOuPmSDrsKntlqUgKHRydWUg6rCA66Gc67Cp7ZalLCBmYWxzZSDshLjroZzrsKntlqUpPC9rbz5cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzRXF1YWxTaXplPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBzaXplcyBvZiBhbGwgY2FyZCBlbGVtZW50cyBhcmUgZXF1YWwgdG8gb25lIGFub3RoZXIuIElmIHNpemVzIG9mIGNhcmQgZWxlbWVudHMgdG8gYmUgYXJyYW5nZWQgYXJlIGFsbCBlcXVhbCBhbmQgdGhpcyBvcHRpb24gaXMgc2V0IHRvIFwidHJ1ZVwiLCB0aGUgcGVyZm9ybWFuY2Ugb2YgbGF5b3V0IGFycmFuZ2VtZW50IGNhbiBiZSBpbXByb3ZlZC4gPGtvPuy5tOuTnCDsl5jrpqzrqLztirjsnZgg7YGs6riw6rCAIOuPmeydvO2VnOyngCDsl6zrtoAuIOuwsOy5mOuQoCDsubTrk5wg7JeY66as66i87Yq47J2YIO2BrOq4sOqwgCDrqqjrkZAg64+Z7J287ZWgIOuVjCDsnbQg7Ji17IWY7J2EICd0cnVlJ+uhnCDshKTsoJXtlZjrqbQg66CI7J207JWE7JuDIOuwsOy5mCDshLHriqXsnYQg64aS7J28IOyImCDsnojri6Q8L2tvPlxuICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAwXSBUaGUgdGhyZXNob2xkIHNpemUgb2YgYW4gZXZlbnQgYXJlYSB3aGVyZSBjYXJkIGVsZW1lbnRzIGFyZSBhZGRlZCB0byBhIGxheW91dC48a28+66CI7J207JWE7JuD7JeQIOy5tOuTnCDsl5jrpqzrqLztirjrpbwg7LaU6rCA7ZWY64qUIOydtOuypO2KuOqwgCDrsJzsg53tlZjripQg6riw7KSAIOyYgeyXreydmCDtgazquLAuPC9rbz5cbiAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXR0cmlidXRlUHJlZml4PVwiZGF0YS1cIl0gVGhlIHByZWZpeCB0byB1c2UgZWxlbWVudCdzIGRhdGEgYXR0cmlidXRlLjxrbz7sl5jrpqzrqLztirjsnZgg642w7J207YOAIOyGjeyEseyXkCDsgqzsmqntlaAg7KCR65GQ7IKsLjwva28+XG4gICovXG5cdGZ1bmN0aW9uIEluZmluaXRlR3JpZChlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZmluaXRlR3JpZCk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcykpO1xuXG5cdFx0X2V4dGVuZHMoX3RoaXMub3B0aW9ucyA9IHtcblx0XHRcdGl0ZW1TZWxlY3RvcjogXCIqXCIsXG5cdFx0XHRpc092ZXJmbG93U2Nyb2xsOiBmYWxzZSxcblx0XHRcdHRocmVzaG9sZDogMTAwLFxuXHRcdFx0aXNFcXVhbFNpemU6IGZhbHNlLFxuXHRcdFx0dXNlUmVjeWNsZTogdHJ1ZSxcblx0XHRcdGhvcml6b250YWw6IGZhbHNlLFxuXHRcdFx0YXR0cmlidXRlUHJlZml4OiBcImRhdGEtXCJcblx0XHR9LCBvcHRpb25zKTtcblx0XHRfdGhpcy5vcHRpb25zLnVzZUZpdCA9ICFfY29uc3RzLkRFRkVOU0VfQlJPV1NFUjtcblx0XHRfY29uc3RzLklTX0FORFJPSUQyICYmIChfdGhpcy5vcHRpb25zLmlzT3ZlcmZsb3dTY3JvbGwgPSBmYWxzZSk7XG5cdFx0X3RoaXMuX3Jlc2V0KCk7XG5cdFx0X3RoaXMuX2xvYWRpbmdCYXIgPSB7fTtcblxuXHRcdHZhciBfdGhpcyRvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcblx0XHQgICAgaXNPdmVyZmxvd1Njcm9sbCA9IF90aGlzJG9wdGlvbnMuaXNPdmVyZmxvd1Njcm9sbCxcblx0XHQgICAgaXNFcXVhbFNpemUgPSBfdGhpcyRvcHRpb25zLmlzRXF1YWxTaXplLFxuXHRcdCAgICBob3Jpem9udGFsID0gX3RoaXMkb3B0aW9ucy5ob3Jpem9udGFsLFxuXHRcdCAgICB0aHJlc2hvbGQgPSBfdGhpcyRvcHRpb25zLnRocmVzaG9sZCxcblx0XHQgICAgdXNlUmVjeWNsZSA9IF90aGlzJG9wdGlvbnMudXNlUmVjeWNsZTtcblxuXG5cdFx0X3RoaXMuX2l0ZW1zID0gbmV3IF9JdGVtTWFuYWdlcjJbXCJkZWZhdWx0XCJdKCk7XG5cdFx0X3RoaXMuX3JlbmRlcmVyID0gbmV3IF9ET01SZW5kZXJlcjJbXCJkZWZhdWx0XCJdKGVsZW1lbnQsIHtcblx0XHRcdGlzT3ZlcmZsb3dTY3JvbGw6IGlzT3ZlcmZsb3dTY3JvbGwsXG5cdFx0XHRpc0VxdWFsU2l6ZTogaXNFcXVhbFNpemUsXG5cdFx0XHRob3Jpem9udGFsOiBob3Jpem9udGFsXG5cdFx0fSk7XG5cdFx0X3RoaXMuX3dhdGNoZXIgPSBuZXcgX1dhdGNoZXIyW1wiZGVmYXVsdFwiXShfdGhpcy5fcmVuZGVyZXIudmlldywge1xuXHRcdFx0aXNPdmVyZmxvd1Njcm9sbDogaXNPdmVyZmxvd1Njcm9sbCxcblx0XHRcdGhvcml6b250YWw6IGhvcml6b250YWwsXG5cdFx0XHRjb250YWluZXI6IF90aGlzLl9yZW5kZXJlci5jb250YWluZXIsXG5cdFx0XHRyZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzLl9vblJlc2l6ZSgpO1xuXHRcdFx0fSxcblx0XHRcdGNoZWNrOiBmdW5jdGlvbiBjaGVjayhwYXJhbSkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMuX29uQ2hlY2socGFyYW0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0X3RoaXMuX2luZmluaXRlID0gbmV3IF9JbmZpbml0ZTJbXCJkZWZhdWx0XCJdKF90aGlzLl9pdGVtcywge1xuXHRcdFx0aG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcblx0XHRcdHVzZVJlY3ljbGU6IHVzZVJlY3ljbGUsXG5cdFx0XHR0aHJlc2hvbGQ6IHRocmVzaG9sZCxcblx0XHRcdGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKHBhcmFtKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpcy5fcmVxdWVzdEFwcGVuZChwYXJhbSk7XG5cdFx0XHR9LFxuXHRcdFx0cHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChwYXJhbSkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMuX3JlcXVlc3RQcmVwZW5kKHBhcmFtKTtcblx0XHRcdH0sXG5cdFx0XHRyZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHBhcmFtKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpcy5fcmVjeWNsZShwYXJhbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cdC8qKlxuICAqIEFkZHMgYSBjYXJkIGVsZW1lbnQgYXQgdGhlIGJvdHRvbSBvZiBhIGxheW91dC4gVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgdGhlIGlzUHJvY2Vzc2luZygpIG1ldGhvZCByZXR1cm5zIGZhbHNlLlxuICAqIEBrbyDsubTrk5wg7JeY66as66i87Yq466W8IOugiOydtOyVhOybgyDslYTrnpjsl5Ag7LaU6rCA7ZWc64ukLiBpc1Byb2Nlc3NpbmcoKSDrqZTshJzrk5zsnZgg67CY7ZmY6rCS7J20ICdmYWxzZSfsnbwg65WM66eMIOydtCDrqZTshJzrk5zrpbwg7IKs7Jqp7ZWgIOyImCDsnojri6RcbiAgKiDsnbQg66mU7IaM65Oc64qUIGlzUHJvY2Vzc2luZygp7J2YIOuwmO2ZmOqwkuydtCBmYWxzZeydvCDqsr3smrDsl5Drp4wg7IKs7JqpIOqwgOuKpe2VmOuLpC5cbiAgKiBAcGFyYW0ge0FycmF5fGpRdWVyeX0gZWxlbWVudHMgQXJyYXkgb2YgdGhlIGNhcmQgZWxlbWVudHMgdG8gYmUgYWRkZWQgPGtvPuy2lOqwgO2VoCDsubTrk5wg7JeY66as66i87Yq47J2YIOuwsOyXtDwva28+XG4gICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZ3JvdXBLZXldIFRoZSBncm91cCBrZXkgdG8gYmUgY29uZmlndXJlZCBpbiBhIGNhcmQgZWxlbWVudC4gSXQgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgZGVmYXVsdC5cbiAgKiA8a28+7LaU6rCA7ZWgIOy5tOuTnCDsl5jrpqzrqLztirjsl5Ag7ISk7KCV7ZWgIOq3uOujuSDtgqQuIOyDneuete2VmOuptCDqsJLsnbQg7J6Q64+Z7Jy866GcIOyDneyEseuQnOuLpC48L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAZXhhbXBsZVxuICAqIGluZmluaXRlZ3JpZC5hcHBlbmQoXCImbHQ7ZGl2IGNsYXNzPSdpdGVtJyZndDt0ZXN0MSZsdDsvZGl2Jmd0OyZsdDtkaXYgY2xhc3M9J2l0ZW0nJmd0O3Rlc3QyJmx0Oy9kaXYmZ3Q7XCIpO1xuICAqIGluZmluaXRlZ3JpZC5hcHBlbmQoW1wiJmx0O2RpdiBjbGFzcz0naXRlbScmZ3Q7dGVzdDEmbHQ7L2RpdiZndDtcIiwgXCImbHQ7ZGl2IGNsYXNzPSdpdGVtJyZndDt0ZXN0MiZsdDsvZGl2Jmd0O1wiXSk7XG4gICogaW5maW5pdGVncmlkLmFwcGVuZChbSFRNTEVsZW1lbnQxLCBIVE1MRWxlbWVudDJdKTtcbiAgKiBpbmZpbml0ZWdyaWQuYXBwZW5kKGpRdWVyeShbXCImbHQ7ZGl2IGNsYXNzPSdpdGVtJyZndDt0ZXN0MSZsdDsvZGl2Jmd0O1wiLCBcIiZsdDtkaXYgY2xhc3M9J2l0ZW0nJmd0O3Rlc3QyJmx0Oy9kaXYmZ3Q7XCJdKSk7XG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChlbGVtZW50cywgZ3JvdXBLZXkpIHtcblx0XHR0aGlzLl9sYXlvdXQgJiYgdGhpcy5faW5zZXJ0KGVsZW1lbnRzLCBfY29uc3RzLkFQUEVORCwgZ3JvdXBLZXkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGEgY2FyZCBlbGVtZW50IGF0IHRoZSB0b3Agb2YgYSBsYXlvdXQuIFRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHRoZSBpc1Byb2Nlc3NpbmcoKSBtZXRob2QgcmV0dXJucyBmYWxzZS5cbiAgKiBAa28g7Lm065OcIOyXmOumrOuovO2KuOulvCDroIjsnbTslYTsm4PsnZgg7JyE7JeQIOy2lOqwgO2VnOuLpC4gaXNQcm9jZXNzaW5nKCkg66mU7ISc65Oc7J2YIOuwmO2ZmOqwkuydtCAnZmFsc2Un7J28IOuVjOunjCDsnbQg66mU7ISc65Oc66W8IOyCrOyaqe2VoCDsiJgg7J6I64ukXG4gICogQHBhcmFtIHtBcnJheXxqUXVlcnl9IGVsZW1lbnRzIEFycmF5IG9mIHRoZSBjYXJkIGVsZW1lbnRzIHRvIGJlIGFkZGVkIDxrbz7stpTqsIDtlaAg7Lm065OcIOyXmOumrOuovO2KuCDrsLDsl7Q8L2tvPlxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2dyb3VwS2V5XSBUaGUgZ3JvdXAga2V5IHRvIGJlIGNvbmZpZ3VyZWQgaW4gYSBjYXJkIGVsZW1lbnQuIEl0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQuXG4gICogPGtvPuy2lOqwgO2VoCDsubTrk5wg7JeY66as66i87Yq47JeQIOyEpOygle2VoCDqt7jro7kg7YKkLiDsg53rnrXtlZjrqbQg6rCS7J20IOyekOuPmeycvOuhnCDsg53shLHrkJzri6QuPC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5JbmZpbml0ZUdyaWR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZjxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBpbmZpbml0ZWdyaWQucHJlcGVuZChcIiZsdDtkaXYgY2xhc3M9J2l0ZW0nJmd0O3Rlc3QxJmx0Oy9kaXYmZ3Q7Jmx0O2RpdiBjbGFzcz0naXRlbScmZ3Q7dGVzdDImbHQ7L2RpdiZndDtcIik7XG4gICogaW5maW5pdGVncmlkLnByZXBlbmQoW1wiJmx0O2RpdiBjbGFzcz0naXRlbScmZ3Q7dGVzdDEmbHQ7L2RpdiZndDtcIiwgXCImbHQ7ZGl2IGNsYXNzPSdpdGVtJyZndDt0ZXN0MiZsdDsvZGl2Jmd0O1wiXSk7XG4gICogaW5maW5pdGVncmlkLnByZXBlbmQoW0hUTUxFbGVtZW50MSwgSFRNTEVsZW1lbnQyXSk7XG4gICogaW5maW5pdGVncmlkLnByZXBlbmQoalF1ZXJ5KFtcIiZsdDtkaXYgY2xhc3M9J2l0ZW0nJmd0O3Rlc3QxJmx0Oy9kaXYmZ3Q7XCIsIFwiJmx0O2RpdiBjbGFzcz0naXRlbScmZ3Q7dGVzdDImbHQ7L2RpdiZndDtcIl0pKTtcbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoZWxlbWVudHMsIGdyb3VwS2V5KSB7XG5cdFx0dGhpcy5fbGF5b3V0ICYmIHRoaXMuX2luc2VydChlbGVtZW50cywgX2NvbnN0cy5QUkVQRU5ELCBncm91cEtleSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuICAqIFNwZWNpZmllcyB0aGUgTGF5b3V0IGNsYXNzIHRvIHVzZS5cbiAgKiBAa28g7IKs7Jqp7ZWgIExheW91dCDtgbTrnpjsiqTrpbwg7KeA7KCV7ZWc64ukLlxuICAqIEBwYXJhbSB7Q2xhc3N8T2JqZWN0fSBMYXlvdXRLbGFzcyBUaGUgTGF5b3V0IGNsYXNzIHRvIHVzZSBvciBhbiBpbnN0YW5jZSBvZiBhIGxheW91dCBtb3VkbGU8a28+7IKs7Jqp7ZWgIExheW91dCDtgbTrnpjsiqQg65iQ64qUIOugiOydtOyVhOybgyDrqqjrk4jsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIHRvIGFwcGx5IHRvIHRoZSBMYXlvdXQuPGtvPkxheW91dOyXkCDsoIHsmqntlaAg7Ji17IWYPC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5JbmZpbml0ZUdyaWR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZjxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBpbmZpbml0ZWdyaWQuc2V0TGF5b3V0KGVnLkluZmluaXRlR3JpZC5HcmlkTGF5b3V0LCB7XG4gICogIG1hcmdpbjogMTAsXG4gICogIGFsaWduOiBcInN0YXJ0XCJcbiAgKiB9KTtcbiAgICogaW5maW5pdGVncmlkLnNldExheW91dChlZy5JbmZpbml0ZUdyaWQuSnVzdGlmaWVkTGF5b3V0LCB7XG4gICogIG1hcmdpbjogMTAsXG4gICogIG1pblNpemU6IDEwMCxcbiAgKiAgbWF4U2l6ZTogMjAwXG4gICogfSk7XG4gICAqIGluZmluaXRlZ3JpZC5zZXRMYXlvdXQoZWcuSW5maW5pdGVHcmlkLlNxdWFyZUxheW91dCwge1xuICAqICBtYXJnaW46IDEwLFxuICAqICBjb2x1bW46IDJcbiAgKiB9KTtcbiAgKiBpbmZpbml0ZWdyaWQuc2V0TGF5b3V0KGVnLkluZmluaXRlR3JpZC5GcmFtZUxheW91dCwge1xuICAqICBtYXJnaW46IDEwLFxuICAqICBmcmFtZTogW1xuICAqICAgWzEsIDJdLFxuICAgKiAgIFs0LCAzXSxcbiAgKiAgXVxuICAqIH0pO1xuICAqIGluZmluaXRlZ3JpZC5zZXRMYXlvdXQoZWcuSW5maW5pdGVHcmlkLlBhY2tpbmdMYXlvdXQsIHtcbiAgKiAgbWFyZ2luOiAxMCxcbiAgKiAgYXNwZWN0UmF0aW86IDEuNVxuICAqIH0pO1xuICAqIHZhciBsYXlvdXQgPSBuZXcgZWcuSW5maW5pdGVHcmlkLkdyaWRMYXlvdXQoe1xuICAqIFx0bWFyZ2luOiAxMCxcbiAgKlx0YWxpZ246IFwic3RhcnRcIlxuICAqIH0pO1xuICAqIGluZmluaXRlZ3JpZC5zZXRMYXlvdXQobGF5b3V0KTtcbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuc2V0TGF5b3V0ID0gZnVuY3Rpb24gc2V0TGF5b3V0KExheW91dEtsYXNzKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFx0aWYgKHR5cGVvZiBMYXlvdXRLbGFzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0aGlzLl9sYXlvdXQgPSBuZXcgTGF5b3V0S2xhc3MoX2V4dGVuZHMob3B0aW9ucywge1xuXHRcdFx0XHRob3Jpem9udGFsOiB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFxuXHRcdFx0fSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9sYXlvdXQgPSBMYXlvdXRLbGFzcztcblx0XHRcdHRoaXMuX2xheW91dC5vcHRpb25zLmhvcml6b250YWwgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbDtcblx0XHR9XG5cdFx0dGhpcy5fcmVuZGVyZXIucmVzaXplKCk7XG5cdFx0dGhpcy5fc2V0U2l6ZSh0aGlzLl9yZW5kZXJlci5nZXRWaWV3cG9ydFNpemUoKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5fc2V0U2l6ZSA9IGZ1bmN0aW9uIF9zZXRTaXplKHNpemUpIHtcblx0XHR0aGlzLl9pbmZpbml0ZS5zZXRTaXplKHRoaXMuX3JlbmRlcmVyLmdldFZpZXdTaXplKCkpO1xuXHRcdHRoaXMuX2xheW91dC5zZXRTaXplKHNpemUpO1xuXHR9O1xuXHQvKipcbiAgKiBSZXR1cm5zIHRoZSBsYXlvdXRlZCBpdGVtcy5cbiAgKiBAa28g66CI7J207JWE7JuD65CcIOyVhOydtO2FnOuTpOydhCDrsJjtmZjtlZzri6QuXG4gICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQ2FjaGVkIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGhlIGNhY2hlZCBpdGVtcy4gPGtvPuy6kOyLseuQnCDslYTsnbTthZzsnYQg7Y+s7ZWo7ZWg7KeAIOyXrOu2gOulvCDrgpjtg4Drgrjri6QuPC9rbz5cbiAgKiBAcmV0dXJucyB7QXJyYXl9IExpc3Qgb2YgaXRlbXMgPGtvPuyVhOydtO2FnOydmCDrqqnroZ08L2tvPlxuICAqL1xuXG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uIGdldEl0ZW1zKCkge1xuXHRcdHZhciBpbmNsdWRlQ2FjaGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuXHRcdHJldHVybiBpbmNsdWRlQ2FjaGVkID8gdGhpcy5faXRlbXMucGx1Y2soXCJpdGVtc1wiKSA6IHRoaXMuX2luZmluaXRlLmdldFZpc2libGVJdGVtcygpO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX2ZpdEl0ZW1zID0gZnVuY3Rpb24gX2ZpdEl0ZW1zKGJhc2UpIHtcblx0XHR2YXIgbWFyZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG5cdFx0YmFzZSA+IDAgJiYgdGhpcy5fd2F0Y2hlci5zY3JvbGxCeSgtYmFzZSk7XG5cdFx0dGhpcy5faXRlbXMuZml0KGJhc2UsIHRoaXMub3B0aW9ucy5ob3Jpem9udGFsKTtcblx0XHRfRE9NUmVuZGVyZXIyW1wiZGVmYXVsdFwiXS5yZW5kZXJJdGVtcyh0aGlzLmdldEl0ZW1zKCkpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLnNldENvbnRhaW5lclNpemUodGhpcy5fZ2V0RWRnZVZhbHVlKFwiZW5kXCIpIHx8IG1hcmdpbik7XG5cdFx0YmFzZSA8IDAgJiYgdGhpcy5fd2F0Y2hlci5zY3JvbGxCeSgtYmFzZSk7XG5cdH07XG5cdC8vIGNhbGxlZCBieSB2aXNpYmxlXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9maXQgPSBmdW5jdGlvbiBfZml0KCkge1xuXHRcdC8vIGZvciBjYWNoaW5nXG5cdFx0aWYgKCF0aGlzLl9sYXlvdXQpIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHR2YXIgYmFzZSA9IHRoaXMuX2dldEVkZ2VWYWx1ZShcInN0YXJ0XCIpO1xuXHRcdHZhciBtYXJnaW4gPSB0aGlzLl9nZXRMb2FkaW5nU3RhdHVzKCkgPT09IF9jb25zdHMuTE9BRElOR19QUkVQRU5EICYmIHRoaXMuX3N0YXR1cy5sb2FkaW5nU2l6ZSB8fCAwO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXNlUmVjeWNsZSB8fCAhdGhpcy5vcHRpb25zLnVzZUZpdCkge1xuXHRcdFx0aWYgKGJhc2UgPCBtYXJnaW4pIHtcblx0XHRcdFx0dGhpcy5fZml0SXRlbXMoYmFzZSAtIG1hcmdpbiwgbWFyZ2luKTtcblx0XHRcdH1cblx0XHRcdGJhc2UgPSAwO1xuXHRcdH0gZWxzZSBpZiAoYmFzZSAhPT0gMCB8fCBtYXJnaW4pIHtcblx0XHRcdHZhciBpc1Byb2Nlc3NpbmcgPSB0aGlzLl9pc1Byb2Nlc3NpbmcoKTtcblxuXHRcdFx0dGhpcy5fcHJvY2VzcyhfY29uc3RzLlBST0NFU1NJTkcpO1xuXHRcdFx0Ly8gXCJiZWZvcmVcIiBpcyBiYXNlID4gMFxuXHRcdFx0Ly8gXCJhZnRlclwiIGlzIGJhc2UgPCAwXG5cdFx0XHR0aGlzLl9maXRJdGVtcyhiYXNlIC0gbWFyZ2luLCBtYXJnaW4pO1xuXHRcdFx0aWYgKCFpc1Byb2Nlc3NpbmcpIHtcblx0XHRcdFx0dGhpcy5fcHJvY2VzcyhfY29uc3RzLlBST0NFU1NJTkcsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdHRoaXMuX2lzTG9hZGluZygpICYmIHRoaXMuX3JlbmRlckxvYWRpbmcoKTtcblx0XHRyZXR1cm4gYmFzZTtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9nZXRFZGdlVmFsdWUgPSBmdW5jdGlvbiBfZ2V0RWRnZVZhbHVlKGN1cnNvcikge1xuXHRcdHJldHVybiB0aGlzLl9pbmZpbml0ZS5nZXRFZGdlVmFsdWUoY3Vyc29yKTtcblx0fTtcblx0LyoqXG4gICogUmVhcnJhbmdlcyBhIGxheW91dC5cbiAgKiBAa28g66CI7J207JWE7JuD7J2EIOuLpOyLnCDrsLDsuZjtlZzri6QuXG4gICogQHBhcmFtIHtCb29sZWFufSBbaXNSZWxheW91dD10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciBhIGNhcmQgZWxlbWVudCBpcyBiZWluZyByZWxheW91dGVkIDxrbz7subTrk5wg7JeY66as66i87Yq4IOyerOuwsOy5mCDsl6zrtoA8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gbGF5b3V0KCkge1xuXHRcdHZhciBpc1JlbGF5b3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXlvdXQpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblx0XHR2YXIgaXRlbU1hbmFnZXIgPSB0aGlzLl9pdGVtcztcblxuXHRcdC8vIGNoZWNrIGNoaWxkRWxlbWVudFxuXHRcdGlmICghdGhpcy5faXRlbXMuc2l6ZSgpKSB7XG5cdFx0XHR0aGlzLl9pbnNlcnQoKDAsIF91dGlscy50b0FycmF5KShyZW5kZXJlci5jb250YWluZXIuY2hpbGRyZW4pLCB0cnVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR2YXIgZGF0YSA9IHZvaWQgMDtcblx0XHR2YXIgb3V0bGluZSA9IHZvaWQgMDtcblxuXHRcdHZhciBpbmZpbml0ZSA9IHRoaXMuX2luZmluaXRlO1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcblx0XHR2YXIgaXNFcXVhbFNpemUgPSB0aGlzLm9wdGlvbnMuaXNFcXVhbFNpemU7XG5cblx0XHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmIChpc1JlbGF5b3V0KSB7XG5cdFx0XHQvLyByZW1vdmUgY2FjaGVcblx0XHRcdGlmIChpc0VxdWFsU2l6ZSkge1xuXHRcdFx0XHRyZW5kZXJlci51cGRhdGVTaXplKFtpdGVtc1swXV0pO1xuXHRcdFx0XHRkYXRhID0gaXRlbU1hbmFnZXIuZ2V0KCk7XG5cdFx0XHRcdG91dGxpbmUgPSBpdGVtTWFuYWdlci5nZXRPdXRsaW5lKDAsIFwic3RhcnRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhID0gaW5maW5pdGUuZ2V0VmlzaWJsZURhdGEoKTtcblx0XHRcdH1cblx0XHRcdGlmIChyZW5kZXJlci5yZXNpemUoKSkge1xuXHRcdFx0XHR0aGlzLl9zZXRTaXplKHJlbmRlcmVyLmdldFZpZXdwb3J0U2l6ZSgpKTtcblx0XHRcdFx0ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0ZGF0YS5pdGVtcyA9IHJlbmRlcmVyLnVwZGF0ZVNpemUodi5pdGVtcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gaW5maW5pdGUuZ2V0VmlzaWJsZURhdGEoKTtcblx0XHRcdG91dGxpbmUgPSBpbmZpbml0ZS5nZXRFZGdlT3V0bGluZShcInN0YXJ0XCIpO1xuXHRcdH1cblx0XHRpZiAoIWRhdGEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbGF5b3V0LmxheW91dChkYXRhLCBvdXRsaW5lKTtcblxuXHRcdGlmIChpc1JlbGF5b3V0KSB7XG5cdFx0XHRpZiAoaXNFcXVhbFNpemUpIHtcblx0XHRcdFx0dGhpcy5fZml0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc3RhcnRDdXJzb3IgPSBpbmZpbml0ZS5nZXRDdXJzb3IoXCJzdGFydFwiKTtcblx0XHRcdFx0dmFyIGVuZEN1cnNvciA9IGluZmluaXRlLmdldEN1cnNvcihcImVuZFwiKTtcblxuXHRcdFx0XHRpdGVtTWFuYWdlci5fZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwgY3Vyc29yKSB7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0Q3Vyc29yIDw9IGN1cnNvciAmJiBjdXJzb3IgPD0gZW5kQ3Vyc29yKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdyb3VwLm91dGxpbmVzLnN0YXJ0ID0gW107XG5cdFx0XHRcdFx0Z3JvdXAub3V0bGluZXMuZW5kID0gW107XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9vbkxheW91dENvbXBsZXRlKHtcblx0XHRcdGl0ZW1zOiBpdGVtcyxcblx0XHRcdGlzQXBwZW5kOiBfY29uc3RzLkFQUEVORCxcblx0XHRcdGZyb21DYWNoZTogX2NvbnN0cy5DQUNIRSxcblx0XHRcdGlzVHJ1c3RlZDogX2NvbnN0cy5OT19UUlVTVEVELFxuXHRcdFx0dXNlUmVjeWNsZTogZmFsc2UsXG5cdFx0XHRpc0xheW91dDogdHJ1ZVxuXHRcdH0pO1xuXHRcdF9ET01SZW5kZXJlcjJbXCJkZWZhdWx0XCJdLnJlbmRlckl0ZW1zKGl0ZW1zKTtcblx0XHRpc1JlbGF5b3V0ICYmIHRoaXMuX3dhdGNoZXIuc2V0U2Nyb2xsUG9zKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG4gICogUmVtb3ZlcyBhIGl0ZW0gZWxlbWVudCBvbiBhIGdyaWQgbGF5b3V0LlxuICAqIEBrbyDqt7jrpqzrk5wg66CI7J207JWE7JuD7J2YIOy5tOuTnCDsl5jrpqzrqLztirjrpbwg7IKt7KCc7ZWc64ukLlxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGl0ZW0gZWxlbWVudCB0byBiZSByZW1vdmVkIDxrbz7sgq3soJzrkKAg7JWE7J207YWcIOyXmOumrOuovO2KuDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSAgUmVtb3ZlZCBpdGVtIGVsZW1lbnQgPGtvPuyCreygnOuQnCDslYTsnbTthZwg7JeY66as66i87Yq4IOygleuztDwva28+XG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG5cdFx0dmFyIGlzTGF5b3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuX2luZmluaXRlLnJlbW92ZShlbGVtZW50KTtcblxuXHRcdFx0aXRlbXMgJiYgX0RPTVJlbmRlcmVyMltcImRlZmF1bHRcIl0ucmVtb3ZlRWxlbWVudChlbGVtZW50KTtcblx0XHRcdGlzTGF5b3V0ICYmIHRoaXMubGF5b3V0KGZhbHNlKTtcblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdC8qKlxuICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZ3JvdXAga2V5cyB3aGljaCBiZWxvbmdzIHRvIGNhcmQgZWxlbWVudHMgY3VycmVudGx5IGJlaW5nIG1haW50YWluZWQuIFlvdSBjYW4gdXNlIHRoZSBhcHBlbmQoKSBvciBwcmVwZW5kKCkgbWV0aG9kIHRvIGNvbmZpZ3VyZSBncm91cCBrZXlzIHNvIHRoYXQgbXVsdGlwbGUgY2FyZCBlbGVtZW50cyBjYW4gYmUgbWFuYWdlZCBhdCBvbmNlLiBJZiB5b3UgZG8gbm90IHVzZSB0aGVzZSBtZXRob2RzIHRvIGNvbmZpZ3VyZSBncm91cCBrZXlzLCBncm91cGtleSBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgKiBAa28g7ZiE7J6sIOycoOyngO2VmOqzoCDsnojripQg7Lm065OcIOyXmOumrOuovO2KuOydmCDqt7jro7kg7YKkIOuqqeuhneydhCDrsJjtmZjtlZzri6QuIOyXrOufrCDqsJzsnZgg7Lm065OcIOyXmOumrOuovO2KuOulvCDrrLbslrTshJwg6rSA66as7ZWgIOyImCDsnojrj4TroZ0gYXBwZW5kKCkg66mU7ISc65Oc64KYIHByZXBlbmQoKSDrqZTshJzrk5zsl5DshJwg6re466O5IO2CpOulvCDsp4DsoJXtlaAg7IiYIOyeiOuLpC4gYXBwZW5kKCkg66mU7ISc65Oc64KYIHByZXBlbmQoKSDrqZTshJzrk5zsl5DshJwg6re466O5IO2CpOulvCDsp4DsoJXtlZjsp4Ag7JWK7JWY64uk66m0IOyekOuPmeycvOuhnCDqt7jro7ntgqTqsIAg7IOd7ISx65Cc64ukLlxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUNhY2hlZCBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoZSBjYWNoZWQgZ3JvdXBzLiA8a28+7LqQ7Iux65CcIOq3uOujueydhCDtj6ztlajtlaDsp4Ag7Jes67aA66W8IOuCmO2DgOuCuOuLpC48L2tvPlxuICAqIEByZXR1cm4ge0FycmF5fSBMaXN0IG9mIGdyb3VwIGtleXMgPGtvPuq3uOujuSDtgqTsnZgg66qp66GdPC9rbz5cbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuZ2V0R3JvdXBLZXlzID0gZnVuY3Rpb24gZ2V0R3JvdXBLZXlzKGluY2x1ZGVDYWNoZWQpIHtcblx0XHR2YXIgZGF0YSA9IGluY2x1ZGVDYWNoZWQgPyB0aGlzLl9pdGVtcy5nZXQoKSA6IHRoaXMuX2luZmluaXRlLmdldFZpc2libGVEYXRhKCk7XG5cblx0XHRyZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiB2Lmdyb3VwS2V5O1xuXHRcdH0pO1xuXHR9O1xuXHQvKipcbiAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgbW9kdWxlIHN1Y2ggYXMgbG9jYXRpb24gaW5mb3JtYXRpb24uIFlvdSBjYW4gdXNlIHRoZSBzZXRTdGF0dXMoKSBtZXRob2QgdG8gcmVzdG9yZSB0aGUgaW5mb3JtYXRpb24gcmV0dXJuZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhpcyBtZXRob2QuXG4gICogQGtvIOy5tOuTnOydmCDsnITsuZgg7KCV67O0IOuTsSDrqqjrk4jsnZgg7ZiE7J6sIOyDge2DnCDsoJXrs7Trpbwg67CY7ZmY7ZWc64ukLiDsnbQg66mU7ISc65Oc6rCAIOuwmO2ZmO2VnCDsoJXrs7Trpbwg7KCA7J6l7ZW0IOuRkOyXiOuLpOqwgCBzZXRTdGF0dXMoKSDrqZTshJzrk5zroZwg67O17JuQ7ZWgIOyImCDsnojri6RcbiAgKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRlIG9iamVjdCBvZiB0aGUgZWcuSW5maW5pdGVHcmlkIG1vZHVsZTxrbz5lZy5JbmZpbml0ZUdyaWQg66qo65OI7J2YIOyDge2DnCDqsJ3ssrQ8L2tvPlxuICAqL1xuXG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9wdGlvbnM6IF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMpLFxuXHRcdFx0X3N0YXR1czogX2V4dGVuZHMoe30sIHRoaXMuX3N0YXR1cyksXG5cdFx0XHRfaXRlbXM6IHRoaXMuX2l0ZW1zLmdldFN0YXR1cygpLFxuXHRcdFx0X3JlbmRlcmVyOiB0aGlzLl9yZW5kZXJlci5nZXRTdGF0dXMoKSxcblx0XHRcdF93YXRjaGVyOiB0aGlzLl93YXRjaGVyLmdldFN0YXR1cygpLFxuXHRcdFx0X2luZmluaXRlOiB0aGlzLl9pbmZpbml0ZS5nZXRTdGF0dXMoKVxuXHRcdH07XG5cdH07XG5cdC8qKlxuICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBlZy5JbmZpbml0ZUdyaWQgbW9kdWxlIHdpdGggdGhlIGluZm9ybWF0aW9uIHJldHVybmVkIHRocm91Z2ggYSBjYWxsIHRvIHRoZSBnZXRTdGF0dWUoKSBtZXRob2QuXG4gICogQGtvIGdldFN0YXR1ZSgpIOuplOyEnOuTnOqwgCDsoIDsnqXtlZwg7KCV67O066GcIGVnLkluZmluaXRlR3JpZCDrqqjrk4jsnZgg7IOB7YOc66W8IOyEpOygle2VnOuLpC5cbiAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHVzIFN0YXRlIG9iamVjdCBvZiB0aGUgZWcuSW5maW5pdGVHcmlkIG1vZHVsZSA8a28+ZWcuSW5maW5pdGVHcmlkIOuqqOuTiOydmCDsg4Htg5wg6rCd7LK0PC9rbz5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcHBseVNjcm9sbFBvcz10cnVlXSBDaGVja3Mgd2hldGhlciB0byBzY3JvbGw8a28+7Iqk7YGs66Gk7J2YIOychOy5mOulvCDrs7Xsm5DtlaDsp4Ag6rKw7KCV7ZWc64ukLjwva28+XG4gICogQHJldHVybiB7ZWcuSW5maW5pdGVHcmlkfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGY8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqL1xuXG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG5cdFx0dmFyIGFwcGx5U2Nyb2xsUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdFx0aWYgKCFzdGF0dXMpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR2YXIgb3B0aW9ucyA9IHN0YXR1cy5vcHRpb25zLFxuXHRcdCAgICBfc3RhdHVzID0gc3RhdHVzLl9zdGF0dXMsXG5cdFx0ICAgIF9yZW5kZXJlciA9IHN0YXR1cy5fcmVuZGVyZXIsXG5cdFx0ICAgIF9pdGVtcyA9IHN0YXR1cy5faXRlbXMsXG5cdFx0ICAgIF93YXRjaGVyID0gc3RhdHVzLl93YXRjaGVyLFxuXHRcdCAgICBfaW5maW5pdGUgPSBzdGF0dXMuX2luZmluaXRlO1xuXG5cblx0XHRpZiAoIV9zdGF0dXMgfHwgIV9yZW5kZXJlciB8fCAhX2l0ZW1zIHx8ICFfd2F0Y2hlciB8fCAhX2luZmluaXRlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fd2F0Y2hlci5kZXRhY2hFdmVudCgpO1xuXHRcdF9leHRlbmRzKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cdFx0X2V4dGVuZHModGhpcy5fc3RhdHVzLCBfc3RhdHVzKTtcblx0XHR0aGlzLl9pdGVtcy5zZXRTdGF0dXMoX2l0ZW1zKTtcblx0XHR0aGlzLl9yZW5kZXJlci5zZXRTdGF0dXMoX3JlbmRlcmVyKTtcblx0XHR0aGlzLl9pbmZpbml0ZS5zZXRTdGF0dXMoX2luZmluaXRlKTtcblx0XHR0aGlzLl9yZW5kZXJlci5jcmVhdGVBbmRJbnNlcnQodGhpcy5nZXRJdGVtcygpKTtcblx0XHR0aGlzLl93YXRjaGVyLnNldFN0YXR1cyhfd2F0Y2hlciwgYXBwbHlTY3JvbGxQb3MpO1xuXHRcdHRoaXMuX3dhdGNoZXIuYXR0YWNoRXZlbnQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG4gICogQ2xlYXJzIGFkZGVkIGNhcmQgZWxlbWVudHMgYW5kIGRhdGEuXG4gICogQGtvIOy2lOqwgOuQnCDsubTrk5wg7JeY66as66i87Yq47JmAIOuNsOydtO2EsOulvCDrqqjrkZAg7KeA7Jq064ukLlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcblx0XHR0aGlzLl9pdGVtcy5jbGVhcigpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLmNsZWFyKCk7XG5cdFx0dGhpcy5faW5maW5pdGUuY2xlYXIoKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX2FwcGVuZExvYWRpbmdCYXIoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG4gICogU3BlY2lmaWVzIHRoZSBMb2FkaW5nIEJhciB0byB1c2UgZm9yIGFwcGVuZCBvciBwcmVwZW5kIGl0ZW1zLlxuICAqIEBrbyDslYTsnbTthZzsnYQgYXBwZW5kIOuYkOuKlCBwcmVwZW5kIO2VmOq4sCDsnITtlbQg7IKs7Jqp7ZWgIOuhnOuUqSDrsJTrpbwg7KeA7KCV7ZWc64ukLlxuICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW3VzZXJMb2FkaW5nQmFyPXt9XSBUaGUgbG9hZGluZyBiYXIgSFRNTCBtYXJrdXAgb3IgZWxlbWVudCBvciBlbGVtZW50IHNlbGVjdG9yIDxrbz4g66Gc65SpIOuwlCBIVE1MIOuYkOuKlCBlbGVtZW50IOuYkOuKlCBzZWxlY3RvciA8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuc2V0TG9hZGluZ0JhciA9IGZ1bmN0aW9uIHNldExvYWRpbmdCYXIoKSB7XG5cdFx0dmFyIHVzZXJMb2FkaW5nQmFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXHRcdHZhciBsb2FkaW5nQmFyT2JqID0gKHR5cGVvZiB1c2VyTG9hZGluZ0JhciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHVzZXJMb2FkaW5nQmFyKSkgPT09IFwib2JqZWN0XCIgPyB1c2VyTG9hZGluZ0JhciA6IHtcblx0XHRcdFwiYXBwZW5kXCI6IHVzZXJMb2FkaW5nQmFyLFxuXHRcdFx0XCJwcmVwZW5kXCI6IHVzZXJMb2FkaW5nQmFyXG5cdFx0fTtcblxuXHRcdHRoaXMuX3N0YXR1cy5sb2FkaW5nU2l6ZSA9IDA7XG5cdFx0dGhpcy5fc3RhdHVzLmxvYWRpbmdTdHlsZSA9IHt9O1xuXHRcdHZhciBsb2FkaW5nQmFyID0gdGhpcy5fbG9hZGluZ0JhcjtcblxuXHRcdGZvciAodmFyIHR5cGUgaW4gbG9hZGluZ0Jhck9iaikge1xuXHRcdFx0bG9hZGluZ0Jhclt0eXBlXSA9ICgwLCBfdXRpbHMuJCkobG9hZGluZ0Jhck9ialt0eXBlXSk7XG5cdFx0XHRsb2FkaW5nQmFyW3R5cGVdLmNsYXNzTmFtZSArPSBcIiBcIiArIF9jb25zdHMuSUdOT1JFX0NMQVNTTkFNRTtcblx0XHR9XG5cdFx0dGhpcy5fYXBwZW5kTG9hZGluZ0JhcigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX2FwcGVuZExvYWRpbmdCYXIgPSBmdW5jdGlvbiBfYXBwZW5kTG9hZGluZ0JhcigpIHtcblx0XHR2YXIgbG9hZGluZ0JhciA9IHRoaXMuX2xvYWRpbmdCYXI7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX3JlbmRlcmVyLmNvbnRhaW5lcjtcblxuXHRcdGZvciAodmFyIHR5cGUgaW4gbG9hZGluZ0Jhcikge1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxvYWRpbmdCYXJbdHlwZV0pO1xuXHRcdH1cblx0fTtcblx0LyoqXG4gICogQ2hlY2tzIHdoZXRoZXIgYSBjYXJkIGVsZW1lbnQgb3IgZGF0YSBpcyBiZWluZyBhZGRlZC5cbiAgKiBAa28g7Lm065OcIOyXmOumrOuovO2KuCDstpTqsIAg65iQ64qUIOuNsOydtO2EsCDroZzrlKnsnbQg7KeE7ZaJIOykkeyduOyngCDtmZXsnbjtlZzri6RcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciBhIGNhcmQgZWxlbWVudCBvciBkYXRhIGlzIGJlaW5nIGFkZGVkIDxrbz7subTrk5wg7JeY66as66i87Yq4IOy2lOqwgCDrmJDripQg642w7J207YSwIOuhnOuUqSDsp4Ttlokg7KSRIOyXrOu2gDwva28+XG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLmlzUHJvY2Vzc2luZyA9IGZ1bmN0aW9uIGlzUHJvY2Vzc2luZygpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNQcm9jZXNzaW5nKCkgfHwgdGhpcy5faXNMb2FkaW5nKCk7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5faXNQcm9jZXNzaW5nID0gZnVuY3Rpb24gX2lzUHJvY2Vzc2luZygpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3N0YXR1cy5wcm9jZXNzaW5nU3RhdHVzICYgX2NvbnN0cy5QUk9DRVNTSU5HKSA+IDA7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5faXNMb2FkaW5nID0gZnVuY3Rpb24gX2lzTG9hZGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TG9hZGluZ1N0YXR1cygpID4gMDtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9nZXRMb2FkaW5nU3RhdHVzID0gZnVuY3Rpb24gX2dldExvYWRpbmdTdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXR1cy5wcm9jZXNzaW5nU3RhdHVzICYgKF9jb25zdHMuTE9BRElOR19BUFBFTkQgfCBfY29uc3RzLkxPQURJTkdfUFJFUEVORCk7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIF9wcm9jZXNzKHN0YXR1cykge1xuXHRcdHZhciBpc0FkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuXHRcdGlmIChpc0FkZCkge1xuXHRcdFx0dGhpcy5fc3RhdHVzLnByb2Nlc3NpbmdTdGF0dXMgfD0gc3RhdHVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zdGF0dXMucHJvY2Vzc2luZ1N0YXR1cyAtPSB0aGlzLl9zdGF0dXMucHJvY2Vzc2luZ1N0YXR1cyAmIHN0YXR1cztcblx0XHR9XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5faW5zZXJ0ID0gZnVuY3Rpb24gX2luc2VydChlbGVtZW50cywgaXNBcHBlbmQsIGdyb3VwS2V5KSB7XG5cdFx0aWYgKHRoaXMuX2lzUHJvY2Vzc2luZygpIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIga2V5ID0gdHlwZW9mIGdyb3VwS2V5ID09PSBcInVuZGVmaW5lZFwiID8gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSA6IGdyb3VwS2V5O1xuXHRcdHZhciBpdGVtcyA9IF9JdGVtTWFuYWdlcjJbXCJkZWZhdWx0XCJdLmZyb20oZWxlbWVudHMsIHRoaXMub3B0aW9ucy5pdGVtU2VsZWN0b3IsIHtcblx0XHRcdGlzQXBwZW5kOiBpc0FwcGVuZCxcblx0XHRcdGdyb3VwS2V5OiBrZXlcblx0XHR9KTtcblxuXHRcdGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX3Bvc3RMYXlvdXQoe1xuXHRcdFx0ZnJvbUNhY2hlOiBfY29uc3RzLk5PX0NBQ0hFLFxuXHRcdFx0aXRlbXM6IGl0ZW1zLFxuXHRcdFx0aXNBcHBlbmQ6IGlzQXBwZW5kLFxuXHRcdFx0aXNUcnVzdGVkOiBfY29uc3RzLk5PX1RSVVNURURcblx0XHR9KTtcblx0fTtcblx0Ly8gYWRkIGl0ZW1zLCBhbmQgcmVtb3ZlIGl0ZW1zIGZvciByZWN5Y2xpbmdcblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3JlY3ljbGUgPSBmdW5jdGlvbiBfcmVjeWNsZShfcmVmKSB7XG5cdFx0dmFyIHN0YXJ0ID0gX3JlZi5zdGFydCxcblx0XHQgICAgZW5kID0gX3JlZi5lbmQ7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51c2VSZWN5Y2xlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdF9ET01SZW5kZXJlcjJbXCJkZWZhdWx0XCJdLnJlbW92ZUl0ZW1zKHRoaXMuX2l0ZW1zLnBsdWNrKFwiaXRlbXNcIiwgc3RhcnQsIGVuZCkpO1xuXHR9O1xuXHQvKipcbiAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIGxvYWRpbmcgYmFyLlxuICAqIEBrbyDroZzrlKkg67CU7J2YIGVsZW1lbnTrpbwg67CY7ZmY7ZWc64ukLlxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXBwZW5kPWN1cnJlbnRMb2FkaW5nQmFyfHRydWVdIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJkIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIGFwcGVuZCAoKSBtZXRob2QuIDxrbz7subTrk5wg7JeY66as66i87Yq46rCAIGFwcGVuZCgpIOuplOyEnOuTnOuhnCDstpTqsIAg7ZWgIOqyg+yduOyngCDtmZXsnbjtlZzri6QuPC9rbz5cbiAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgZWxlbWVudCBvZiBsb2FkaW5nIGJhci4gPGtvPuuhnOuUqSDrsJTsnZggZWxlbWVudDwva28+XG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLmdldExvYWRpbmdCYXIgPSBmdW5jdGlvbiBnZXRMb2FkaW5nQmFyKCkge1xuXHRcdHZhciBpc0FwcGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5fZ2V0TG9hZGluZ1N0YXR1cygpICE9PSBfY29uc3RzLkxPQURJTkdfUFJFUEVORDtcblxuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nQmFyW2lzQXBwZW5kID8gXCJhcHBlbmRcIiA6IFwicHJlcGVuZFwiXTtcblx0fTtcblx0LyoqXG4gICogU3RhcnQgbG9hZGluZyBmb3IgYXBwZW5kL3ByZXBlbmQgZHVyaW5nIGxvYWRpbmcgZGF0YS5cbiAgKiBAa28g642w7J207YSw6rCAIOuhnOuUqeuQmOuKlCDrj5nslYggYXBwZW5kL3ByZXBlbmTtlZjquLgg7JyE7ZW0IOuhnOuUqeydhCDsi5zsnpHtlZzri6QuXG4gICogQHBhcmFtIHtCb29sZWFufSBbaXNBcHBlbmQ9dHJ1ZV0gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhcmQgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgYXBwZW5kICgpIG1ldGhvZC4gPGtvPuy5tOuTnCDsl5jrpqzrqLztirjqsIAgYXBwZW5kKCkg66mU7ISc65Oc66GcIOy2lOqwgCDtlaAg6rKD7J247KeAIO2ZleyduO2VnOuLpC48L2tvPlxuICAqIEBwYXJhbSB7T2JqZWN0fSBbdXNlclN0eWxlID0ge2Rpc3BsYXk6IFwiYmxvY2tcIn1dIGN1c3RvbSBzdHlsZSB0byBhcHBseSB0byB0aGlzIGxvYWRpbmcgYmFyIGZvciBzdGFydC4gPGtvPiDroZzrlKkg7Iuc7J6R7J2EIOychO2VnCDroZzrlKkg67CU7JeQIOyggeyaqe2VoCDsu6TsiqTthYAg7Iqk7YOA7J28IDwva28+XG4gICogQHJldHVybiB7ZWcuSW5maW5pdGVHcmlkfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGY8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqL1xuXG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5zdGFydExvYWRpbmcgPSBmdW5jdGlvbiBzdGFydExvYWRpbmcoaXNBcHBlbmQpIHtcblx0XHR2YXIgdXNlclN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9O1xuXG5cdFx0aWYgKHRoaXMuX2lzTG9hZGluZygpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSBpc0FwcGVuZCA/IFwiYXBwZW5kXCIgOiBcInByZXBlbmRcIjtcblxuXHRcdHRoaXMuX3Byb2Nlc3MoaXNBcHBlbmQgPyBfY29uc3RzLkxPQURJTkdfQVBQRU5EIDogX2NvbnN0cy5MT0FESU5HX1BSRVBFTkQpO1xuXHRcdGlmICghdGhpcy5fbG9hZGluZ0Jhclt0eXBlXSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMuX3JlbmRlckxvYWRpbmcodXNlclN0eWxlKTtcblx0XHR0aGlzLl9zdGF0dXMubG9hZGluZ1N0eWxlID0gdXNlclN0eWxlO1xuXHRcdGlmICghaXNBcHBlbmQpIHtcblx0XHRcdHRoaXMuX2ZpdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5zZXRDb250YWluZXJTaXplKHRoaXMuX2dldEVkZ2VWYWx1ZShcImVuZFwiKSArIHRoaXMuX3N0YXR1cy5sb2FkaW5nU2l6ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3JlbmRlckxvYWRpbmcgPSBmdW5jdGlvbiBfcmVuZGVyTG9hZGluZygpIHtcblx0XHR2YXIgX2V4dGVuZHMyO1xuXG5cdFx0dmFyIHVzZXJTdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5fc3RhdHVzLmxvYWRpbmdTdHlsZTtcblxuXHRcdGlmICghdGhpcy5faXNMb2FkaW5nKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGlzQXBwZW5kID0gdGhpcy5fZ2V0TG9hZGluZ1N0YXR1cygpID09PSBfY29uc3RzLkxPQURJTkdfQVBQRU5EO1xuXHRcdHZhciBlbCA9IHRoaXMuX2xvYWRpbmdCYXJbaXNBcHBlbmQgPyBcImFwcGVuZFwiIDogXCJwcmVwZW5kXCJdO1xuXG5cdFx0aWYgKCFlbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9zdGF0dXMubG9hZGluZ1NpemUgPSB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICgwLCBfdXRpbHMuaW5uZXJXaWR0aCkoZWwpIDogKDAsIF91dGlscy5pbm5lckhlaWdodCkoZWwpO1xuXHRcdHZhciBwb3MgPSBpc0FwcGVuZCA/IHRoaXMuX2dldEVkZ2VWYWx1ZShcImVuZFwiKSA6IHRoaXMuX2dldEVkZ2VWYWx1ZShcInN0YXJ0XCIpIC0gdGhpcy5fc3RhdHVzLmxvYWRpbmdTaXplO1xuXHRcdHZhciBzdHlsZSA9IF9leHRlbmRzKChfZXh0ZW5kczIgPSB7XG5cdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG5cdFx0fSwgX2V4dGVuZHMyW3RoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXSA9IHBvcyArIFwicHhcIiwgX2V4dGVuZHMyKSwgdXNlclN0eWxlKTtcblxuXHRcdGZvciAodmFyIHByb3BlcnR5IGluIHN0eWxlKSB7XG5cdFx0XHRlbC5zdHlsZVtwcm9wZXJ0eV0gPSBzdHlsZVtwcm9wZXJ0eV07XG5cdFx0fVxuXHR9O1xuXHQvKipcbiAgKiBFbmQgbG9hZGluZyBhZnRlciBzdGFydExvYWRpbmcoKSBmb3IgYXBwZW5kL3ByZXBlbmRcbiAgKiBAa28gIGFwcGVuZC9wcmVwZW5k7ZWY6ri4IOychO2VtCBzdGFydExvYWRpbmcoKSDtmLjstpztlbTshKAg6rG47JeI642YIOuhnOuUqeydhCDrgZ3rgrjri6QuXG4gICogQHBhcmFtIHtPYmplY3R9IFt1c2VyU3R5bGUgPSB7ZGlzcGxheTogXCJub25lXCJ9XSBjdXN0b20gc3R5bGUgdG8gYXBwbHkgdG8gdGhpcyBsb2FkaW5nIGJhciBmb3IgZW5kIDxrbz4g66Gc65SpIOyLnOyekeydhCDsnITtlZwg66Gc65SpIOuwlOyXkCDsoIHsmqntlaAg7Luk7Iqk7YWAIOyKpO2DgOydvCA8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKi9cblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuZW5kTG9hZGluZyA9IGZ1bmN0aW9uIGVuZExvYWRpbmcoKSB7XG5cdFx0dmFyIHVzZXJTdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogeyBkaXNwbGF5OiBcIm5vbmVcIiB9O1xuXG5cdFx0aWYgKCF0aGlzLl9pc0xvYWRpbmcoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHZhciBpc0FwcGVuZCA9IHRoaXMuX2dldExvYWRpbmdTdGF0dXMoKSA9PT0gX2NvbnN0cy5MT0FESU5HX0FQUEVORDtcblx0XHR2YXIgdHlwZSA9IGlzQXBwZW5kID8gXCJhcHBlbmRcIiA6IFwicHJlcGVuZFwiO1xuXHRcdHZhciBlbCA9IHRoaXMuX2xvYWRpbmdCYXJbdHlwZV07XG5cdFx0dmFyIHN0YXR1cyA9IHRoaXMuX3N0YXR1cztcblx0XHR2YXIgc2l6ZSA9IHN0YXR1cy5sb2FkaW5nU2l6ZTtcblxuXHRcdHRoaXMuX3Byb2Nlc3MoX2NvbnN0cy5MT0FESU5HX0FQUEVORCB8IF9jb25zdHMuTE9BRElOR19QUkVQRU5ELCBmYWxzZSk7XG5cdFx0c3RhdHVzLmxvYWRpbmdTaXplID0gMDtcblx0XHRzdGF0dXMubG9hZGluZ1N0eWxlID0ge307XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHR2YXIgX2V4dGVuZHMzO1xuXG5cdFx0XHR2YXIgc3R5bGUgPSBfZXh0ZW5kcygoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1t0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl0gPSAtc2l6ZSArIFwicHhcIiwgX2V4dGVuZHMzKSwgdXNlclN0eWxlKTtcblxuXHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWwuc3R5bGVbcHJvcGVydHldID0gc3R5bGVbcHJvcGVydHldO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpc0FwcGVuZCkge1xuXHRcdFx0XHR0aGlzLl9maXRJdGVtcyhzaXplKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyLnNldENvbnRhaW5lclNpemUodGhpcy5fZ2V0RWRnZVZhbHVlKFwiZW5kXCIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy51c2VSZWN5Y2xlICYmICF0aGlzLmlzUHJvY2Vzc2luZygpKSB7XG5cdFx0XHR0aGlzLl9pbmZpbml0ZS5yZWN5Y2xlKHRoaXMuX3dhdGNoZXIuZ2V0U2Nyb2xsUG9zKCksIGlzQXBwZW5kKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuICAqIE1vdmUgdG8gc29tZSBncm91cCBvciBpdGVtIHBvc2l0aW9uLlxuICAqIEBrbyDtlbTri7ntlZjripQg6re466O5IOuYkOuKlCDslYTsnbTthZzsnZgg7JyE7LmY66GcIOydtOuPme2VnOuLpC5cbiAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XSBncm91cCdzIGluZGV4IDxrbz4g6re466O57J2YIGluZGV4PC9rbz5cbiAgKiBAcGFyYW0ge051bWJlcn0gW2l0ZW1JbmRleD0tMV0gaXRlbSdzIGluZGV4IDxrbz4g6re466O57J2YIGluZGV4PC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5JbmZpbml0ZUdyaWR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZjxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIG1vdmVUbyhpbmRleCkge1xuXHRcdHZhciBpdGVtSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC0xO1xuXG5cdFx0aWYgKHRoaXMuaXNQcm9jZXNzaW5nKCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR2YXIgZGF0YSA9IHRoaXMuX2l0ZW1zLmdldERhdGEoaW5kZXgpO1xuXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dmFyIGluZmluaXRlID0gdGhpcy5faW5maW5pdGU7XG5cdFx0dmFyIG91dGxpbmVzID0gZGF0YS5vdXRsaW5lcztcblx0XHR2YXIgaXRlbSA9IGRhdGEuaXRlbXNbaXRlbUluZGV4XTtcblx0XHR2YXIgaXNSZXNpemUgPSBvdXRsaW5lcy5zdGFydCAmJiBvdXRsaW5lcy5zdGFydC5sZW5ndGggPT09IDA7XG5cdFx0dmFyIHN0YXJ0Q3Vyc29yID0gaW5maW5pdGUuZ2V0Q3Vyc29yKFwic3RhcnRcIik7XG5cdFx0dmFyIGVuZEN1cnNvciA9IGluZmluaXRlLmdldEN1cnNvcihcImVuZFwiKTtcblx0XHR2YXIgaXNJbkN1cnNvciA9IHN0YXJ0Q3Vyc29yIDw9IGluZGV4ICYmIGluZGV4IDw9IGVuZEN1cnNvcjtcblx0XHR2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIHVzZVJlY3ljbGUgPSBfb3B0aW9ucy51c2VSZWN5Y2xlLFxuXHRcdCAgICBpc0VxdWFsU2l6ZSA9IF9vcHRpb25zLmlzRXF1YWxTaXplLFxuXHRcdCAgICBob3Jpem9udGFsID0gX29wdGlvbnMuaG9yaXpvbnRhbDtcblxuXG5cdFx0aWYgKGlzSW5DdXJzb3IgfHwgIXVzZVJlY3ljbGUgfHwgaXNFcXVhbFNpemUgfHwgIWlzUmVzaXplKSB7XG5cdFx0XHR2YXIgcG9zID0gaXRlbSAmJiBpdGVtLnJlY3RbaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl07XG5cblx0XHRcdGlmICh0eXBlb2YgcG9zID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdHBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIG91dGxpbmVzLnN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdHZhciBmaXQgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvdXRsaW5lcy5zdGFydCk7XG5cblx0XHRcdGlmIChmaXQgPCAwKSB7XG5cdFx0XHRcdC8vIGJhc2UgPCAwXG5cdFx0XHRcdHRoaXMuX2ZpdEl0ZW1zKGZpdCwgMCk7XG5cdFx0XHRcdHBvcyAtPSBmaXQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlzSW5DdXJzb3IgJiYgdXNlUmVjeWNsZSkge1xuXHRcdFx0XHR2YXIgaXNBcHBlbmQgPSBpbmRleCA+IHN0YXJ0Q3Vyc29yO1xuXG5cdFx0XHRcdGlmIChpc0FwcGVuZCkge1xuXHRcdFx0XHRcdC8vIGFwcGVuZFxuXHRcdFx0XHRcdGlmIChlbmRDdXJzb3IgKyAxIDwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdGluZmluaXRlLnNldEN1cnNvcihcInN0YXJ0XCIsIGluZGV4KTtcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYXBwZW5kXG5cdFx0XHRcdFx0XHRpbmZpbml0ZS5zZXRDdXJzb3IoXCJlbmRcIiwgaW5kZXggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcmVjeWNsZSBwcmV2aW91cyBpdGVtc1xuXHRcdFx0XHRcdHRoaXMuX3JlY3ljbGUoeyBzdGFydDogMCwgZW5kOiBpbmRleCAtIDEgfSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggKyAxIDwgc3RhcnRDdXJzb3IpIHtcblx0XHRcdFx0XHQvLyBwcmVwYXJlIHByZXBlbmRcblx0XHRcdFx0XHRpbmZpbml0ZS5zZXRDdXJzb3IoXCJzdGFydFwiLCBpbmRleCArIDEpO1xuXHRcdFx0XHRcdGluZmluaXRlLnNldEN1cnNvcihcImVuZFwiLCBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcG9zdENhY2hlKHtcblx0XHRcdFx0XHRpc0FwcGVuZDogaXNBcHBlbmQsXG5cdFx0XHRcdFx0b3V0bGluZTogb3V0bGluZXNbaXNBcHBlbmQgPyBcInN0YXJ0XCIgOiBcImVuZFwiXSxcblx0XHRcdFx0XHRjYWNoZTogZGF0YSxcblx0XHRcdFx0XHRpc1RydXN0ZWQ6IF9jb25zdHMuTk9fVFJVU1RFRCxcblx0XHRcdFx0XHRtb3ZlSXRlbTogaXRlbUluZGV4XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdHBvcyA9IE1hdGgubWF4KE1hdGgubWluKHBvcywgdGhpcy5fZ2V0RWRnZVZhbHVlKFwiZW5kXCIpIC0gdGhpcy5fcmVuZGVyZXIuZ2V0Vmlld1NpemUoKSksIDApO1xuXHRcdFx0dGhpcy5fc2Nyb2xsVG8ocG9zKTtcblx0XHR9IGVsc2UgaWYgKGlzUmVzaXplKSB7XG5cdFx0XHR2YXIgX2lzQXBwZW5kID0gaW5kZXggPiBlbmRDdXJzb3I7XG5cdFx0XHR2YXIgb3V0bGluZSA9IFswXTtcblxuXHRcdFx0aWYgKF9pc0FwcGVuZCkge1xuXHRcdFx0XHRpbmZpbml0ZS5zZXRDdXJzb3IoXCJzdGFydFwiLCBpbmRleCk7XG5cdFx0XHRcdGluZmluaXRlLnNldEN1cnNvcihcImVuZFwiLCBpbmRleCAtIDEpO1xuXHRcdFx0XHR0aGlzLl9yZWN5Y2xlKHsgc3RhcnQ6IDAsIGVuZDogaW5kZXggLSAxIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5maW5pdGUuc2V0Q3Vyc29yKFwic3RhcnRcIiwgaW5kZXggKyAxKTtcblx0XHRcdFx0aW5maW5pdGUuc2V0Q3Vyc29yKFwiZW5kXCIsIGluZGV4KTtcblx0XHRcdFx0dGhpcy5fcmVjeWNsZSh7IHN0YXJ0OiBpbmRleCArIDEsIGVuZDogdGhpcy5faXRlbXMuc2l6ZSgpIH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9zdExheW91dCh7XG5cdFx0XHRcdG91dGxpbmU6IG91dGxpbmUsXG5cdFx0XHRcdGlzQXBwZW5kOiBfaXNBcHBlbmQsXG5cdFx0XHRcdGZyb21DYWNoZTogX2NvbnN0cy5DQUNIRSxcblx0XHRcdFx0aXRlbXM6IGRhdGEuaXRlbXMsXG5cdFx0XHRcdGlzVHJ1c3RlZDogX2NvbnN0cy5UUlVTVEVELFxuXHRcdFx0XHRtb3ZlSXRlbTogaXRlbUluZGV4XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5fc2V0U2Nyb2xsUG9zID0gZnVuY3Rpb24gX3NldFNjcm9sbFBvcyhwb3MpIHtcblx0XHR0aGlzLl93YXRjaGVyLnNldFNjcm9sbFBvcyh0aGlzLl93YXRjaGVyLmdldENvbnRhaW5lck9mZnNldCgpICsgcG9zKTtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9zY3JvbGxUbyA9IGZ1bmN0aW9uIF9zY3JvbGxUbyhwb3MpIHtcblx0XHR0aGlzLl93YXRjaGVyLnNjcm9sbFRvKHRoaXMuX3dhdGNoZXIuZ2V0Q29udGFpbmVyT2Zmc2V0KCkgKyBwb3MpO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3Bvc3RMYXlvdXRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9wb3N0TGF5b3V0Q29tcGxldGUoX3JlZjIpIHtcblx0XHR2YXIgbGF5b3V0ZWQgPSBfcmVmMi5sYXlvdXRlZCxcblx0XHQgICAgaXNBcHBlbmQgPSBfcmVmMi5pc0FwcGVuZCxcblx0XHQgICAgaXNUcnVzdGVkID0gX3JlZjIuaXNUcnVzdGVkLFxuXHRcdCAgICBmcm9tQ2FjaGUgPSBfcmVmMi5mcm9tQ2FjaGUsXG5cdFx0ICAgIF9yZWYyJG1vdmVJdGVtID0gX3JlZjIubW92ZUl0ZW0sXG5cdFx0ICAgIG1vdmVJdGVtID0gX3JlZjIkbW92ZUl0ZW0gPT09IHVuZGVmaW5lZCA/IC0yIDogX3JlZjIkbW92ZUl0ZW0sXG5cdFx0ICAgIF9yZWYyJHVzZVJlY3ljbGUgPSBfcmVmMi51c2VSZWN5Y2xlLFxuXHRcdCAgICB1c2VSZWN5Y2xlID0gX3JlZjIkdXNlUmVjeWNsZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnVzZVJlY3ljbGUgOiBfcmVmMiR1c2VSZWN5Y2xlO1xuXG5cdFx0dmFyIHBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGxheW91dGVkLm91dGxpbmVzLnN0YXJ0KTtcblxuXHRcdGlmIChtb3ZlSXRlbSA+IC0yKSB7XG5cdFx0XHRwb3MgPSBNYXRoLm1heChNYXRoLm1pbihwb3MsIHRoaXMuX2dldEVkZ2VWYWx1ZShcImVuZFwiKSAtIHRoaXMuX3JlbmRlcmVyLmdldFZpZXdTaXplKCkpLCAwKTtcblx0XHRcdGlmICghaXNBcHBlbmQpIHtcblx0XHRcdFx0dGhpcy5fc2V0U2Nyb2xsUG9zKHBvcyArIDAuMSk7XG5cdFx0XHRcdHRoaXMuX3Njcm9sbFRvKHBvcyArIDAuMSk7XG5cdFx0XHR9IGVsc2UgaWYgKHBvcyA+IDApIHtcblx0XHRcdFx0dGhpcy5fc2V0U2Nyb2xsUG9zKHBvcyAtIDAuMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBpdGVtcyA9IGxheW91dGVkLml0ZW1zO1xuXG5cdFx0dGhpcy5fb25MYXlvdXRDb21wbGV0ZSh7IGl0ZW1zOiBpdGVtcywgaXNBcHBlbmQ6IGlzQXBwZW5kLCBmcm9tQ2FjaGU6IGZyb21DYWNoZSwgaXNUcnVzdGVkOiBpc1RydXN0ZWQsIHVzZVJlY3ljbGU6IHVzZVJlY3ljbGUgfSk7XG5cdFx0aWYgKG1vdmVJdGVtID4gLTIpIHtcblx0XHRcdCFpc0FwcGVuZCAmJiAocG9zID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgbGF5b3V0ZWQub3V0bGluZXMuc3RhcnQpKTtcblx0XHRcdHZhciBtb3ZlUG9zID0gcG9zO1xuXG5cdFx0XHRpZiAoaXRlbXNbbW92ZUl0ZW1dKSB7XG5cdFx0XHRcdG1vdmVQb3MgPSBpdGVtc1ttb3ZlSXRlbV0ucmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvdG5hbCA/IFwibGVmdFwiIDogXCJ0b3BcIl07XG5cdFx0XHR9XG5cdFx0XHRtb3ZlUG9zID0gTWF0aC5tYXgoTWF0aC5taW4obW92ZVBvcywgdGhpcy5fZ2V0RWRnZVZhbHVlKFwiZW5kXCIpIC0gdGhpcy5fcmVuZGVyZXIuZ2V0Vmlld1NpemUoKSksIDApO1xuXHRcdFx0aWYgKGlzQXBwZW5kKSB7XG5cdFx0XHRcdHRoaXMuX3Njcm9sbFRvKG1vdmVQb3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5faW5maW5pdGUuc2Nyb2xsKG1vdmVQb3MsIHRydWUpO1xuXHRcdFx0XHR0aGlzLl9zY3JvbGxUbyhtb3ZlUG9zKTtcblx0XHRcdFx0dGhpcy5fcmVjeWNsZSh7IHN0YXJ0OiB0aGlzLl9pbmZpbml0ZS5nZXRDdXJzb3IoXCJlbmRcIikgKyAxLCBlbmQ6IHRoaXMuX2l0ZW1zLnNpemUoKSAtIDEgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3Bvc3RJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uIF9wb3N0SW1hZ2VMb2FkZWQoZnJvbUNhY2hlLCBsYXlvdXRlZCwgaXRlbXMsIGlzQXBwZW5kLCBpc1RydXN0ZWQpIHtcblx0XHR2YXIgbW92ZUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IC0yO1xuXG5cdFx0dmFyIGdyb3VwS2V5ID0gbGF5b3V0ZWQuaXRlbXMgJiYgbGF5b3V0ZWQuaXRlbXNbMF0uZ3JvdXBLZXkgfHwgMDtcblxuXHRcdGxheW91dGVkLmdyb3VwS2V5ID0gZ3JvdXBLZXk7XG5cdFx0aWYgKGZyb21DYWNoZSkge1xuXHRcdFx0dGhpcy5faW5maW5pdGUuc2V0RGF0YShsYXlvdXRlZCwgaXNBcHBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmZpbml0ZVtpc0FwcGVuZCA/IFwiYXBwZW5kXCIgOiBcInByZXBlbmRcIl0obGF5b3V0ZWQpO1xuXHRcdH1cblx0XHRfRE9NUmVuZGVyZXIyW1wiZGVmYXVsdFwiXS5yZW5kZXJJdGVtcyhsYXlvdXRlZC5pdGVtcyk7XG5cdFx0dGhpcy5fcG9zdExheW91dENvbXBsZXRlKHsgbGF5b3V0ZWQ6IGxheW91dGVkLCBpc0FwcGVuZDogaXNBcHBlbmQsIGZyb21DYWNoZTogZnJvbUNhY2hlLCBpc1RydXN0ZWQ6IGlzVHJ1c3RlZCwgbW92ZUl0ZW06IG1vdmVJdGVtLCB1c2VSZWN5Y2xlOiBmYWxzZSB9KTtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9vbkltYWdlRXJyb3IgPSBmdW5jdGlvbiBfb25JbWFnZUVycm9yKHRhcmdldCwgaXRlbSwgaXRlbUluZGV4LCByZW1vdmVUYXJnZXQsIHJlcGxhY2VUYXJnZXQpIHtcblx0XHR2YXIgZWxlbWVudCA9IGl0ZW0uZWw7XG5cdFx0dmFyIHByZWZpeCA9IHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVQcmVmaXg7XG5cblx0XHRpdGVtLmNvbnRlbnQgPSBlbGVtZW50Lm91dGVySFRNTDtcblxuXHRcdHZhciByZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbSgpIHtcblx0XHRcdGlmIChoYXNUYXJnZXQoW3JlbW92ZVRhcmdldCwgZWxlbWVudF0pKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlbW92ZVRhcmdldC5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0dmFyIGluZGV4ID0gcmVwbGFjZVRhcmdldC5pbmRleE9mKGl0ZW1JbmRleCk7XG5cblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0cmVwbGFjZVRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiB0aGUgaW1hZ2UuXG4gICAqIEBrbyDsnbTrr7jsp4Ag66Gc65Oc7JeQIOyXkOufrOqwgCDrgqAg65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirguXG4gICAqIEBldmVudCBlZy5JbmZpbml0ZUdyaWQjaW1hZ2VFcnJvclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyYW0udGFyZ2V0IEFwcGVuZGluZyBjYXJkJ3MgaW1hZ2UgZWxlbWVudC48a28+7LaU6rCAIOuQmOuKlCDsubTrk5zsnZgg7J2066+47KeAIOyXmOumrOuovO2KuDwva28+XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyYW0uZWxlbWVtdCBUaGUgaXRlbSdzIGVsZW1lbnQgd2l0aCBlcnJvciBpbWFnZXMuPGtvPuyXkOufrOuCnCDsnbTrr7jsp4Drpbwg6rCA7KeA6rOgIOyeiOuKlCDslYTsnbTthZzsnZgg7JeY66as66i87Yq4PC9rbz5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLml0ZW0gVGhlIGl0ZW0gd2l0aCBlcnJvciBpbWFnZXMuPGtvPuyXkOufrOuCnCDsnbTrr7jsp4Drpbwg6rCA7KeA6rOgIOyeiOuKlCDslYTsnbTthZw8L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0uaXRlbUluZGV4IFRoZSBpdGVtJ3MgaW5kZXggd2l0aCBlcnJvciBpbWFnZXMuPGtvPuyXkOufrOuCnCDsnbTrr7jsp4Drpbwg6rCA7KeA6rOgIOyeiOuKlCDslYTsnbTthZzsnZgg7J24642x7IqkPC9rbz5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW0ucmVtb3ZlIEluIHRoZSBpbWFnZUVycm9yIGV2ZW50LCB0aGlzIG1ldGhvZCBleHBlY3RzIHRvIHJlbW92ZSB0aGUgZXJyb3IgaW1hZ2UuPGtvPuydtOuvuOyngCDsl5Drn6wg7J2067Kk7Yq47JeQ7IScIOydtCDrqZTshJzrk5zripQg7JeQ65+s64KcIOydtOuvuOyngOulvCDsgq3soJztlZzri6QuPC9rbz5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW0ucmVtb3ZlSXRlbSBJbiB0aGUgaW1hZ2VFcnJvciBldmVudCwgdGhpcyBtZXRob2QgZXhwZWN0cyB0byByZW1vdmUgdGhlIGl0ZW0gd2l0aCB0aGUgZXJyb3IgaW1hZ2UuPGtvPuydtOuvuOyngCDsl5Drn6wg7J2067Kk7Yq47JeQ7IScIOydtCDrqZTshJzrk5zripQg7JeQ65+s64KcIOydtOuvuOyngOulvCDqsIDsp4Dqs6Ag7J6I64qUIOyVhOydtO2FnOydhCDsgq3soJztlZzri6QuPC9rbz5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcGFyYW0ucmVwbGFjZSBJbiB0aGUgaW1hZ2VFcnJvciBldmVudCwgdGhpcyBtZXRob2QgZXhwZWN0cyB0byByZXBsYWNlIHRoZSBlcnJvciBpbWFnZSdzIHNvdXJjZSBvciBlbGVtZW50Ljxrbz7snbTrr7jsp4Ag7JeQ65+sIOydtOuypO2KuOyXkOyEnCDsnbQg66mU7ISc65Oc64qUIOyXkOufrOuCnCDsnbTrr7jsp4DsnZgg7KO87IaMIOuYkOuKlCDsl5jrpqzrqLztirjrpbwg6rWQ7LK07ZWc64ukLjwva28+XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcmFtLnJlcGxhY2VJdGVtIEluIHRoZSBpbWFnZUVycm9yIGV2ZW50LCB0aGlzIG1ldGhvZCBleHBlY3RzIHRvIHJlcGxhY2UgdGhlIGl0ZW0ncyBjb250ZW50cyB3aXRoIHRoZSBlcnJvciBpbWFnZS48a28+7J2066+47KeAIOyXkOufrCDsnbTrsqTtirjsl5DshJwg7J20IOuplOyEnOuTnOuKlCDsl5Drn6zrgpwg7J2066+47KeA66W8IOqwgOyngOqzoCDsnojripQg7JWE7J207YWc7J2YIOuCtOyaqeydhCDqtZDssrTtlZzri6QuPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgaWcub24oXCJpbWFnZUVycm9yXCIsIGUgPT4ge1xuICBlLnJlbW92ZSgpO1xuICBlLnJlbW92ZUl0ZW0oKTtcbiAgZS5yZXBsYWNlKFwiaHR0cDovLy4uLmpwZ1wiKTtcbiAgZS5yZXBsYWNlKGltYWdlRWxlbWVudCk7XG4gIGUucmVwbGFjZUl0ZW0oXCJpdGVtIGh0bWxcIik7XG4gIH0pO1xuICAgKi9cblx0XHR0aGlzLnRyaWdnZXIoXCJpbWFnZUVycm9yXCIsIHtcblx0XHRcdHRhcmdldDogdGFyZ2V0LFxuXHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRpdGVtSW5kZXg6IGl0ZW1JbmRleCxcblx0XHRcdC8vIHJlbW92ZSBpdGVtXG5cdFx0XHRyZW1vdmVJdGVtOiByZW1vdmVJdGVtLFxuXHRcdFx0Ly8gcmVtb3ZlIGltYWdlXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRcdFx0aWYgKHRhcmdldCA9PT0gZWxlbWVudCkge1xuXHRcdFx0XHRcdHJlbW92ZUl0ZW0oKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1RhcmdldChbcmVtb3ZlVGFyZ2V0LCBlbGVtZW50XSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcblx0XHRcdFx0aXRlbS5jb250ZW50ID0gZWxlbWVudC5vdXRlckhUTUw7XG5cdFx0XHRcdGlmIChoYXNUYXJnZXQoW3JlcGxhY2VUYXJnZXQsIGl0ZW1JbmRleF0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcGxhY2VUYXJnZXQucHVzaChpdGVtSW5kZXgpO1xuXHRcdFx0fSxcblx0XHRcdC8vIHJlcGxhY2UgaW1hZ2Vcblx0XHRcdHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2Uoc3JjKSB7XG5cdFx0XHRcdGlmIChoYXNUYXJnZXQoW3JlbW92ZVRhcmdldCwgZWxlbWVudF0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRpZiAoKDAsIF91dGlscy5tYXRjaEhUTUwpKHNyYykgfHwgKHR5cGVvZiBzcmMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihzcmMpKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoKDAsIF91dGlscy4kKShzcmMpLCB0YXJnZXQpO1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuXHRcdFx0XHRcdFx0aXRlbS5jb250ZW50ID0gZWxlbWVudC5vdXRlckhUTUw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldC5zcmMgPSBzcmM7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZShwcmVmaXggKyBcIndpZHRoXCIpKSB7XG5cdFx0XHRcdFx0XHRcdF9BdXRvU2l6ZXIyW1wiZGVmYXVsdFwiXS5yZW1vdmUodGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShwcmVmaXggKyBcIndpZHRoXCIpO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXQucmVtb3ZlQXR0cmlidXRlKHByZWZpeCArIFwiaGVpZ2h0XCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpdGVtLmNvbnRlbnQgPSBlbGVtZW50Lm91dGVySFRNTDtcblx0XHRcdFx0aWYgKGhhc1RhcmdldChbcmVwbGFjZVRhcmdldCwgaXRlbUluZGV4XSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVwbGFjZVRhcmdldC5wdXNoKGl0ZW1JbmRleCk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gcmVwbGFjZSBpdGVtXG5cdFx0XHRyZXBsYWNlSXRlbTogZnVuY3Rpb24gcmVwbGFjZUl0ZW0oY29udGVudCkge1xuXHRcdFx0XHRpZiAoaGFzVGFyZ2V0KFtyZW1vdmVUYXJnZXQsIGVsZW1lbnRdLCBbcmVwbGFjZVRhcmdldCwgaXRlbUluZGV4XSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuXHRcdFx0XHRpdGVtLmNvbnRlbnQgPSBlbGVtZW50Lm91dGVySFRNTDtcblx0XHRcdFx0cmVwbGFjZVRhcmdldC5wdXNoKGl0ZW1JbmRleCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5fcG9zdEltYWdlTG9hZGVkRW5kID0gZnVuY3Rpb24gX3Bvc3RJbWFnZUxvYWRlZEVuZChpdGVtcywgaXNBcHBlbmQsIHJlbW92ZVRhcmdldCwgcmVwbGFjZVRhcmdldCkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0dmFyIHNjcm9sbFBvcyA9IHRoaXMuX3dhdGNoZXIuZ2V0U2Nyb2xsUG9zKCk7XG5cdFx0dmFyIF9vcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcblx0XHQgICAgdXNlUmVjeWNsZSA9IF9vcHRpb25zMi51c2VSZWN5Y2xlLFxuXHRcdCAgICBpc0VxdWFsU2l6ZSA9IF9vcHRpb25zMi5pc0VxdWFsU2l6ZSxcblx0XHQgICAgYXR0cmlidXRlUHJlZml4ID0gX29wdGlvbnMyLmF0dHJpYnV0ZVByZWZpeDtcblxuXG5cdFx0aWYgKCFyZW1vdmVUYXJnZXQubGVuZ3RoICYmICFyZXBsYWNlVGFyZ2V0Lmxlbmd0aCkge1xuXHRcdFx0aWYgKCF0aGlzLmlzUHJvY2Vzc2luZygpICYmIHVzZVJlY3ljbGUpIHtcblx0XHRcdFx0dGhpcy5faW5maW5pdGUucmVjeWNsZShzY3JvbGxQb3MsIGlzQXBwZW5kKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGxheW91dGVkSXRlbXMgPSByZXBsYWNlVGFyZ2V0Lm1hcChmdW5jdGlvbiAoaXRlbUluZGV4KSB7XG5cdFx0XHRyZXR1cm4gaXRlbXNbaXRlbUluZGV4XTtcblx0XHR9KTtcblxuXHRcdHJlbW92ZVRhcmdldC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRfdGhpczIucmVtb3ZlKGVsZW1lbnQsIGZhbHNlKTtcblx0XHR9KTtcblx0XHRpZiAoaXNFcXVhbFNpemUpIHtcblx0XHRcdGlmIChyZW1vdmVUYXJnZXQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLmxheW91dChmYWxzZSk7XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLmlzUHJvY2Vzc2luZygpICYmIHVzZVJlY3ljbGUpIHtcblx0XHRcdFx0dGhpcy5faW5maW5pdGUucmVjeWNsZShzY3JvbGxQb3MsIGlzQXBwZW5kKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly8gd2FpdCBsYXlvdXRDb21wbGV0ZSBiZWFjYXVzZSBvZiBlcnJvciBldmVudC5cblx0XHRfSW1hZ2VMb2FkZWQyW1wiZGVmYXVsdFwiXS5jaGVjayhsYXlvdXRlZEl0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuXHRcdFx0cmV0dXJuIHYuZWw7XG5cdFx0fSksIHtcblx0XHRcdHByZWZpeDogYXR0cmlidXRlUHJlZml4LFxuXHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0XHRfdGhpczIuX3JlbmRlcmVyLnVwZGF0ZVNpemUobGF5b3V0ZWRJdGVtcyk7XG5cdFx0XHRcdF90aGlzMi5sYXlvdXQoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3Bvc3RDYWNoZSA9IGZ1bmN0aW9uIF9wb3N0Q2FjaGUoX3JlZjMpIHtcblx0XHR2YXIgY2FjaGUgPSBfcmVmMy5jYWNoZSxcblx0XHQgICAgaXNBcHBlbmQgPSBfcmVmMy5pc0FwcGVuZCxcblx0XHQgICAgX3JlZjMkaXNUcnVzdGVkID0gX3JlZjMuaXNUcnVzdGVkLFxuXHRcdCAgICBpc1RydXN0ZWQgPSBfcmVmMyRpc1RydXN0ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMyRpc1RydXN0ZWQsXG5cdFx0ICAgIF9yZWYzJG91dGxpbmUgPSBfcmVmMy5vdXRsaW5lLFxuXHRcdCAgICBvdXRsaW5lID0gX3JlZjMkb3V0bGluZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5faW5maW5pdGUuZ2V0RWRnZU91dGxpbmUoaXNBcHBlbmQgPyBcImVuZFwiIDogXCJzdGFydFwiKSA6IF9yZWYzJG91dGxpbmUsXG5cdFx0ICAgIF9yZWYzJG1vdmVJdGVtID0gX3JlZjMubW92ZUl0ZW0sXG5cdFx0ICAgIG1vdmVJdGVtID0gX3JlZjMkbW92ZUl0ZW0gPT09IHVuZGVmaW5lZCA/IC0yIDogX3JlZjMkbW92ZUl0ZW07XG5cblx0XHR2YXIgY2FjaGVPdXRsaW5lID0gY2FjaGUub3V0bGluZXNbaXNBcHBlbmQgPyBcInN0YXJ0XCIgOiBcImVuZFwiXTtcblxuXHRcdHZhciBmcm9tUmVsYXlvdXQgPSBvdXRsaW5lLmxlbmd0aCA9PT0gY2FjaGVPdXRsaW5lLmxlbmd0aCA/ICFvdXRsaW5lLmV2ZXJ5KGZ1bmN0aW9uICh2LCBpbmRleCkge1xuXHRcdFx0cmV0dXJuIHYgPT09IGNhY2hlT3V0bGluZVtpbmRleF07XG5cdFx0fSkgOiB0cnVlO1xuXG5cdFx0aWYgKCFmcm9tUmVsYXlvdXQpIHtcblx0XHRcdHRoaXMuX2luZmluaXRlLnVwZGF0ZUN1cnNvcihpc0FwcGVuZCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpO1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuY3JlYXRlQW5kSW5zZXJ0KGNhY2hlLml0ZW1zLCBpc0FwcGVuZCk7XG5cdFx0XHR0aGlzLl9wb3N0TGF5b3V0Q29tcGxldGUoeyBsYXlvdXRlZDogY2FjaGUsIGlzQXBwZW5kOiBpc0FwcGVuZCwgaXNUcnVzdGVkOiBpc1RydXN0ZWQsIG1vdmVJdGVtOiBtb3ZlSXRlbSB9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fcG9zdExheW91dCh7XG5cdFx0XHRmcm9tQ2FjaGU6IF9jb25zdHMuQ0FDSEUsXG5cdFx0XHRpdGVtczogY2FjaGUuaXRlbXMsXG5cdFx0XHRvdXRsaW5lOiBvdXRsaW5lLFxuXHRcdFx0aXNBcHBlbmQ6IGlzQXBwZW5kLFxuXHRcdFx0aXNUcnVzdGVkOiBpc1RydXN0ZWQsXG5cdFx0XHRtb3ZlSXRlbTogbW92ZUl0ZW1cblx0XHR9KTtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9wb3N0TGF5b3V0ID0gZnVuY3Rpb24gX3Bvc3RMYXlvdXQoX3JlZjQpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblxuXHRcdHZhciBmcm9tQ2FjaGUgPSBfcmVmNC5mcm9tQ2FjaGUsXG5cdFx0ICAgIGl0ZW1zID0gX3JlZjQuaXRlbXMsXG5cdFx0ICAgIGlzQXBwZW5kID0gX3JlZjQuaXNBcHBlbmQsXG5cdFx0ICAgIF9yZWY0JG91dGxpbmUgPSBfcmVmNC5vdXRsaW5lLFxuXHRcdCAgICBvdXRsaW5lID0gX3JlZjQkb3V0bGluZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5faW5maW5pdGUuZ2V0RWRnZU91dGxpbmUoaXNBcHBlbmQgPyBcImVuZFwiIDogXCJzdGFydFwiKSA6IF9yZWY0JG91dGxpbmUsXG5cdFx0ICAgIGlzVHJ1c3RlZCA9IF9yZWY0LmlzVHJ1c3RlZCxcblx0XHQgICAgX3JlZjQkbW92ZUl0ZW0gPSBfcmVmNC5tb3ZlSXRlbSxcblx0XHQgICAgbW92ZUl0ZW0gPSBfcmVmNCRtb3ZlSXRlbSA9PT0gdW5kZWZpbmVkID8gLTIgOiBfcmVmNCRtb3ZlSXRlbTtcblxuXHRcdHRoaXMuX3Byb2Nlc3MoX2NvbnN0cy5QUk9DRVNTSU5HKTtcblx0XHR2YXIgbWV0aG9kID0gaXNBcHBlbmQgPyBcImFwcGVuZFwiIDogXCJwcmVwZW5kXCI7XG5cblx0XHRmcm9tQ2FjaGUgJiYgX0RPTVJlbmRlcmVyMltcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudHMoaXRlbXMpO1xuXHRcdHRoaXMuX3JlbmRlcmVyW21ldGhvZF0oaXRlbXMpO1xuXG5cdFx0Ly8gY2hlY2sgaW1hZ2Ugc2l6ZXMgYWZ0ZXIgZWxlbWVudHMgYXJlIGF0dGF0ZWQgb24gRE9NXG5cdFx0dmFyIHR5cGUgPSB0aGlzLm9wdGlvbnMuaXNFcXVhbFNpemUgJiYgdGhpcy5fcmVuZGVyZXIuX3NpemUuaXRlbSA/IF9JbWFnZUxvYWRlZC5DSEVDS19PTkxZX0VSUk9SIDogX0ltYWdlTG9hZGVkLkNIRUNLX0FMTDtcblx0XHR2YXIgcHJlZml4ID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZVByZWZpeDtcblx0XHR2YXIgcmVwbGFjZVRhcmdldCA9IFtdO1xuXHRcdHZhciByZW1vdmVUYXJnZXQgPSBbXTtcblx0XHR2YXIgbGF5b3V0ZWQgPSB2b2lkIDA7XG5cblx0XHRfSW1hZ2VMb2FkZWQyW1wiZGVmYXVsdFwiXS5jaGVjayhpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLmVsO1xuXHRcdH0pLCB7XG5cdFx0XHRwcmVmaXg6IHByZWZpeCxcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG5cdFx0XHRcdGxheW91dGVkID0gX3RoaXMzLl9sYXlvdXRbbWV0aG9kXShfdGhpczMuX3JlbmRlcmVyLnVwZGF0ZVNpemUoaXRlbXMpLCBvdXRsaW5lKTtcblx0XHRcdFx0Ly8gbm8gcmVjeWNsZVxuXHRcdFx0XHRfdGhpczMuX3Bvc3RJbWFnZUxvYWRlZChmcm9tQ2FjaGUsIGxheW91dGVkLCBpdGVtcywgaXNBcHBlbmQsIGlzVHJ1c3RlZCwgbW92ZUl0ZW0pO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiBlcnJvcihfcmVmNSkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gX3JlZjUudGFyZ2V0LFxuXHRcdFx0XHQgICAgaXRlbUluZGV4ID0gX3JlZjUuaXRlbUluZGV4O1xuXG5cdFx0XHRcdHZhciBpdGVtID0gbGF5b3V0ZWQgJiYgbGF5b3V0ZWQuaXRlbXNbaXRlbUluZGV4XSB8fCBpdGVtc1tpdGVtSW5kZXhdO1xuXG5cdFx0XHRcdF90aGlzMy5fb25JbWFnZUVycm9yKHRhcmdldCwgaXRlbSwgaXRlbUluZGV4LCByZW1vdmVUYXJnZXQsIHJlcGxhY2VUYXJnZXQpO1xuXHRcdFx0fSxcblx0XHRcdGVuZDogZnVuY3Rpb24gZW5kKCkge1xuXHRcdFx0XHQvLyByZWN5Y2xlXG5cdFx0XHRcdF90aGlzMy5fcG9zdEltYWdlTG9hZGVkRW5kKGl0ZW1zLCBpc0FwcGVuZCwgcmVtb3ZlVGFyZ2V0LCByZXBsYWNlVGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0Ly8gY2FsbGVkIGJ5IHZpc2libGVcblxuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3JlcXVlc3RBcHBlbmQgPSBmdW5jdGlvbiBfcmVxdWVzdEFwcGVuZChfcmVmNikge1xuXHRcdHZhciBjYWNoZSA9IF9yZWY2LmNhY2hlO1xuXG5cdFx0aWYgKHRoaXMuX2lzUHJvY2Vzc2luZygpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChjYWNoZSkge1xuXHRcdFx0dGhpcy5fcG9zdENhY2hlKHsgY2FjaGU6IGNhY2hlLCBpc0FwcGVuZDogX2NvbnN0cy5BUFBFTkQgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKlxuICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgY2FyZCBlbGVtZW50IG11c3QgYmUgYWRkZWQgYXQgdGhlIGJvdHRvbSBvciByaWdodCBvZiBhIGxheW91dCBiZWNhdXNlIHRoZXJlIGlzIG5vIGNhcmQgdG8gYmUgZGlzcGxheWVkIG9uIHNjcmVlbiB3aGVuIGEgdXNlciBzY3JvbGxzIG5lYXIgYm90dG9tIG9yIHJpZ2h0LlxuICAgICogQGtvIOy5tOuTnCDsl5jrpqzrqLztirjqsIAg66CI7J207JWE7JuD7J2YIOyVhOuemOuCmCDsmKTrpbjsqr3sl5Ag7LaU6rCA64+87JW8IO2VoCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuC4g7IKs7Jqp7J6Q6rCAIOyVhOuemOuCmCDsmKTrpbjsqr3snLzroZwg7Iqk7YGs66Gk7ZW07IScIO2ZlOuptOyXkCDtkZzsi5zrkKAg7Lm065Oc6rCAIOyXhuydhCDrlYwg67Cc7IOd7ZWc64ukXG4gICAgKiBAZXZlbnQgZWcuSW5maW5pdGVHcmlkI2FwcGVuZFxuICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBncm91cEtleSBUaGUgZ3JvdXAga2V5IG9mIHRoZSBmaXJzdCBncm91cCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gPGtvPu2ZlOuptOyXkCDrs7Tsl6zsp4DripQg66eI7KeA66eJIOq3uOujueydmCDqt7jro7ntgqQ8L2tvPlxuICAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbS5pc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImFwcGVuZFwiLCB7XG5cdFx0XHRcdGlzVHJ1c3RlZDogX2NvbnN0cy5UUlVTVEVELFxuXHRcdFx0XHRncm91cEtleTogdGhpcy5nZXRHcm91cEtleXMoKS5wb3AoKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXHQvLyBjYWxsZWQgYnkgdmlzaWJsZVxuXG5cblx0SW5maW5pdGVHcmlkLnByb3RvdHlwZS5fcmVxdWVzdFByZXBlbmQgPSBmdW5jdGlvbiBfcmVxdWVzdFByZXBlbmQoX3JlZjcpIHtcblx0XHR2YXIgY2FjaGUgPSBfcmVmNy5jYWNoZSxcblx0XHQgICAgX3JlZjckZml0ID0gX3JlZjcuZml0LFxuXHRcdCAgICBmaXQgPSBfcmVmNyRmaXQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmNyRmaXQ7XG5cblx0XHRpZiAoZml0KSB7XG5cdFx0XHR0aGlzLl9maXQoKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2lzUHJvY2Vzc2luZygpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChjYWNoZSkge1xuXHRcdFx0dGhpcy5fcG9zdENhY2hlKHsgY2FjaGU6IGNhY2hlLCBpc0FwcGVuZDogX2NvbnN0cy5QUkVQRU5EIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKipcbiAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGNhcmQgZWxlbWVudCBtdXN0IGJlIGFkZGVkIGF0IHRoZSB0b3Agb3IgbGVmdCBvZiBhIGxheW91dCBiZWNhdXNlIHRoZXJlIGlzIG5vIGNhcmQgdG8gYmUgZGlzcGxheWVkIG9uIHNjcmVlbiB3aGVuIGEgdXNlciBzY3JvbGxzIG5lYXIgdG9wIG9yIGxlZnQuXG4gICAgKiBAa28g7Lm065Oc6rCAIOugiOydtOyVhOybg+ydmCDsnITrgpgg7Jm87Kq97JeQIOy2lOqwgOuPvOyVvCDtlaAg65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirguIOyCrOyaqeyekOqwgCDsnITrgpgg7Jm87Kq97Jy866GcIOyKpO2BrOuhpO2VtOyEnCDtmZTrqbTsl5Ag7ZGc7Iuc65CgIOy5tOuTnOqwgCDsl4bsnYQg65WMIOuwnOyDne2VnOuLpC5cbiAgICAqIEBldmVudCBlZy5JbmZpbml0ZUdyaWQjcHJlcGVuZFxuICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBncm91cEtleSBUaGUgZ3JvdXAga2V5IG9mIHRoZSBmaXJzdCBncm91cCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4gPGtvPu2ZlOuptOyXkCDrs7Tsl6zsp4DripQg7LKr67KI7Ke4IOq3uOujueydmCDqt7jro7ntgqQ8L2tvPlxuICAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbS5pc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcInByZXBlbmRcIiwge1xuXHRcdFx0XHRpc1RydXN0ZWQ6IF9jb25zdHMuVFJVU1RFRCxcblx0XHRcdFx0Z3JvdXBLZXk6IHRoaXMuZ2V0R3JvdXBLZXlzKCkuc2hpZnQoKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuXHRcdHRoaXMubGF5b3V0KHRydWUpO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX29uQ2hlY2sgPSBmdW5jdGlvbiBfb25DaGVjayhfcmVmOCkge1xuXHRcdHZhciBpc0ZvcndhcmQgPSBfcmVmOC5pc0ZvcndhcmQsXG5cdFx0ICAgIHNjcm9sbFBvcyA9IF9yZWY4LnNjcm9sbFBvcyxcblx0XHQgICAgaG9yaXpvbnRhbCA9IF9yZWY4Lmhvcml6b250YWwsXG5cdFx0ICAgIG9yZ1Njcm9sbFBvcyA9IF9yZWY4Lm9yZ1Njcm9sbFBvcztcblxuXHRcdC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy5cbiAgICogQGtvIOyCrOyaqeyekOqwgCDsiqTtgazroaQg7ZWgIOqyveyasCDrsJzsg53tlZjripQg7J2067Kk7Yq4LlxuICAgKiBAZXZlbnQgZWcuSW5maW5pdGVHcmlkI2NoYW5nZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW0uaXNGb3J3YXJkIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY3JvbGwgcHJvZ3Jlc3Npb24gZGlyZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dvcmQuIDxrbz7siqTtgazroaQg7KeE7ZaJ67Cp7Zal7J20IOyVnuyqveycvOuhnCDsp4TtlontlZjripQg7KeALCDrkqTsqr3snLzroZwg7KeE7ZaJ7ZWY64qU7KeA66W8IOuCmO2DgOuCuOuLpC48L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0uc2Nyb2xsUG9zIEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlIHJlbGF0aXZlIHRvIHRoZSBpbmZpbml0ZUdyaWQgY29udGFpbmVyIGVsZW1lbnQuIDxrbz5pbmZpbml0ZUdyaWQg7Luo7YWM7J2064SIIOyXmOumrOuovO2KuCDquLDspIDsnZgg7ZiE7J6sIOyKpO2BrOuhpCDsnITsuZjqsJI8L2tvPlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtLm9yZ1Njcm9sbFBvcyBDdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgPGtvPu2YhOyerCDsiqTtgazroaQg7JyE7LmY6rCSPC9rbz5cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbS5pc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5ob3Jpem9udGFsIERpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsIG1vdmVtZW50ICh0cnVlOiBob3Jpem9udGFsLCBmYWxzZTogdmVydGljYWwpIDxrbz7siqTtgazroaQg7J2064+ZIOuwqe2WpSAodHJ1ZSDqsIDroZzrsKntlqUsIGZhbHNlIOyEuOuhnOuwqe2WpTwva28+XG4gICAqL1xuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB7XG5cdFx0XHRpc0ZvcndhcmQ6IGlzRm9yd2FyZCxcblx0XHRcdGhvcml6b250YWw6IGhvcml6b250YWwsXG5cdFx0XHRzY3JvbGxQb3M6IHNjcm9sbFBvcyxcblx0XHRcdG9yZ1Njcm9sbFBvczogb3JnU2Nyb2xsUG9zXG5cdFx0fSk7XG5cdFx0dGhpcy5faW5maW5pdGUuc2Nyb2xsKHNjcm9sbFBvcywgaXNGb3J3YXJkKTtcblx0fTtcblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLl9vbkxheW91dENvbXBsZXRlID0gZnVuY3Rpb24gX29uTGF5b3V0Q29tcGxldGUoX3JlZjkpIHtcblx0XHR2YXIgaXRlbXMgPSBfcmVmOS5pdGVtcyxcblx0XHQgICAgaXNBcHBlbmQgPSBfcmVmOS5pc0FwcGVuZCxcblx0XHQgICAgX3JlZjkkaXNUcnVzdGVkID0gX3JlZjkuaXNUcnVzdGVkLFxuXHRcdCAgICBpc1RydXN0ZWQgPSBfcmVmOSRpc1RydXN0ZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjkkaXNUcnVzdGVkLFxuXHRcdCAgICBfcmVmOSR1c2VSZWN5Y2xlID0gX3JlZjkudXNlUmVjeWNsZSxcblx0XHQgICAgdXNlUmVjeWNsZSA9IF9yZWY5JHVzZVJlY3ljbGUgPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy51c2VSZWN5Y2xlIDogX3JlZjkkdXNlUmVjeWNsZSxcblx0XHQgICAgX3JlZjkkZnJvbUNhY2hlID0gX3JlZjkuZnJvbUNhY2hlLFxuXHRcdCAgICBmcm9tQ2FjaGUgPSBfcmVmOSRmcm9tQ2FjaGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjkkZnJvbUNhY2hlLFxuXHRcdCAgICBfcmVmOSRpc0xheW91dCA9IF9yZWY5LmlzTGF5b3V0LFxuXHRcdCAgICBpc0xheW91dCA9IF9yZWY5JGlzTGF5b3V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWY5JGlzTGF5b3V0O1xuXG5cdFx0dmFyIHZpZXdTaXplID0gdGhpcy5fcmVuZGVyZXIuZ2V0Vmlld1NpemUoKTtcblxuXHRcdGlmICghaXNBcHBlbmQpIHtcblx0XHRcdHRoaXMuX2ZpdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pc0xvYWRpbmcoKSAmJiB0aGlzLl9yZW5kZXJMb2FkaW5nKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyO1xuXHRcdHZhciBzY3JvbGxQb3MgPSB3YXRjaGVyLmdldFNjcm9sbFBvcygpO1xuXG5cdFx0Ly8gcmVjeWNsZSBhZnRlciBfZml0IGJlYWNhdXNlIHByZXBlbmQgYW5kIGFwcGVuZCBhcmUgb2NjdXJlZCBzaW11bHRhbmVvdXNseSBieSBzY3JvbGwuXG5cdFx0aWYgKCFpc0xheW91dCAmJiB1c2VSZWN5Y2xlICYmICF0aGlzLl9pc0xvYWRpbmcoKSkge1xuXHRcdFx0dGhpcy5faW5maW5pdGUucmVjeWNsZShzY3JvbGxQb3MsIGlzQXBwZW5kKTtcblx0XHR9XG5cblx0XHR2YXIgc2l6ZSA9IHRoaXMuX2dldEVkZ2VWYWx1ZShcImVuZFwiKTtcblxuXHRcdGlzQXBwZW5kICYmIHRoaXMuX3JlbmRlcmVyLnNldENvbnRhaW5lclNpemUoc2l6ZSArIHRoaXMuX3N0YXR1cy5sb2FkaW5nU2l6ZSB8fCAwKTtcblx0XHQhaXNMYXlvdXQgJiYgdGhpcy5fcHJvY2VzcyhfY29uc3RzLlBST0NFU1NJTkcsIGZhbHNlKTtcblxuXHRcdC8vICBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtLmZyb21DYWNoZSBDaGVjayB3aGV0aGVyIHRoZXNlIGl0ZW1zIGFyZSBjYWNoZSBvciBub3QgPGtvPu2VtOuLuSDslYTsnbTthZzrk6TsnbQg7LqQ7Iuc7J247KeAIOyVhOuLjOyngCDtmZXsnbjtlZzri6QuPC9rbz5cblx0XHQvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGxheW91dCBpcyBzdWNjZXNzZnVsbHkgYXJyYW5nZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIGFwcGVuZCgpLCBwcmVwZW5kKCksIG9yIGxheW91dCgpIG1ldGhvZC5cbiAgICogQGtvIOugiOydtOyVhOybgyDrsLDsuZjqsIAg7JmE66OM65CQ7J2EIOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4LiBhcHBlbmQoKSDrqZTshJzrk5zrgpggcHJlcGVuZCgpIOuplOyEnOuTnCwgbGF5b3V0KCkg66mU7ISc65OcIO2YuOy2nCDtm4Qg7Lm065Oc7J2YIOuwsOy5mOqwgCDsmYTro4zrkJDsnYQg65WMIOuwnOyDne2VnOuLpFxuICAgKiBAZXZlbnQgZWcuSW5maW5pdGVHcmlkI2xheW91dENvbXBsZXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW0udGFyZ2V0IFJlYXJyYW5nZWQgY2FyZCBlbGVtZW50czxrbz7snqzrsLDsuZjrkJwg7Lm065OcIOyXmOumrOuovO2KuOuTpDwva28+XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW0uaXNBcHBlbmQgQ2hlY2tzIHdoZXRoZXIgdGhlIGFwcGVuZCgpIG1ldGhvZCBpcyB1c2VkIHRvIGFkZCBhIGNhcmQgZWxlbWVudC4gSXQgcmV0dXJucyB0cnVlIGV2ZW4gdGhvdWdoIHRoZSBsYXlvdXRDb21wbGV0ZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgbGF5b3V0KCkgbWV0aG9kIGlzIGNhbGxlZC4gPGtvPuy5tOuTnCDsl5jrpqzrqLztirjqsIAgYXBwZW5kKCkg66mU7ISc65Oc66GcIOy2lOqwgOuQkOuKlOyngCDtmZXsnbjtlZzri6QuIGxheW91dCgpIOuplOyEnOuTnOqwgCDtmLjstpzrkJwg7ZuEIGxheW91dENvbXBsZXRlIOydtOuypO2KuOqwgCDrsJzsg53tlbTrj4QgJ3RydWUn66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtLmlzU2Nyb2xsIENoZWNrcyB3aGV0aGVyIHNjcm9sbGluZyBoYXMgb2NjdXJyZWQgYWZ0ZXIgdGhlIGFwcGVuZCgpLCBwcmVwZW5kKCksIC4uLiwgZXRjIG1ldGhvZCBpcyBjYWxsZWQgPGtvPmFwcGVuZCwgcHJlbmQg65OxIO2YuOy2nCDtm4Qg7Iqk7YGs66Gk7J20IOyDneqyvOuKlOyngCDtmZXsnbjtlZzri6QuPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLnNjcm9sbFBvcyBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgaW5maW5pdGVHcmlkIGNvbnRhaW5lciBlbGVtZW50LiA8a28+aW5maW5pdGVHcmlkIOy7qO2FjOydtOuEiCDsl5jrpqzrqLztirgg6riw7KSA7J2YIO2YhOyerCDsiqTtgazroaQg7JyE7LmY6rCSPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLm9yZ1Njcm9sbFBvcyBDdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgPGtvPu2YhOyerCDsiqTtgazroaQg7JyE7LmY6rCSPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLnNpemUgVGhlIHNpemUgb2YgY29udGFpbmVyIGVsZW1lbnQgPGtvPuy7qO2FjOydtOuEiCDsl5jrpqzrqLztirjsnZgg7YGs6riwPC9rbz5cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbS5pc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqL1xuXHRcdHRoaXMudHJpZ2dlcihcImxheW91dENvbXBsZXRlXCIsIHtcblx0XHRcdHRhcmdldDogaXRlbXMuY29uY2F0KCksXG5cdFx0XHRpc0FwcGVuZDogaXNBcHBlbmQsXG5cdFx0XHRpc1RydXN0ZWQ6IGlzVHJ1c3RlZCxcblx0XHRcdGlzU2Nyb2xsOiB2aWV3U2l6ZSA8IHdhdGNoZXIuZ2V0Q29udGFpbmVyT2Zmc2V0KCkgKyBzaXplLFxuXHRcdFx0c2Nyb2xsUG9zOiBzY3JvbGxQb3MsXG5cdFx0XHRvcmdTY3JvbGxQb3M6IHdhdGNoZXIuZ2V0T3JnU2Nyb2xsUG9zKCksXG5cdFx0XHRzaXplOiBzaXplXG5cdFx0fSk7XG5cdFx0dGhpcy5faW5maW5pdGUuc2Nyb2xsKHNjcm9sbFBvcywgaXNBcHBlbmQpO1xuXHR9O1xuXG5cdEluZmluaXRlR3JpZC5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gX3Jlc2V0KCkge1xuXHRcdHRoaXMuX3N0YXR1cyA9IHtcblx0XHRcdHByb2Nlc3NpbmdTdGF0dXM6IF9jb25zdHMuSURMRSxcblx0XHRcdGxvYWRpbmdTaXplOiAwXG5cdFx0fTtcblx0fTtcblx0LyoqXG4gICogRGVzdHJveXMgZWxlbWVudHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMgdXNlZCBvbiBhIGdyaWQgbGF5b3V0LlxuICAqIEBrbyDqt7jrpqzrk5wg66CI7J207JWE7JuD7JeQIOyCrOyaqe2VnCDsl5jrpqzrqLztirjsmYAg7IaN7ISxLCDsnbTrsqTtirjrpbwg7ZW07KCc7ZWc64ukXG4gICovXG5cblxuXHRJbmZpbml0ZUdyaWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdHRoaXMub2ZmKCk7XG5cdFx0dGhpcy5faW5maW5pdGUuY2xlYXIoKTtcblx0XHR0aGlzLl93YXRjaGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX2l0ZW1zLmNsZWFyKCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuZGVzdHJveSgpO1xuXHR9O1xuXG5cdHJldHVybiBJbmZpbml0ZUdyaWQ7XG59KF9jb21wb25lbnQyW1wiZGVmYXVsdFwiXSk7XG5cbkluZmluaXRlR3JpZC5WRVJTSU9OID0gXCIzLjMuMVwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEluZmluaXRlR3JpZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEyX187XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gQUxJR05cbnZhciBTVEFSVCA9IF9jb25zdHMuQUxJR04uU1RBUlQsXG4gICAgQ0VOVEVSID0gX2NvbnN0cy5BTElHTi5DRU5URVIsXG4gICAgRU5EID0gX2NvbnN0cy5BTElHTi5FTkQsXG4gICAgSlVTVElGWSA9IF9jb25zdHMuQUxJR04uSlVTVElGWTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFRoZSBHcmlkTGF5b3V0IGlzIGEgbGF5b3V0IHRoYXQgc3RhY2tzIGNhcmRzIHdpdGggdGhlIHNhbWUgd2lkdGggYXMgYSBzdGFjayBvZiBicmlja3MuIEFkanVzdCB0aGUgd2lkdGggb2YgYWxsIGltYWdlcyB0byB0aGUgc2FtZSBzaXplLCBmaW5kIHRoZSBsb3dlc3QgaGVpZ2h0IGNvbHVtbiwgYW5kIGluc2VydCBhIG5ldyBjYXJkLlxuICogQGtvIEdyaWRMYXlvdXTripQg67K964+M7J2EIOyMk+yVhCDsmKzrprAg66qo7JaR7LKY65+8IOuPmeydvO2VnCDrhIjruYTrpbwg6rCA7KeEIOy5tOuTnOulvCDsjJPripQg66CI7J207JWE7JuD7J2064ukLiDrqqjrk6Ag7J2066+47KeA7J2YIOuEiOu5hOulvCDrj5nsnbztlZwg7YGs6riw66GcIOyhsOygle2VmOqzoCwg6rCA7J6lIOuGkuydtOqwgCDrgq7snYAg7Je07J2EIOywvuyVhCDsg4jroZzsmrQg7J2066+47KeA66W8IOyCveyehe2VnOuLpC4g65Sw65287IScIOuwsOy5mOuQnCDsubTrk5wg7IKs7J207JeQIOu5iCDqs7XqsITsnbQg7IOd6riw7KeA64qUIOyViuyngOunjCDrsLDsuZjrkJwg66CI7J207JWE7JuD7J2YIOyVhOuemOyqveydgCDsmrjtiYHrtojtiYHtlbTsp4Tri6QuXG4gKiBAY2xhc3MgZWcuSW5maW5pdGVHcmlkLkdyaWRMYXlvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Qgb2YgZWcuSW5maW5pdGVHcmlkLkdyaWRMYXlvdXQgbW9kdWxlIDxrbz5lZy5JbmZpbml0ZUdyaWQuR3JpZExheW91dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFyZ2luPTBdIE1hcmdpbiB1c2VkIHRvIGNyZWF0ZSBzcGFjZSBhcm91bmQgaXRlbXMgPGtvPuyVhOydtO2FnOuTpCDsgqzsnbTsnZgg6rO16rCEPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaG9yaXpvbnRhbD1mYWxzZV0gRGlyZWN0aW9uIG9mIHRoZSBzY3JvbGwgbW92ZW1lbnQgKGZhbHNlOiB2ZXJ0aWNhbCwgdHJ1ZTogaG9yaXpvbnRhbCkgPGtvPuyKpO2BrOuhpCDsnbTrj5kg67Cp7ZalIChmYWxzZTog7IS466Gc67Cp7ZalLCB0cnVlOiDqsIDroZzrsKntlqUpPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxpZ249U1RBUlRdIEFsaWduIG9mIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbXMgKFNUQVJULCBDRU5URVIsIEVORCwgSlVTVElGWSkgPGtvPuyVhOydtO2FnOuTpOydmCDsnITsuZjsnZgg7KCV66CsIChTVEFSVCwgQ0VOVEVSLCBFTkQsIEpVU1RJRlkpPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXRlbVNpemU9MF0gVGhlIHNpemUgb2YgdGhlIGl0ZW1zLiBJZiBpdCBpcyAwLCBpdCBpcyBjYWxjdWxhdGVkIGFzIHRoZSBzaXplIG9mIHRoZSBmaXJzdCBpdGVtIGluIGl0ZW1zLiA8a28+IOyVhOydtO2FnOydmCDsgqzsnbTspoguIOunjOyVvSDslYTsnbTthZwg7IKs7J207KaI6rCAIDDsnbTrqbQsIOyVhOydtO2FnOuTpOydmCDssqvrsojsp7gg7JWE7J207YWc7J2YIOyCrOydtOymiOuhnCDqs4TsgrDsnbQg65Cc64ukLiA8L2tvPlxuICogQGV4YW1wbGVcbmBgYFxuPHNjcmlwdD5cbnZhciBpZyA9IG5ldyBlZy5JbmZpbml0ZUdyaWQoXCIjZ3JpZFwiLiB7XG5cdGhvcml6b250YWw6IHRydWUsXG59KTtcblxuaWcuc2V0TGF5b3V0KGVnLkluZmluaXRlR3JpZC5HcmlkTGF5b3V0LCB7XG5cdG1hcmdpbjogMTAsXG5cdGFsaWduOiBcInN0YXJ0XCIsXG5cdGl0ZW1TaXplOiAyMDBcbn0pO1xuXG4vLyBvclxuXG52YXIgbGF5b3V0ID0gbmV3IGVnLkluZmluaXRlR3JpZC5HcmlkTGF5b3V0KHtcblx0bWFyZ2luOiAxMCxcblx0YWxpZ246IFwiY2VudGVyXCIsXG5cdGl0ZW1TaXplOiAyMDAsXG5cdGhvcml6b250YWw6IHRydWUsXG59KTtcblxuPC9zY3JpcHQ+XG5gYGBcbiAqKi9cblxudmFyIEdyaWRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIEdyaWRMYXlvdXQoKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyaWRMYXlvdXQpO1xuXG5cdFx0dGhpcy5vcHRpb25zID0gKDAsIF91dGlscy5hc3NpZ25PcHRpb25zKSh7XG5cdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRob3Jpem9udGFsOiBmYWxzZSxcblx0XHRcdGFsaWduOiBTVEFSVCxcblx0XHRcdGl0ZW1TaXplOiAwXG5cdFx0fSwgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0dGhpcy5fY29sdW1uU2l6ZSA9IDA7XG5cdFx0dGhpcy5fY29sdW1uTGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zdHlsZSA9ICgwLCBfdXRpbHMuZ2V0U3R5bGVOYW1lcykodGhpcy5vcHRpb25zLmhvcml6b250YWwpO1xuXHR9XG5cblx0R3JpZExheW91dC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzKG91dGxpbmVzKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiO1xuXG5cdFx0cmV0dXJuIG91dGxpbmVzLm1hcChmdW5jdGlvbiAob3V0bGluZSkge1xuXHRcdFx0cmV0dXJuIG91dGxpbmVbcG9zXTtcblx0XHR9KTtcblx0fTtcblxuXHRHcmlkTGF5b3V0LnByb3RvdHlwZS5jaGVja0NvbHVtbiA9IGZ1bmN0aW9uIGNoZWNrQ29sdW1uKGl0ZW0pIHtcblx0XHR2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0ICAgIGl0ZW1TaXplID0gX29wdGlvbnMuaXRlbVNpemUsXG5cdFx0ICAgIG1hcmdpbiA9IF9vcHRpb25zLm1hcmdpbixcblx0XHQgICAgaG9yaXpvbnRhbCA9IF9vcHRpb25zLmhvcml6b250YWw7XG5cblx0XHR2YXIgc2l6ZU5hbWUgPSBob3Jpem9udGFsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcblx0XHR2YXIgY29sdW1uU2l6ZSA9IGl0ZW1TaXplIHx8IGl0ZW0gJiYgaXRlbS5zaXplW3NpemVOYW1lXSB8fCAwO1xuXG5cdFx0dGhpcy5fY29sdW1uU2l6ZSA9IGNvbHVtblNpemU7XG5cdFx0aWYgKCFjb2x1bW5TaXplKSB7XG5cdFx0XHR0aGlzLl9jb2x1bW5MZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9jb2x1bW5MZW5ndGggPSBNYXRoLm1heChwYXJzZUludCgodGhpcy5fc2l6ZSArIG1hcmdpbikgLyAoY29sdW1uU2l6ZSArIG1hcmdpbiksIDEwKSwgMSk7XG5cdH07XG5cblx0R3JpZExheW91dC5wcm90b3R5cGUuX2xheW91dCA9IGZ1bmN0aW9uIF9sYXlvdXQoaXRlbXMsIG91dGxpbmUsIGlzQXBwZW5kKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblx0XHR2YXIgbWFyZ2luID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcblx0XHR2YXIgYWxpZ24gPSB0aGlzLm9wdGlvbnMuYWxpZ247XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cblx0XHR2YXIgc2l6ZTFOYW1lID0gc3R5bGUuc2l6ZTE7XG5cdFx0dmFyIHNpemUyTmFtZSA9IHN0eWxlLnNpemUyO1xuXHRcdHZhciBwb3MxTmFtZSA9IHN0eWxlLnBvczE7XG5cdFx0dmFyIHBvczJOYW1lID0gc3R5bGUucG9zMjtcblx0XHR2YXIgY29sdW1uU2l6ZSA9IHRoaXMuX2NvbHVtblNpemU7XG5cdFx0dmFyIGNvbHVtbkxlbmd0aCA9IHRoaXMuX2NvbHVtbkxlbmd0aDtcblxuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHR2YXIgdmlld0Rpc3QgPSBzaXplIC0gKGNvbHVtblNpemUgKyBtYXJnaW4pICogY29sdW1uTGVuZ3RoICsgbWFyZ2luO1xuXG5cdFx0dmFyIHBvaW50Q2FjdWxhdGVOYW1lID0gaXNBcHBlbmQgPyBcIm1pblwiIDogXCJtYXhcIjtcblx0XHR2YXIgc3RhcnRPdXRsaW5lID0gb3V0bGluZS5zbGljZSgpO1xuXHRcdHZhciBlbmRPdXRsaW5lID0gb3V0bGluZS5zbGljZSgpO1xuXHRcdHZhciBzdGFydEluZGV4ID0gMDtcblx0XHR2YXIgZW5kSW5kZXggPSAtMTtcblx0XHR2YXIgZW5kUG9zID0gLTE7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgX2l0ZW0kcmVjdDtcblxuXHRcdFx0dmFyIHBvaW50ID0gTWF0aFtwb2ludENhY3VsYXRlTmFtZV0uYXBwbHkoTWF0aCwgZW5kT3V0bGluZSkgfHwgMDtcblx0XHRcdHZhciBpbmRleCA9IGVuZE91dGxpbmUuaW5kZXhPZihwb2ludCk7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2lzQXBwZW5kID8gaSA6IGxlbmd0aCAtIDEgLSBpXTtcblx0XHRcdHZhciBzaXplMSA9IGl0ZW0uc2l6ZVtzaXplMU5hbWVdO1xuXHRcdFx0dmFyIHNpemUyID0gaXRlbS5zaXplW3NpemUyTmFtZV07XG5cdFx0XHR2YXIgcG9zMSA9IGlzQXBwZW5kID8gcG9pbnQgOiBwb2ludCAtIG1hcmdpbiAtIHNpemUxO1xuXHRcdFx0dmFyIGVuZFBvczEgPSBwb3MxICsgc2l6ZTEgKyBtYXJnaW47XG5cblx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBvczIgPSAoY29sdW1uU2l6ZSArIG1hcmdpbikgKiBpbmRleDtcblxuXHRcdFx0Ly8gQUxJR05cblx0XHRcdGlmIChhbGlnbiA9PT0gQ0VOVEVSKSB7XG5cdFx0XHRcdHBvczIgKz0gdmlld0Rpc3QgLyAyO1xuXHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gRU5EKSB7XG5cdFx0XHRcdHBvczIgKz0gdmlld0Rpc3QgKyBjb2x1bW5TaXplIC0gc2l6ZTI7XG5cdFx0XHR9IGVsc2UgaWYgKGFsaWduID09PSBKVVNUSUZZKSB7XG5cdFx0XHRcdGlmIChjb2x1bW5MZW5ndGggPD0gMSkge1xuXHRcdFx0XHRcdHBvczIgKz0gdmlld0Rpc3QgLyAyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBvczIgPSAoc2l6ZSAtIGNvbHVtblNpemUpIC8gKGNvbHVtbkxlbmd0aCAtIDEpICogaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHRldHJpc1xuXHRcdFx0aXRlbS5yZWN0ID0gKF9pdGVtJHJlY3QgPSB7fSwgX2l0ZW0kcmVjdFtwb3MxTmFtZV0gPSBwb3MxLCBfaXRlbSRyZWN0W3BvczJOYW1lXSA9IHBvczIsIF9pdGVtJHJlY3QpO1xuXHRcdFx0aXRlbS5jb2x1bW4gPSBpbmRleDtcblx0XHRcdGVuZE91dGxpbmVbaW5kZXhdID0gaXNBcHBlbmQgPyBlbmRQb3MxIDogcG9zMTtcblx0XHRcdGlmIChlbmRJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0ZW5kSW5kZXggPSBpO1xuXHRcdFx0XHRlbmRQb3MgPSBlbmRQb3MxO1xuXHRcdFx0fSBlbHNlIGlmIChlbmRQb3MgPCBlbmRQb3MxKSB7XG5cdFx0XHRcdGVuZEluZGV4ID0gaTtcblx0XHRcdFx0ZW5kUG9zID0gZW5kUG9zMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFpc0FwcGVuZCkge1xuXHRcdFx0aXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHR2YXIgaXRlbTFwb3MxID0gYS5yZWN0W3BvczFOYW1lXTtcblx0XHRcdFx0dmFyIGl0ZW0xcG9zMiA9IGEucmVjdFtwb3MyTmFtZV07XG5cdFx0XHRcdHZhciBpdGVtMnBvczEgPSBiLnJlY3RbcG9zMU5hbWVdO1xuXHRcdFx0XHR2YXIgaXRlbTJwb3MyID0gYi5yZWN0W3BvczJOYW1lXTtcblxuXHRcdFx0XHRpZiAoaXRlbTFwb3MxIC0gaXRlbTJwb3MxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0xcG9zMSAtIGl0ZW0ycG9zMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gaXRlbTFwb3MyIC0gaXRlbTJwb3MyO1xuXHRcdFx0fSk7XG5cdFx0XHRlbmRJbmRleCA9IGxlbmd0aCAtIDE7XG5cdFx0fVxuXHRcdC8vIGlmIGFwcGVuZCBpdGVtcywgc3RhcnRPdXRsaW5lIGlzIGxvdywgZW5kT3V0bGluZSBpcyBoaWdoXG5cdFx0Ly8gaWYgcHJlcGVuZCBpdGVtcywgc3RhcnRPdXRsaW5lIGlzIGhpZ2gsIGVuZE91dGxpbmUgaXMgbG93XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBpc0FwcGVuZCA/IHN0YXJ0T3V0bGluZSA6IGVuZE91dGxpbmUsXG5cdFx0XHRlbmQ6IGlzQXBwZW5kID8gZW5kT3V0bGluZSA6IHN0YXJ0T3V0bGluZSxcblx0XHRcdHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG5cdFx0XHRlbmRJbmRleDogZW5kSW5kZXhcblx0XHR9O1xuXHR9O1xuXG5cdEdyaWRMYXlvdXQucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiBfaW5zZXJ0KCkge1xuXHRcdHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cdFx0dmFyIG91dGxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXHRcdHZhciB0eXBlID0gYXJndW1lbnRzWzJdO1xuXG5cdFx0dmFyIGNsb25lID0gKDAsIF91dGlscy5jbG9uZUl0ZW1zKShpdGVtcyk7XG5cblx0XHR2YXIgc3RhcnRPdXRsaW5lID0gb3V0bGluZTtcblxuXHRcdGlmICghdGhpcy5fY29sdW1uTGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmNoZWNrQ29sdW1uKGl0ZW1zWzBdKTtcblx0XHR9XG5cdFx0aWYgKG91dGxpbmUubGVuZ3RoICE9PSB0aGlzLl9jb2x1bW5MZW5ndGgpIHtcblx0XHRcdHN0YXJ0T3V0bGluZSA9ICgwLCBfdXRpbHMuZmlsbCkobmV3IEFycmF5KHRoaXMuX2NvbHVtbkxlbmd0aCksIG91dGxpbmUubGVuZ3RoID09PSAwID8gMCA6IE1hdGhbdHlwZSA9PT0gX2NvbnN0cy5BUFBFTkQgPyBcIm1pblwiIDogXCJtYXhcIl0uYXBwbHkoTWF0aCwgb3V0bGluZSkgfHwgMCk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMuX2xheW91dChjbG9uZSwgc3RhcnRPdXRsaW5lLCB0eXBlKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpdGVtczogY2xvbmUsXG5cdFx0XHRvdXRsaW5lczogcmVzdWx0XG5cdFx0fTtcblx0fTtcblx0LyoqXG4gICogQWRkcyBpdGVtcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g7JWE7J207YWc65Ok7J2EIOyVhOybg+udvOyduCDslYTrnpjsl5Ag7LaU6rCA7ZWc64ukLlxuICAqIEBtZXRob2QgZWcuSW5maW5pdGVHcmlkLkdyaWRMYXlvdXQjYXBwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMCwgMjAwLCAzMDAsIDQwMF0pO1xuICAqL1xuXG5cblx0R3JpZExheW91dC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGl0ZW1zLCBvdXRsaW5lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc2VydChpdGVtcywgb3V0bGluZSwgX2NvbnN0cy5BUFBFTkQpO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIGF0IHRoZSB0b3Agb2YgYSBvdXRsaW5lLlxuICAqIEBrbyDslYTsnbTthZzsnYQg7JWE7JuD65287J24IOychOyXkCDstpTqsIDtlZzri6QuXG4gICogQG1ldGhvZCBlZy5JbmZpbml0ZUdyaWQuR3JpZExheW91dCNwcmVwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMCwgMjAwLCAzMDAsIDQwMF0pO1xuICAqL1xuXG5cblx0R3JpZExheW91dC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoaXRlbXMsIG91dGxpbmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KGl0ZW1zLCBvdXRsaW5lLCBfY29uc3RzLlBSRVBFTkQpO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIG9mIGdyb3VwcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g6re466O565Ok7J2YIOyVhOydtO2FnOuTpOydhCDslYTsm4Prnbzsnbgg7JWE656Y7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5HcmlkTGF5b3V0I2xheW91dFxuICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwcyBBcnJheSBvZiBncm91cHMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDqt7jro7nrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBvdXRsaW5lIEFycmF5IG9mIG91dGxpbmUgcG9pbnRzIHRvIGJlIHJlZmVyZW5jZSBwb2ludHMgPGtvPuq4sOykgOygkOydtCDrkJjripQg7JWE7JuD65287J24IOygkOuTpOydmCDrsLDsl7Q8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZC5HcmlkTGF5b3V0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGY8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqIEBleGFtcGxlXG4gICogbGF5b3V0LmxheW91dChncm91cHMsIFsxMDAsIDIwMCwgMzAwLCA0MDBdKTtcbiAgKi9cblxuXG5cdEdyaWRMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIGxheW91dCgpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dmFyIGdyb3VwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cdFx0dmFyIG91dGxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG5cdFx0dmFyIGZpcnN0SXRlbSA9IGdyb3Vwcy5sZW5ndGggJiYgZ3JvdXBzWzBdLml0ZW1zLmxlbmd0aCAmJiBncm91cHNbMF0uaXRlbXNbMF0gfHwgMDtcblxuXHRcdHRoaXMuY2hlY2tDb2x1bW4oZmlyc3RJdGVtKTtcblxuXHRcdC8vIGlmIG91dGxpbmVzJyBsZW5ndGggYW5kIGNvbHVtbnMnIGxlbmd0aCBhcmUgbm93IHNhbWUsIHJlLWNhY3VsYXRlIG91dGxpbmVzLlxuXHRcdHZhciBzdGFydE91dGxpbmUgPSB2b2lkIDA7XG5cblx0XHRpZiAob3V0bGluZS5sZW5ndGggIT09IHRoaXMuX2NvbHVtbkxlbmd0aCkge1xuXHRcdFx0dmFyIHBvcyA9IG91dGxpbmUubGVuZ3RoID09PSAwID8gMCA6IE1hdGgubWluLmFwcGx5KE1hdGgsIG91dGxpbmUpO1xuXG5cdFx0XHQvLyByZS1sYXlvdXQgaXRlbXMuXG5cdFx0XHRzdGFydE91dGxpbmUgPSAoMCwgX3V0aWxzLmZpbGwpKG5ldyBBcnJheSh0aGlzLl9jb2x1bW5MZW5ndGgpLCBwb3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydE91dGxpbmUgPSBvdXRsaW5lLnNsaWNlKCk7XG5cdFx0fVxuXHRcdGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXM7XG5cdFx0XHR2YXIgcmVzdWx0ID0gX3RoaXMuX2xheW91dChpdGVtcywgc3RhcnRPdXRsaW5lLCBfY29uc3RzLkFQUEVORCk7XG5cblx0XHRcdGdyb3VwLm91dGxpbmVzID0gcmVzdWx0O1xuXHRcdFx0c3RhcnRPdXRsaW5lID0gcmVzdWx0LmVuZDtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHQvKipcbiAgKiBTZXQgdGhlIHZpZXdwb3J0IHNpemUgb2YgdGhlIGxheW91dC5cbiAgKiBAa28g66CI7J207JWE7JuD7J2YIOqwgOyLnCDsgqzsnbTspojrpbwg7ISk7KCV7ZWc64ukLlxuICAqIEBtZXRob2QgZWcuSW5maW5pdGVHcmlkLkdyaWRMYXlvdXQjc2V0U2l6ZVxuICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFRoZSB2aWV3cG9ydCBzaXplIG9mIGNvbnRhaW5lciBhcmVhIHdoZXJlIGl0ZW1zIGFyZSBhZGRlZCB0byBhIGxheW91dCA8a28+66CI7J207JWE7JuD7JeQIOyVhOydtO2FnOydhCDstpTqsIDtlZjripQg7Luo7YWM7J2064SIIOyYgeyXreydmCDqsIDsi5wg7IKs7J207KaIPC9rbz5cbiAgKiBAcmV0dXJuIHtlZy5JbmZpbml0ZUdyaWQuR3JpZExheW91dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAZXhhbXBsZVxuICAqIGxheW91dC5zZXRTaXplKDgwMCk7XG4gICovXG5cblxuXHRHcmlkTGF5b3V0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZShzaXplKSB7XG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cmV0dXJuIEdyaWRMYXlvdXQ7XG59KCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gR3JpZExheW91dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9GcmFtZUxheW91dDIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX0ZyYW1lTGF5b3V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZyYW1lTGF5b3V0Mik7XG5cbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBtYWtlU2hhcGVPdXRsaW5lKG91dGxpbmUsIGl0ZW1TaXplLCBjb2x1bW5MZW5ndGgsIGlzQXBwZW5kKSB7XG5cdHZhciBwb2ludCA9IE1hdGhbaXNBcHBlbmQgPyBcIm1pblwiIDogXCJtYXhcIl0uYXBwbHkoTWF0aCwgb3V0bGluZSkgfHwgMDtcblxuXHRpZiAob3V0bGluZS5sZW5ndGggIT09IGNvbHVtbkxlbmd0aCkge1xuXHRcdHJldHVybiAoMCwgX3V0aWxzLmZpbGwpKG5ldyBBcnJheShjb2x1bW5MZW5ndGgpLCAwKTtcblx0fVxuXHRyZXR1cm4gb3V0bGluZS5tYXAoZnVuY3Rpb24gKGwpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQoKGwgLSBwb2ludCkgLyBpdGVtU2l6ZSwgMTApO1xuXHR9KTtcbn1cbmZ1bmN0aW9uIGdldENvbHVtbihpdGVtKSB7XG5cdGlmIChpdGVtLmNvbHVtbikge1xuXHRcdHJldHVybiBpdGVtLmNvbHVtbjtcblx0fVxuXHR2YXIgY29sdW1uID0gMDtcblxuXHRpZiAoaXRlbS5lbCkge1xuXHRcdHZhciBkYXRhc2V0ID0gaXRlbS5lbC5kYXRhc2V0O1xuXG5cdFx0aWYgKGRhdGFzZXQpIHtcblx0XHRcdGNvbHVtbiA9IGRhdGFzZXQuY29sdW1uIHx8IDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbHVtbiA9IGl0ZW0uZWwuZ2V0QXR0cmlidXRlKFwiY29sdW1uXCIpIHx8IDE7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGNvbHVtbiA9IDE7XG5cdH1cblx0aXRlbS5jb2x1bW4gPSBjb2x1bW47XG5cdHJldHVybiBjb2x1bW47XG59XG5cbi8qKlxuICogQGNsYXNzZGVzYyBTcXVhcmVMYXlvdXQgaXMgYSBsYXlvdXQgdGhhdCBwbGFjZXMgYWxsIGNhcmRzIGxpa2Ugc3F1YXJlcyBvbiBhIGNoZWNrZXJib2FyZCwgYW5kIGltcG9ydGFudCBjYXJkcyBhcmUgbiB0aW1lcyBsYXJnZXIuIFRoZSBtYWluIGNhcmQgY2FuIGJlIGVubGFyZ2VkLCBhbmQgdGhlbiBhIHNtYWxsIGNhcmQgY2FuIGJlIHBsYWNlZCB0byBuYXR1cmFsbHkgc2hvdyB0aGUgcmVsYXRpb25zaGlwIG9mIHRoZSBjYXJkLlxuICogQGtvIFNxdWFyZUxheW91dOydgCDrsJTrkZHtjJDsspjrn7wg66qo65OgIOy5tOuTnOulvCDsoJXsgqzqsIHtmJXsnLzroZwg67Cw7LmY7ZWY6rOgIOykkeyalO2VnCDsubTrk5zripQg7YGs6riw66W8IE7rsLDroZwg7YKk7JuM7IScIOuztOyXrOyjvOuKlCDroIjsnbTslYTsm4PsnbTri6QuIOyjvOyalCDsubTrk5zrpbwg7YGs6rKMIO2RnOyLnO2VmOqzoCwg6re4IOuLpOydjOyXkCDsnpHsnYAg7Lm065Oc66W8IOuwsOy5mO2VtCDsnpDsl7DsiqTrn73qsowg7Lm065Oc7J2YIOq0gOqzhOulvCDrgpjtg4Drgrwg7IiYIOyeiOyKteuLiOuLpC5cbiAqIEBjbGFzcyBlZy5JbmZpbml0ZUdyaWQuU3F1YXJlTGF5b3V0XG4gKiBAZXh0ZW5kcyBlZy5JbmZpbml0ZUdyaWQuRnJhbWVMYXlvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Qgb2YgZWcuSW5maW5pdGVHcmlkLlNxdWFyZUxheW91dCBtb2R1bGUgPGtvPmVnLkluZmluaXRlR3JpZC5TcXVhcmVMYXlvdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrQ8L2tvPlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1hcmdpbj0wXSBNYXJnaW4gdXNlZCB0byBjcmVhdGUgc3BhY2UgYXJvdW5kIGl0ZW1zIDxrbz7slYTsnbTthZzrk6Qg7IKs7J207J2YIOqzteqwhDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmhvcml6b250YWw9ZmFsc2VdIERpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsIG1vdmVtZW50IChmYWxzZTogdmVydGljYWwsIHRydWU6IGhvcml6b250YWwpIDxrbz7siqTtgazroaQg7J2064+ZIOuwqe2WpSAoZmFsc2U6IOyEuOuhnOuwqe2WpSwgdHJ1ZTog6rCA66Gc67Cp7ZalKTwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLml0ZW1TaXplPTBdIFRoZSBzaXplIG9mIHRoZSBpdGVtcy4gSWYgaXQgaXMgMCwgaXQgaXMgY2FsY3VsYXRlZCBhcyB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgaXRlbSBpbiBpdGVtcy4gPGtvPiDslYTsnbTthZzsnZgg7IKs7J207KaILiDrp4zslb0g7JWE7J207YWcIOyCrOydtOymiOqwgCAw7J2066m0LCDslYTsnbTthZzrk6TsnZgg7LKr67KI7Ke4IOyVhOydtO2FnOydmCDsgqzsnbTspojroZwg6rOE7IKw7J20IOuQnOuLpC4gPC9rbz5cbiAqIEBleGFtcGxlXG5gYGBcbjxzY3JpcHQ+XG52YXIgaWcgPSBuZXcgZWcuSW5maW5pdGVHcmlkKFwiI2dyaWRcIi4ge1xuXHRob3Jpem9udGFsOiB0cnVlLFxufSk7XG5cbmlnLnNldExheW91dChlZy5JbmZpbml0ZUdyaWQuU3F1YXJlTGF5b3V0LCB7XG5cdG1hcmdpbjogMTAsXG5cdGl0ZW1TaXplOiAyMDAsXG59KTtcblxuLy8gb3JcblxudmFyIGxheW91dCA9IG5ldyBlZy5JbmZpbml0ZUdyaWQuU3F1YXJlTGF5b3V0KHtcblx0bWFyZ2luOiAxMCxcblx0aXRlbVNpemU6IDIwMCxcblx0aG9yaXpvbnRhbDogdHJ1ZSxcbn0pO1xuXG5cbnZhciBpdGVtMSA9ICc8ZGl2IGRhdGEtY29sdW1uPVwiMlwiPjwvZGl2Pic7XG52YXIgaXRlbTIgPSBcIjxkaXY+PC9kaXY+XCJcbmxheW91dC5hcHBlbmQoW2l0ZW0xLCBpdGVtMl0pO1xuPC9zY3JpcHQ+XG5gYGBcbiAqKi9cblxudmFyIFNxdWFyZUxheW91dCA9IGZ1bmN0aW9uIChfRnJhbWVMYXlvdXQpIHtcblx0X2luaGVyaXRzKFNxdWFyZUxheW91dCwgX0ZyYW1lTGF5b3V0KTtcblxuXHRmdW5jdGlvbiBTcXVhcmVMYXlvdXQoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWFyZUxheW91dCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0ZyYW1lTGF5b3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0U3F1YXJlTGF5b3V0LnByb3RvdHlwZS5fY2hlY2tJdGVtU2l6ZSA9IGZ1bmN0aW9uIF9jaGVja0l0ZW1TaXplKCkge1xuXHRcdHZhciBjb2x1bW4gPSB0aGlzLm9wdGlvbnMuY29sdW1uO1xuXG5cdFx0aWYgKCFjb2x1bW4pIHtcblx0XHRcdF9GcmFtZUxheW91dC5wcm90b3R5cGUuX2NoZWNrSXRlbVNpemUuY2FsbCh0aGlzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG5cblx0XHQvLyBpZiBpdGVtU2l6ZSBpcyBub3QgaW4gb3B0aW9ucywgY2FjdWxhdGUgaXRlbVNpemUgZnJvbSBzaXplLlxuXHRcdHRoaXMuX2l0ZW1TaXplID0gKHRoaXMuX3NpemUgKyBtYXJnaW4pIC8gY29sdW1uIC0gbWFyZ2luO1xuXHR9O1xuXG5cdFNxdWFyZUxheW91dC5wcm90b3R5cGUuX2xheW91dCA9IGZ1bmN0aW9uIF9sYXlvdXQoaXRlbXMpIHtcblx0XHR2YXIgX3NoYXBlcztcblxuXHRcdHZhciBvdXRsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblx0XHR2YXIgaXNBcHBlbmQgPSBhcmd1bWVudHNbMl07XG5cblx0XHR2YXIgaXRlbVNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZSgpO1xuXHRcdHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuXHRcdHZhciBjb2x1bW5MZW5ndGggPSB0aGlzLm9wdGlvbnMuY29sdW1uIHx8IHBhcnNlSW50KCh0aGlzLl9zaXplICsgbWFyZ2luKSAvIChpdGVtU2l6ZSArIG1hcmdpbiksIDEwKSB8fCAxO1xuXHRcdHZhciBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cdFx0dmFyIGVuZE91dGxpbmUgPSBtYWtlU2hhcGVPdXRsaW5lKG91dGxpbmUsIGl0ZW1TaXplLCBjb2x1bW5MZW5ndGgsIGlzQXBwZW5kKTtcblx0XHR2YXIgcG9pbnRDYWN1bGF0ZU5hbWUgPSBpc0FwcGVuZCA/IFwibWluXCIgOiBcIm1heFwiO1xuXHRcdHZhciBzaGFwZXMgPSBbXTtcblx0XHR2YXIgc2lnbiA9IGlzQXBwZW5kID8gMSA6IC0xO1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXHRcdHZhciBwb3MxTmFtZSA9IHN0eWxlLnBvczE7XG5cdFx0dmFyIHBvczJOYW1lID0gc3R5bGUucG9zMjtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBfc2hhcGVzJHB1c2g7XG5cblx0XHRcdHZhciBwb2ludCA9IE1hdGhbcG9pbnRDYWN1bGF0ZU5hbWVdLmFwcGx5KE1hdGgsIGVuZE91dGxpbmUpO1xuXHRcdFx0dmFyIGluZGV4ID0gZW5kT3V0bGluZVtpc0FwcGVuZCA/IFwiaW5kZXhPZlwiIDogXCJsYXN0SW5kZXhPZlwiXShwb2ludCk7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0dmFyIGNvbHVtbldpZHRoID0gaXRlbS5jb2x1bW5XaWR0aDtcblx0XHRcdHZhciBjb2x1bW4gPSBjb2x1bW5XaWR0aCAmJiBjb2x1bW5XaWR0aFswXSA9PT0gY29sdW1uTGVuZ3RoICYmIGNvbHVtbldpZHRoWzFdIHx8IGdldENvbHVtbihpdGVtKTtcblx0XHRcdHZhciBjb2x1bW5Db3VudCA9IDE7XG5cblx0XHRcdGlmIChjb2x1bW4gPiAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAxOyBqIDwgY29sdW1uICYmIChpc0FwcGVuZCAmJiBpbmRleCArIGogPCBjb2x1bW5MZW5ndGggfHwgIWlzQXBwZW5kICYmIGluZGV4IC0gaiA+PSAwKTsgKytqKSB7XG5cdFx0XHRcdFx0aWYgKGlzQXBwZW5kICYmIGVuZE91dGxpbmVbaW5kZXggKyBzaWduICogal0gPD0gcG9pbnQgfHwgIWlzQXBwZW5kICYmIGVuZE91dGxpbmVbaW5kZXggKyBzaWduICogal0gPj0gcG9pbnQpIHtcblx0XHRcdFx0XHRcdCsrY29sdW1uQ291bnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc0FwcGVuZCkge1xuXHRcdFx0XHRcdGluZGV4IC09IGNvbHVtbkNvdW50IC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS5jb2x1bW5XaWR0aCA9IFtjb2x1bW5MZW5ndGgsIGNvbHVtbkNvdW50XTtcblx0XHRcdHNoYXBlcy5wdXNoKChfc2hhcGVzJHB1c2ggPSB7XG5cdFx0XHRcdHdpZHRoOiBjb2x1bW5Db3VudCxcblx0XHRcdFx0aGVpZ2h0OiBjb2x1bW5Db3VudFxuXHRcdFx0fSwgX3NoYXBlcyRwdXNoW3BvczFOYW1lXSA9IHBvaW50IC0gKCFpc0FwcGVuZCA/IGNvbHVtbkNvdW50IDogMCksIF9zaGFwZXMkcHVzaFtwb3MyTmFtZV0gPSBpbmRleCwgX3NoYXBlcyRwdXNoLmluZGV4ID0gaSwgX3NoYXBlcyRwdXNoKSk7XG5cdFx0XHRmb3IgKHZhciBfaiA9IDA7IF9qIDwgY29sdW1uQ291bnQ7ICsrX2opIHtcblx0XHRcdFx0ZW5kT3V0bGluZVtpbmRleCArIF9qXSA9IHBvaW50ICsgc2lnbiAqIGNvbHVtbkNvdW50O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zaGFwZXMgPSAoX3NoYXBlcyA9IHtcblx0XHRcdHNoYXBlczogc2hhcGVzXG5cdFx0fSwgX3NoYXBlc1tzdHlsZS5zaXplMl0gPSBjb2x1bW5MZW5ndGgsIF9zaGFwZXMpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IF9GcmFtZUxheW91dC5wcm90b3R5cGUuX2xheW91dC5jYWxsKHRoaXMsIGl0ZW1zLCBvdXRsaW5lLCBpc0FwcGVuZCk7XG5cblx0XHRpZiAoIWlzQXBwZW5kKSB7XG5cdFx0XHR2YXIgbGFzdEl0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcblxuXHRcdFx0c2hhcGVzLnNvcnQoZnVuY3Rpb24gKHNoYXBlMSwgc2hhcGUyKSB7XG5cdFx0XHRcdHZhciBpdGVtMXBvczEgPSBzaGFwZTFbcG9zMU5hbWVdO1xuXHRcdFx0XHR2YXIgaXRlbTFwb3MyID0gc2hhcGUxW3BvczJOYW1lXTtcblx0XHRcdFx0dmFyIGl0ZW0ycG9zMSA9IHNoYXBlMltwb3MxTmFtZV07XG5cdFx0XHRcdHZhciBpdGVtMnBvczIgPSBzaGFwZTJbcG9zMk5hbWVdO1xuXG5cdFx0XHRcdGlmIChpdGVtMXBvczEgLSBpdGVtMnBvczEpIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbTFwb3MxIC0gaXRlbTJwb3MxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpdGVtMXBvczIgLSBpdGVtMnBvczI7XG5cdFx0XHR9KTtcblx0XHRcdGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0dmFyIGl0ZW0xcG9zMSA9IGEucmVjdFtwb3MxTmFtZV07XG5cdFx0XHRcdHZhciBpdGVtMXBvczIgPSBhLnJlY3RbcG9zMk5hbWVdO1xuXHRcdFx0XHR2YXIgaXRlbTJwb3MxID0gYi5yZWN0W3BvczFOYW1lXTtcblx0XHRcdFx0dmFyIGl0ZW0ycG9zMiA9IGIucmVjdFtwb3MyTmFtZV07XG5cblx0XHRcdFx0aWYgKGl0ZW0xcG9zMSAtIGl0ZW0ycG9zMSkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtMXBvczEgLSBpdGVtMnBvczE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGl0ZW0xcG9zMiAtIGl0ZW0ycG9zMjtcblx0XHRcdH0pO1xuXHRcdFx0cmVzdWx0LnN0YXJ0SW5kZXggPSAwO1xuXHRcdFx0cmVzdWx0LmVuZEluZGV4ID0gaXRlbXMuaW5kZXhPZihsYXN0SXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIFNxdWFyZUxheW91dDtcbn0oX0ZyYW1lTGF5b3V0M1tcImRlZmF1bHRcIl0pO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNxdWFyZUxheW91dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Cb3hNb2RlbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX0JveE1vZGVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0JveE1vZGVsKTtcblxudmFyIF9jb25zdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGdldENvc3Qob3JpZ2luTGVuZ3RoLCBsZW5ndGgpIHtcblx0dmFyIGNvc3QgPSBvcmlnaW5MZW5ndGggLyBsZW5ndGg7XG5cblx0aWYgKGNvc3QgPCAxKSB7XG5cdFx0Y29zdCA9IDEgLyBjb3N0O1xuXHR9XG5cblx0cmV0dXJuIGNvc3QgLSAxO1xufVxuZnVuY3Rpb24gZml0QXJlYShpdGVtLCBiZXN0Rml0QXJlYSwgaXRlbUZpdFNpemUsIGNvbnRhaW5lckZpdFNpemUsIGxheW91dFZlcnRpY2FsKSB7XG5cdGl0ZW0uaGVpZ2h0ID0gaXRlbUZpdFNpemUuaGVpZ2h0O1xuXHRpdGVtLndpZHRoID0gaXRlbUZpdFNpemUud2lkdGg7XG5cdGJlc3RGaXRBcmVhLmhlaWdodCA9IGNvbnRhaW5lckZpdFNpemUuaGVpZ2h0O1xuXHRiZXN0Rml0QXJlYS53aWR0aCA9IGNvbnRhaW5lckZpdFNpemUud2lkdGg7XG5cblx0aWYgKGxheW91dFZlcnRpY2FsKSB7XG5cdFx0aXRlbS50b3AgPSBiZXN0Rml0QXJlYS50b3AgKyBiZXN0Rml0QXJlYS5oZWlnaHQ7XG5cdFx0aXRlbS5sZWZ0ID0gYmVzdEZpdEFyZWEubGVmdDtcblx0fSBlbHNlIHtcblx0XHRpdGVtLmxlZnQgPSBiZXN0Rml0QXJlYS5sZWZ0ICsgYmVzdEZpdEFyZWEud2lkdGg7XG5cdFx0aXRlbS50b3AgPSBiZXN0Rml0QXJlYS50b3A7XG5cdH1cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjIFRoZSBQYWNraW5nTGF5b3V0IGlzIGEgbGF5b3V0IHRoYXQgc2hvd3MgdGhlIGltcG9ydGFudCBjYXJkcyBiaWdnZXIgd2l0aG91dCBzYWNyaWZpY2luZyB0aGUgd2VpZ2h0IG9mIHRoZSBjYXJkcy4gUm93cyBhbmQgY29sdW1ucyBhcmUgc2VwYXJhdGVkIHNvIHRoYXQgY2FyZHMgYXJlIGR5bmFtaWNhbGx5IHBsYWNlZCB3aXRoaW4gdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNwYWNlIHJhdGhlciB0aGFuIGFycmFuZ2VkIGluIGFuIG9yZGVybHkgZmFzaGlvbi5cbiAqIEBrbyBQYWNraW5nTGF5b3V07J2AIOy5tOuTnOydmCDrs7jrnpgg7YGs6riw7JeQIOuUsOuluCDruYTspJHsnYQg7ZW07LmY7KeAIOyViuycvOuptOyEnCDspJHsmpTtlZwg7Lm065Oc64qUIOuNlCDtgazqsowg67O07JesIOyjvOuKlCDroIjsnbTslYTsm4PsnbTri6QuIO2WieqzvCDsl7TsnbQg6rWs67aE64+8IOydtOuvuOyngOulvCDsoJXrj4jrkJjqsowg67Cw7LmY7ZWY64qUIOuMgOyLoCDqsIDroZzshLjroZwg7J287KCVIOqzteqwhCDrgrTsl5DshJwg64+Z7KCB7Jy866GcIOy5tOuTnOulvCDrsLDsuZjtlZzri6QuXG4gKiBAY2xhc3MgZWcuSW5maW5pdGVHcmlkLlBhY2tpbmdMYXlvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Qgb2YgZWcuSW5maW5pdGVHcmlkLlBhY2tpbmdMYXlvdXQgbW9kdWxlIDxrbz5lZy5JbmZpbml0ZUdyaWQuUGFja2luZ0xheW91dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFyZ2luPTBdIE1hcmdpbiB1c2VkIHRvIGNyZWF0ZSBzcGFjZSBhcm91bmQgaXRlbXMgPGtvPuyVhOydtO2FnOuTpCDsgqzsnbTsnZgg6rO16rCEPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaG9yaXpvbnRhbD1mYWxzZV0gRGlyZWN0aW9uIG9mIHRoZSBzY3JvbGwgbW92ZW1lbnQgKGZhbHNlOiB2ZXJ0aWNhbCwgdHJ1ZTogaG9yaXpvbnRhbCkgPGtvPuyKpO2BrOuhpCDsnbTrj5kg67Cp7ZalIChmYWxzZTog7IS466Gc67Cp7ZalLCB0cnVlOiDqsIDroZzrsKntlqUpPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXNwZWN0UmF0aW89MV0gVGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgZ3JvdXAgPGtvPiDqt7jro7nsnZgg6rCA66GcIOyEuOuhnCDruYQgPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2l6ZVdlaWdodD0xXSBUaGUgc2l6ZSB3ZWlnaHQgd2hlbiBwbGFjaW5nIGFuIGltYWdlIDxrbz4g7J2066+47KeA66W8IOuwsOy5mO2VoCDrlYwg7IKs7J207KaIIOqwgOykkey5mCA8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXRpb1dlaWdodD0xXSBUaGUgcmF0aW8gd2VpZ2h0IHdoZW4gcGxhY2luZyBhbiBpbWFnZSA8a28+IOydtOuvuOyngOulvCDrsLDsuZjtlaAg65WMIOu5hOycqCDqsIDspJHsuZggPC9rbz5cbiAqIEBleGFtcGxlXG5gYGBcbjxzY3JpcHQ+XG52YXIgaWcgPSBuZXcgZWcuSW5maW5pdGVHcmlkKFwiI2dyaWRcIi4ge1xuXHRob3Jpem9udGFsOiB0cnVlLFxufSk7XG5cbmlnLnNldExheW91dChlZy5JbmZpbml0ZUdyaWQuUGFja2luZ0xheW91dCwge1xuXHRtYXJnaW46IDEwLFxuXHRhc3BlY3RSYXRpbzogMSxcblx0c2l6ZVdlaWdodDogMSxcblx0cmF0aW9XZWlnaHQ6IDIsXG59KTtcblxuLy8gb3JcblxudmFyIGxheW91dCA9IG5ldyBlZy5JbmZpbml0ZUdyaWQuUGFja2luZ0xheW91dCh7XG5cdGhvcml6b250YWw6IHRydWUsXG5cdG1hcmdpbjogMTAsXG5cdGFzcGVjdFJhdGlvOiAxLFxuXHRzaXplV2VpZ2h0OiAxLFxuXHRyYXRpb1dlaWdodDogMixcbn0pO1xuXG48L3NjcmlwdD5cbmBgYFxuICoqL1xuXG52YXIgUGFja2luZ0xheW91dCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gUGFja2luZ0xheW91dCgpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFja2luZ0xheW91dCk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAoMCwgX3V0aWxzLmFzc2lnbk9wdGlvbnMpKHtcblx0XHRcdG1hcmdpbjogMCxcblx0XHRcdGhvcml6b250YWw6IGZhbHNlLFxuXHRcdFx0YXNwZWN0UmF0aW86IDEsXG5cdFx0XHRzaXplV2VpZ2h0OiAxLFxuXHRcdFx0cmF0aW9XZWlnaHQ6IDFcblx0XHR9LCBvcHRpb25zKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0XHR0aGlzLl9zdHlsZSA9ICgwLCBfdXRpbHMuZ2V0U3R5bGVOYW1lcykodGhpcy5vcHRpb25zLmhvcml6b250YWwpO1xuXHR9XG5cblx0UGFja2luZ0xheW91dC5wcm90b3R5cGUuX2ZpbmRCZXN0Rml0QXJlYSA9IGZ1bmN0aW9uIF9maW5kQmVzdEZpdEFyZWEoY29udGFpbmVyLCBpdGVtKSB7XG5cdFx0aWYgKGNvbnRhaW5lci5nZXRSYXRpbygpID09PSAwKSB7XG5cdFx0XHQvLyDslYTsnbTthZwg7LWc7LSIIOyCveyeheyLnCDsoITssrTsmIHsl60g7KeA7KCVXG5cdFx0XHRjb250YWluZXIub3JpZ2luV2lkdGggPSBpdGVtLndpZHRoO1xuXHRcdFx0Y29udGFpbmVyLm9yaWdpbkhlaWdodCA9IGl0ZW0uaGVpZ2h0O1xuXHRcdFx0Y29udGFpbmVyLndpZHRoID0gaXRlbS53aWR0aDtcblx0XHRcdGNvbnRhaW5lci5oZWlnaHQgPSBpdGVtLmhlaWdodDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYmVzdEZpdEFyZWEgPSBudWxsO1xuXHRcdHZhciBtaW5Db3N0ID0gMTAwMDAwMDA7XG5cdFx0dmFyIGxheW91dFZlcnRpY2FsID0gZmFsc2U7XG5cdFx0dmFyIGl0ZW1GaXRTaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHRcdHZhciBjb250YWluZXJGaXRTaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHRcdHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHQgICAgc2l6ZVdlaWdodCA9IF9vcHRpb25zLnNpemVXZWlnaHQsXG5cdFx0ICAgIHJhdGlvV2VpZ2h0ID0gX29wdGlvbnMucmF0aW9XZWlnaHQ7XG5cblxuXHRcdGNvbnRhaW5lci5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHR2YXIgY29udGFpbmVyU2l6ZUNvc3QgPSBnZXRDb3N0KHYuZ2V0T3JpZ2luU2l6ZSgpLCB2LmdldFNpemUoKSkgKiBzaXplV2VpZ2h0O1xuXHRcdFx0dmFyIGNvbnRhaW5lclJhdGlvQ29zdCA9IGdldENvc3Qodi5nZXRPcmlnaW5SYXRpbygpLCB2LmdldFJhdGlvKCkpICogcmF0aW9XZWlnaHQ7XG5cdFx0XHR2YXIgd2lkdGggPSB2LndpZHRoO1xuXHRcdFx0dmFyIGhlaWdodCA9IHYuaGVpZ2h0O1xuXHRcdFx0dmFyIGNvc3QgPSB2b2lkIDA7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG5cdFx0XHRcdHZhciBpdGVtV2lkdGggPSB2b2lkIDA7XG5cdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gdm9pZCAwO1xuXHRcdFx0XHR2YXIgY29udGFpbmVyV2lkdGggPSB2b2lkIDA7XG5cdFx0XHRcdHZhciBjb250YWluZXJIZWlnaHQgPSB2b2lkIDA7XG5cblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHQvLyDsg4HtlZjsl5Ag7JWE7J207YWcIOy2lOqwgFxuXHRcdFx0XHRcdGl0ZW1XaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRcdGl0ZW1IZWlnaHQgPSBoZWlnaHQgKiAoaXRlbS5oZWlnaHQgLyAodi5vcmlnaW5IZWlnaHQgKyBpdGVtLmhlaWdodCkpO1xuXHRcdFx0XHRcdGNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG5cdFx0XHRcdFx0Y29udGFpbmVySGVpZ2h0ID0gaGVpZ2h0IC0gaXRlbUhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyDsoozsmrDsl5Ag7JWE7J207YWcIOy2lOqwgFxuXHRcdFx0XHRcdGl0ZW1IZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdFx0aXRlbVdpZHRoID0gd2lkdGggKiAoaXRlbS53aWR0aCAvICh2Lm9yaWdpbldpZHRoICsgaXRlbS53aWR0aCkpO1xuXHRcdFx0XHRcdGNvbnRhaW5lckhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0XHRjb250YWluZXJXaWR0aCA9IHdpZHRoIC0gaXRlbVdpZHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGl0ZW1TaXplID0gaXRlbVdpZHRoICogaXRlbUhlaWdodDtcblx0XHRcdFx0dmFyIGl0ZW1SYXRpbyA9IGl0ZW1XaWR0aCAvIGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdHZhciBjb250YWluZXJTaXplID0gY29udGFpbmVyV2lkdGggKiBjb250YWluZXJIZWlnaHQ7XG5cdFx0XHRcdHZhciBjb250YWluZXJSYXRpbyA9IGNvbnRhaW5lckhlaWdodCAvIGNvbnRhaW5lckhlaWdodDtcblxuXHRcdFx0XHRjb3N0ID0gZ2V0Q29zdChpdGVtLmdldFNpemUoKSwgaXRlbVNpemUpICogc2l6ZVdlaWdodDtcblx0XHRcdFx0Y29zdCArPSBnZXRDb3N0KGl0ZW0uZ2V0UmF0aW8oKSwgaXRlbVJhdGlvKSAqIHJhdGlvV2VpZ2h0O1xuXHRcdFx0XHRjb3N0ICs9IGdldENvc3Qodi5nZXRPcmlnaW5TaXplKCksIGNvbnRhaW5lclNpemUpICogc2l6ZVdlaWdodCAtIGNvbnRhaW5lclNpemVDb3N0O1xuXHRcdFx0XHRjb3N0ICs9IGdldENvc3Qodi5nZXRPcmlnaW5SYXRpbygpLCBjb250YWluZXJSYXRpbykgKiByYXRpb1dlaWdodCAtIGNvbnRhaW5lclJhdGlvQ29zdDtcblxuXHRcdFx0XHRpZiAoY29zdCA9PT0gTWF0aC5taW4oY29zdCwgbWluQ29zdCkpIHtcblx0XHRcdFx0XHRtaW5Db3N0ID0gY29zdDtcblx0XHRcdFx0XHRiZXN0Rml0QXJlYSA9IHY7XG5cdFx0XHRcdFx0bGF5b3V0VmVydGljYWwgPSBpID09PSAwO1xuXHRcdFx0XHRcdGl0ZW1GaXRTaXplLndpZHRoID0gaXRlbVdpZHRoO1xuXHRcdFx0XHRcdGl0ZW1GaXRTaXplLmhlaWdodCA9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdFx0Y29udGFpbmVyRml0U2l6ZS53aWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuXHRcdFx0XHRcdGNvbnRhaW5lckZpdFNpemUuaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRmaXRBcmVhKGl0ZW0sIGJlc3RGaXRBcmVhLCBpdGVtRml0U2l6ZSwgY29udGFpbmVyRml0U2l6ZSwgbGF5b3V0VmVydGljYWwpO1xuXHR9O1xuXG5cdFBhY2tpbmdMYXlvdXQucHJvdG90eXBlLl9sYXlvdXQgPSBmdW5jdGlvbiBfbGF5b3V0KGl0ZW1zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHZhciBvdXRsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblx0XHR2YXIgaXNBcHBlbmQgPSBhcmd1bWVudHNbMl07XG5cblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHR2YXIgX29wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuXHRcdCAgICBob3Jpem9udGFsID0gX29wdGlvbnMyLmhvcml6b250YWwsXG5cdFx0ICAgIGFzcGVjdFJhdGlvID0gX29wdGlvbnMyLmFzcGVjdFJhdGlvLFxuXHRcdCAgICBtYXJnaW4gPSBfb3B0aW9uczIubWFyZ2luO1xuXG5cdFx0dmFyIHBvczFOYW1lID0gc3R5bGUucG9zMTtcblx0XHR2YXIgc2l6ZTFOYW1lID0gc3R5bGUuc2l6ZTE7XG5cdFx0dmFyIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fc2l6ZSAqIChob3Jpem9udGFsID8gYXNwZWN0UmF0aW8gOiAxKTtcblx0XHR2YXIgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fc2l6ZSAvIChob3Jpem9udGFsID8gMSA6IGFzcGVjdFJhdGlvKTtcblx0XHR2YXIgY29udGFpbmVyU2l6ZTEgPSBob3Jpem9udGFsID8gY29udGFpbmVyV2lkdGggOiBjb250YWluZXJIZWlnaHQ7XG5cdFx0dmFyIHByZXZPdXRsaW5lID0gKDAsIF91dGlscy50b1plcm9BcnJheSkob3V0bGluZSk7XG5cdFx0dmFyIHN0YXJ0ID0gaXNBcHBlbmQgPyBNYXRoLm1heC5hcHBseShNYXRoLCBwcmV2T3V0bGluZSkgOiBNYXRoLm1pbi5hcHBseShNYXRoLCBwcmV2T3V0bGluZSkgLSBjb250YWluZXJTaXplMSAtIG1hcmdpbjtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyBjb250YWluZXJTaXplMSArIG1hcmdpbjtcblx0XHR2YXIgY29udGFpbmVyID0gbmV3IF9Cb3hNb2RlbDJbXCJkZWZhdWx0XCJdKHt9KTtcblx0XHR2YXIgc3RhcnRJbmRleCA9IC0xO1xuXHRcdHZhciBlbmRJbmRleCA9IC0xO1xuXHRcdHZhciBzdGFydFBvcyA9IC0xO1xuXHRcdHZhciBlbmRQb3MgPSAtMTtcblxuXHRcdGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBfaXRlbSRvcmdTaXplID0gaXRlbS5vcmdTaXplLFxuXHRcdFx0ICAgIHdpZHRoID0gX2l0ZW0kb3JnU2l6ZS53aWR0aCxcblx0XHRcdCAgICBoZWlnaHQgPSBfaXRlbSRvcmdTaXplLmhlaWdodDtcblxuXHRcdFx0dmFyIG1vZGVsID0gbmV3IF9Cb3hNb2RlbDJbXCJkZWZhdWx0XCJdKHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0b3JpZ2luV2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRvcmlnaW5IZWlnaHQ6IGhlaWdodFxuXHRcdFx0fSk7XG5cblx0XHRcdF90aGlzLl9maW5kQmVzdEZpdEFyZWEoY29udGFpbmVyLCBtb2RlbCk7XG5cdFx0XHRjb250YWluZXIucHVzaChtb2RlbCk7XG5cdFx0XHRjb250YWluZXIuc2NhbGVUbyhjb250YWluZXJXaWR0aCArIG1hcmdpbiwgY29udGFpbmVySGVpZ2h0ICsgbWFyZ2luKTtcblx0XHR9KTtcblx0XHRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG5cdFx0XHR2YXIgYm94SXRlbSA9IGNvbnRhaW5lci5pdGVtc1tpXTtcblx0XHRcdHZhciB3aWR0aCA9IGJveEl0ZW0ud2lkdGg7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gYm94SXRlbS5oZWlnaHQ7XG5cdFx0XHR2YXIgdG9wID0gYm94SXRlbS50b3A7XG5cdFx0XHR2YXIgbGVmdCA9IGJveEl0ZW0ubGVmdDtcblxuXHRcdFx0aXRlbS5yZWN0ID0geyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgd2lkdGg6IHdpZHRoIC0gbWFyZ2luLCBoZWlnaHQ6IGhlaWdodCAtIG1hcmdpbiB9O1xuXHRcdFx0aXRlbS5yZWN0W3BvczFOYW1lXSArPSBzdGFydDtcblxuXHRcdFx0aWYgKHN0YXJ0SW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdHN0YXJ0SW5kZXggPSBpO1xuXHRcdFx0XHRlbmRJbmRleCA9IGk7XG5cdFx0XHRcdHN0YXJ0UG9zID0gaXRlbS5yZWN0W3BvczFOYW1lXTtcblx0XHRcdFx0ZW5kUG9zID0gc3RhcnRQb3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RhcnRQb3MgPiBpdGVtLnJlY3RbcG9zMU5hbWVdKSB7XG5cdFx0XHRcdHN0YXJ0UG9zID0gaXRlbS5yZWN0W3BvczFOYW1lXTtcblx0XHRcdFx0c3RhcnRJbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5kUG9zIDwgaXRlbS5yZWN0W3BvczFOYW1lXSArIGl0ZW0ucmVjdFtzaXplMU5hbWVdICsgbWFyZ2luKSB7XG5cdFx0XHRcdGVuZFBvcyA9IGl0ZW0ucmVjdFtwb3MxTmFtZV0gKyBpdGVtLnJlY3Rbc2l6ZTFOYW1lXSArIG1hcmdpbjtcblx0XHRcdFx0ZW5kSW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBbc3RhcnRdLFxuXHRcdFx0ZW5kOiBbZW5kXSxcblx0XHRcdHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG5cdFx0XHRlbmRJbmRleDogZW5kSW5kZXhcblx0XHR9O1xuXHR9O1xuXG5cdFBhY2tpbmdMYXlvdXQucHJvdG90eXBlLl9pbnNlcnQgPSBmdW5jdGlvbiBfaW5zZXJ0KCkge1xuXHRcdHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cdFx0dmFyIG91dGxpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXHRcdHZhciB0eXBlID0gYXJndW1lbnRzWzJdO1xuXG5cdFx0Ly8gdGhpcyBvbmx5IG5lZWRzIHRoZSBzaXplIG9mIHRoZSBpdGVtLlxuXHRcdHZhciBjbG9uZSA9ICgwLCBfdXRpbHMuY2xvbmVJdGVtcykoaXRlbXMpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGl0ZW1zOiBjbG9uZSxcblx0XHRcdG91dGxpbmVzOiB0aGlzLl9sYXlvdXQoY2xvbmUsIG91dGxpbmUsIHR5cGUpXG5cdFx0fTtcblx0fTtcblx0LyoqXG4gICogQWRkcyBpdGVtcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g7JWE7J207YWc65Ok7J2EIOyVhOybg+udvOyduCDslYTrnpjsl5Ag7LaU6rCA7ZWc64ukLlxuICAqIEBtZXRob2QgZWcuSW5maW5pdGVHcmlkLlBhY2tpbmdMYXlvdXQjYXBwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMF0pO1xuICAqL1xuXG5cblx0UGFja2luZ0xheW91dC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGl0ZW1zLCBvdXRsaW5lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc2VydChpdGVtcywgb3V0bGluZSwgX2NvbnN0cy5BUFBFTkQpO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIGF0IHRoZSB0b3Agb2YgYSBvdXRsaW5lLlxuICAqIEBrbyDslYTsnbTthZzsnYQg7JWE7JuD65287J24IOychOyXkCDstpTqsIDtlZzri6QuXG4gICogQG1ldGhvZCBlZy5JbmZpbml0ZUdyaWQuUGFja2luZ0xheW91dCNwcmVwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMF0pO1xuICAqL1xuXG5cblx0UGFja2luZ0xheW91dC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoaXRlbXMsIG91dGxpbmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KGl0ZW1zLCBvdXRsaW5lLCBfY29uc3RzLlBSRVBFTkQpO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIG9mIGdyb3VwcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g6re466O565Ok7J2YIOyVhOydtO2FnOuTpOydhCDslYTsm4Prnbzsnbgg7JWE656Y7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5QYWNraW5nTGF5b3V0I2xheW91dFxuICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwcyBBcnJheSBvZiBncm91cHMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDqt7jro7nrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBvdXRsaW5lIEFycmF5IG9mIG91dGxpbmUgcG9pbnRzIHRvIGJlIHJlZmVyZW5jZSBwb2ludHMgPGtvPuq4sOykgOygkOydtCDrkJjripQg7JWE7JuD65287J24IOygkOuTpOydmCDrsLDsl7Q8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZC5QYWNraW5nTGF5b3V0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGY8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqIEBleGFtcGxlXG4gICogbGF5b3V0LmxheW91dChncm91cHMsIFsxMDAsIDIwMCwgMzAwLCA0MDBdKTtcbiAgKi9cblxuXG5cdFBhY2tpbmdMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIGxheW91dCgpIHtcblx0XHR2YXIgZ3JvdXBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblx0XHR2YXIgb3V0bGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cblx0XHR2YXIgbGVuZ3RoID0gZ3JvdXBzLmxlbmd0aDtcblx0XHR2YXIgcG9pbnQgPSBvdXRsaW5lO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuXG5cdFx0XHRwb2ludCA9IHRoaXMuX2xheW91dChncm91cC5pdGVtcywgcG9pbnQsIF9jb25zdHMuQVBQRU5EKTtcblx0XHRcdGdyb3VwLm91dGxpbmVzID0gcG9pbnQ7XG5cdFx0XHRwb2ludCA9IHBvaW50LmVuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuICAqIFNldCB0aGUgdmlld3BvcnQgc2l6ZSBvZiB0aGUgbGF5b3V0LlxuICAqIEBrbyDroIjsnbTslYTsm4PsnZgg6rCA7IucIOyCrOydtOymiOulvCDshKTsoJXtlZzri6QuXG4gICogQG1ldGhvZCBlZy5JbmZpbml0ZUdyaWQuUGFja2luZ0xheW91dCNzZXRTaXplXG4gICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIHZpZXdwb3J0IHNpemUgb2YgY29udGFpbmVyIGFyZWEgd2hlcmUgaXRlbXMgYXJlIGFkZGVkIHRvIGEgbGF5b3V0IDxrbz7roIjsnbTslYTsm4Psl5Ag7JWE7J207YWc7J2EIOy2lOqwgO2VmOuKlCDsu6jthYzsnbTrhIgg7JiB7Jet7J2YIOqwgOyLnCDsgqzsnbTspog8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZC5QYWNraW5nTGF5b3V0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGY8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAqIEBleGFtcGxlXG4gICogbGF5b3V0LnNldFNpemUoODAwKTtcbiAgKi9cblxuXG5cdFBhY2tpbmdMYXlvdXQucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplKHNpemUpIHtcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gUGFja2luZ0xheW91dDtcbn0oKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQYWNraW5nTGF5b3V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQm94TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIEJveE1vZGVsKG9wdGlvbnMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94TW9kZWwpO1xuXG5cdFx0X2V4dGVuZHModGhpcywge1xuXHRcdFx0b3JpZ2luV2lkdGg6IDAsXG5cdFx0XHRvcmlnaW5IZWlnaHQ6IDAsXG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRpdGVtczogW11cblx0XHR9LCBvcHRpb25zKTtcblx0fVxuXG5cdEJveE1vZGVsLnByb3RvdHlwZS5zY2FsZVRvID0gZnVuY3Rpb24gc2NhbGVUbyh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIHNjYWxlWCA9IHRoaXMud2lkdGggPyB3aWR0aCAvIHRoaXMud2lkdGggOiAwO1xuXHRcdHZhciBzY2FsZVkgPSB0aGlzLmhlaWdodCA/IGhlaWdodCAvIHRoaXMuaGVpZ2h0IDogMDtcblxuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuXHRcdFx0aWYgKHNjYWxlWCAhPT0gMCkge1xuXHRcdFx0XHR2LmxlZnQgKj0gc2NhbGVYO1xuXHRcdFx0XHR2LndpZHRoICo9IHNjYWxlWDtcblx0XHRcdH1cblx0XHRcdGlmIChzY2FsZVkgIT09IDApIHtcblx0XHRcdFx0di50b3AgKj0gc2NhbGVZO1xuXHRcdFx0XHR2LmhlaWdodCAqPSBzY2FsZVk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdH07XG5cblx0Qm94TW9kZWwucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcblx0XHR0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG5cdH07XG5cblx0Qm94TW9kZWwucHJvdG90eXBlLmdldE9yaWdpblNpemUgPSBmdW5jdGlvbiBnZXRPcmlnaW5TaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm9yaWdpbldpZHRoICogdGhpcy5vcmlnaW5IZWlnaHQ7XG5cdH07XG5cblx0Qm94TW9kZWwucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG5cdH07XG5cblx0Qm94TW9kZWwucHJvdG90eXBlLmdldE9yaWdpblJhdGlvID0gZnVuY3Rpb24gZ2V0T3JpZ2luUmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IHRoaXMub3JpZ2luV2lkdGggLyB0aGlzLm9yaWdpbkhlaWdodDtcblx0fTtcblxuXHRCb3hNb2RlbC5wcm90b3R5cGUuZ2V0UmF0aW8gPSBmdW5jdGlvbiBnZXRSYXRpbygpIHtcblx0XHRyZXR1cm4gdGhpcy5oZWlnaHQgPT09IDAgPyAwIDogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuXHR9O1xuXG5cdHJldHVybiBCb3hNb2RlbDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3hNb2RlbDtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZGlqa3N0cmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9kaWprc3RyYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaWprc3RyYSk7XG5cbnZhciBfY29uc3RzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBjbGFzc2Rlc2MgJ2p1c3RpZmllZCcgaXMgYSBwcmludGluZyB0ZXJtIHdpdGggdGhlIG1lYW5pbmcgdGhhdCAnaXQgZml0cyBpbiBvbmUgcm93IHdpZGUnLiBKdXN0aWZpZWRMYXlvdXQgaXMgYSBsYXlvdXQgdGhhdCB0aGUgY2FyZCBpcyBmaWxsZWQgdXAgb24gdGhlIGJhc2lzIG9mIGEgbGluZSBnaXZlbiBhIHNpemUuXG4gKiBAa28gJ2p1c3RpZmllZCfripQgJzHtlonsnZgg64SI67mE7JeQIOunnuqyjCDqvK0g65Ok7Ja07LCsJ+ydtOudvOuKlCDsnZjrr7jrpbwg6rCA7KeEIOyduOyHhCDsmqnslrTri6QuIOyaqeyWtOydmCDsnZjrr7jrjIDroZwg64SI67mE6rCAIOyjvOyWtOynhCDsgqzsnbTspojrpbwg6riw7KSA7Jy866GcIOy5tOuTnOqwgCDqsIDrk50g7LCo64+E66GdIOuwsOy5mO2VmOuKlCDroIjsnbTslYTsm4PsnbTri6QuXG4gKiBAY2xhc3MgZWcuSW5maW5pdGVHcmlkLkp1c3RpZmllZExheW91dFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdCBvZiBlZy5JbmZpbml0ZUdyaWQuSnVzdGlmaWVkTGF5b3V0IG1vZHVsZSA8a28+ZWcuSW5maW5pdGVHcmlkLkp1c3RpZmllZExheW91dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFyZ2luPTBdIE1hcmdpbiB1c2VkIHRvIGNyZWF0ZSBzcGFjZSBhcm91bmQgaXRlbXMgPGtvPuyVhOydtO2FnOuTpCDsgqzsnbTsnZgg6rO16rCEPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaG9yaXpvbnRhbD1mYWxzZV0gRGlyZWN0aW9uIG9mIHRoZSBzY3JvbGwgbW92ZW1lbnQgKGZhbHNlOiB2ZXJ0aWNhbCwgdHJ1ZTogaG9yaXpvbnRhbCkgPGtvPuyKpO2BrOuhpCDsnbTrj5kg67Cp7ZalIChmYWxzZTog7IS466Gc67Cp7ZalLCB0cnVlOiDqsIDroZzrsKntlqUpPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5TaXplPTBdIE1pbmltdW0gc2l6ZSBvZiBpdGVtIHRvIGJlIHJlc2l6ZWQgPGtvPiDslYTsnbTthZzsnbQg7KGw7KCV65CY64qUIOy1nOyGjCDtgazquLAgPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhTaXplPTBdIE1heGltdW0gc2l6ZSBvZiBpdGVtIHRvIGJlIHJlc2l6ZWQgPGtvPiDslYTsnbTthZzsnbQg7KGw7KCV65CY64qUIOy1nOuMgCDtgazquLAgPC9rbz5cbiAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSBbb3B0aW9ucy5jb2x1bW49WzEsIDhdXSBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIGEgbGluZSA8a28+IO2VnCDspITsl5Ag65Ok7Ja06rCA64qUIOyVhOydtO2FnOydmCDqsJzsiJggPC9rbz5cbiAqIEBleGFtcGxlXG5gYGBcbjxzY3JpcHQ+XG52YXIgaWcgPSBuZXcgZWcuSW5maW5pdGVHcmlkKFwiI2dyaWRcIi4ge1xuXHRob3Jpem9udGFsOiB0cnVlLFxufSk7XG5cbmlnLnNldExheW91dChlZy5JbmZpbml0ZUdyaWQuSnVzdGlmaWVkTGF5b3V0LCB7XG5cdG1hcmdpbjogMTAsXG5cdG1pblNpemU6IDEwMCxcblx0bWF4U2l6ZTogMzAwLFxufSk7XG5cbi8vIG9yXG5cbnZhciBsYXlvdXQgPSBuZXcgZWcuSW5maW5pdGVHcmlkLkp1c3RpZmllZExheW91dCh7XG5cdG1hcmdpbjogMTAsXG5cdG1pblNpemU6IDEwMCxcblx0bWF4U2l6ZTogMzAwLFxuXHRjb2x1bW46IDUsXG5cdGhvcml6b250YWw6IHRydWUsXG59KTtcblxuPC9zY3JpcHQ+XG5gYGBcbiAqKi9cbnZhciBKdXN0aWZpZWRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIEp1c3RpZmllZExheW91dCgpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgSnVzdGlmaWVkTGF5b3V0KTtcblxuXHRcdHRoaXMub3B0aW9ucyA9ICgwLCBfdXRpbHMuYXNzaWduT3B0aW9ucykoe1xuXHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0aG9yaXpvbnRhbDogZmFsc2UsXG5cdFx0XHRtaW5TaXplOiAwLFxuXHRcdFx0bWF4U2l6ZTogMCxcblx0XHRcdGNvbHVtbjogWzEsIDhdXG5cdFx0fSwgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9zdHlsZSA9ICgwLCBfdXRpbHMuZ2V0U3R5bGVOYW1lcykodGhpcy5vcHRpb25zLmhvcml6b250YWwpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0SnVzdGlmaWVkTGF5b3V0LnByb3RvdHlwZS5fbGF5b3V0ID0gZnVuY3Rpb24gX2xheW91dChpdGVtcywgb3V0bGluZSwgaXNBcHBlbmQpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0dmFyIHNpemUxTmFtZSA9IHN0eWxlLnNpemUxO1xuXHRcdHZhciBzaXplMk5hbWUgPSBzdHlsZS5zaXplMjtcblx0XHR2YXIgc3RhcnRJbmRleCA9IDA7XG5cdFx0dmFyIGVuZEluZGV4ID0gaXRlbXMubGVuZ3RoO1xuXHRcdHZhciBjb2x1bW4gPSB0aGlzLm9wdGlvbnMuY29sdW1uO1xuXG5cdFx0aWYgKCh0eXBlb2YgY29sdW1uID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29sdW1uKSkgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdGNvbHVtbiA9IFtjb2x1bW4sIGNvbHVtbl07XG5cdFx0fVxuXG5cdFx0dmFyIGdyYXBoID0gZnVuY3Rpb24gZ3JhcGgoX3N0YXJ0KSB7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IHt9O1xuXHRcdFx0dmFyIHN0YXJ0ID0gK19zdGFydC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIik7XG5cdFx0XHR2YXIgbGVuZ3RoID0gZW5kSW5kZXggKyAxO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gTWF0aC5taW4oc3RhcnQgKyBjb2x1bW5bMF0sIGxlbmd0aCAtIDEpOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aWYgKGkgLSBzdGFydCA+IGNvbHVtblsxXSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjb3N0ID0gX3RoaXMuX2dldENvc3QoaXRlbXMsIHN0YXJ0LCBpLCBzaXplMU5hbWUsIHNpemUyTmFtZSk7XG5cblx0XHRcdFx0aWYgKGNvc3QgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY29zdCA8IDAgJiYgaSA9PT0gbGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdGNvc3QgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdHNbXCJcIiArIGldID0gTWF0aC5wb3coY29zdCwgMik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXHRcdC8vIHNob3J0ZXN0IHBhdGggZm9yIGl0ZW1zJyB0b3RhbCBoZWlnaHQuXG5cdFx0dmFyIHBhdGggPSBfZGlqa3N0cmEyW1wiZGVmYXVsdFwiXS5maW5kX3BhdGgoZ3JhcGgsIFwiXCIgKyBzdGFydEluZGV4LCBcIlwiICsgZW5kSW5kZXgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0eWxlKGl0ZW1zLCBwYXRoLCBvdXRsaW5lLCBpc0FwcGVuZCk7XG5cdH07XG5cblx0SnVzdGlmaWVkTGF5b3V0LnByb3RvdHlwZS5fZ2V0U2l6ZSA9IGZ1bmN0aW9uIF9nZXRTaXplKGl0ZW1zLCBzaXplMU5hbWUsIHNpemUyTmFtZSkge1xuXHRcdHZhciBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luO1xuXHRcdHZhciBzaXplID0gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGl0ZW0pIHtcblx0XHRcdHJldHVybiBzdW0gKyBpdGVtLnNpemVbc2l6ZTJOYW1lXSAvIGl0ZW0uc2l6ZVtzaXplMU5hbWVdO1xuXHRcdH0sIDApO1xuXG5cdFx0cmV0dXJuICh0aGlzLl9zaXplIC0gbWFyZ2luICogKGl0ZW1zLmxlbmd0aCAtIDEpKSAvIHNpemU7XG5cdH07XG5cblx0SnVzdGlmaWVkTGF5b3V0LnByb3RvdHlwZS5fZ2V0Q29zdCA9IGZ1bmN0aW9uIF9nZXRDb3N0KGl0ZW1zLCBpLCBqLCBzaXplMU5hbWUsIHNpemUyTmFtZSkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fZ2V0U2l6ZShpdGVtcy5zbGljZShpLCBqKSwgc2l6ZTFOYW1lLCBzaXplMk5hbWUpO1xuXHRcdHZhciBtaW4gPSB0aGlzLm9wdGlvbnMubWluU2l6ZSB8fCAwO1xuXHRcdHZhciBtYXggPSB0aGlzLm9wdGlvbnMubWF4U2l6ZSB8fCBJbmZpbml0eTtcblxuXHRcdGlmIChpc0Zpbml0ZShtYXgpKSB7XG5cdFx0XHQvLyBpZiB0aGlzIHNpemUgaXMgbm90IGluIHJhbmdlLCB0aGUgY29zdCBpbmNyZWFzZXMgc2hhcnBseS5cblx0XHRcdGlmIChzaXplIDwgbWluKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdyhzaXplIC0gbWluLCAyKSArIE1hdGgucG93KG1heCwgMik7XG5cdFx0XHR9IGVsc2UgaWYgKHNpemUgPiBtYXgpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucG93KHNpemUgLSBtYXgsIDIpICsgTWF0aC5wb3cobWF4LCAyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgc2l6ZSBpbiByYW5nZSwgdGhlIGNvc3QgaXMgbmVnYXRpdmUgb3IgbG93LlxuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4oc2l6ZSAtIG1heCwgbWluIC0gc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlmIG1heCBpcyBpbmZpbml0ZSB0eXBlLCBjYWN1bGF0ZSBjb3N0IG9ubHkgd2l0aCBcIm1pblwiLlxuXHRcdGlmIChzaXplIDwgbWluKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5wb3cobWluLCAyKSwgTWF0aC5wb3coc2l6ZSwgMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gc2l6ZSAtIG1pbjtcblx0fTtcblxuXHRKdXN0aWZpZWRMYXlvdXQucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIF9zZXRTdHlsZShpdGVtcywgcGF0aCkge1xuXHRcdHZhciBvdXRsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblx0XHR2YXIgaXNBcHBlbmQgPSBhcmd1bWVudHNbM107XG5cblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHQvLyBpZiBkaXJlY3Rpb24gaXMgdmVydGljYWxcblx0XHQvLyBwb3MxIDogdG9wLCBwb3MxMSA6IGJvdHRvbVxuXHRcdC8vIHNpemUxIDogaGVpZ2h0XG5cdFx0Ly8gcG9zMiA6IGxlZnQsIHBvczIyIDogcmlnaHRcblx0XHQvLyBzaXplMiA6IHdpZHRoXG5cblx0XHQvLyBpZiBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbFxuXHRcdC8vIHBvczEgOiBsZWZ0LCBwb3MxMSA6IHJpZ2h0XG5cdFx0Ly8gc2l6ZTEgOiB3aWR0aFxuXHRcdC8vIHBvczIgOiB0b3AsIHBvczIyIDogYm90dG9tXG5cdFx0Ly8gc2l6ZTIgOiBoZWlnaHRcblx0XHR2YXIgcG9zMU5hbWUgPSBzdHlsZS5wb3MxO1xuXHRcdHZhciBzaXplMU5hbWUgPSBzdHlsZS5zaXplMTtcblx0XHR2YXIgcG9zMk5hbWUgPSBzdHlsZS5wb3MyO1xuXHRcdHZhciBzaXplMk5hbWUgPSBzdHlsZS5zaXplMjtcblx0XHR2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cdFx0dmFyIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG5cdFx0dmFyIHN0YXJ0UG9pbnQgPSBvdXRsaW5lWzBdIHx8IDA7XG5cdFx0dmFyIGVuZFBvaW50ID0gc3RhcnRQb2ludDtcblx0XHR2YXIgaGVpZ2h0ID0gMDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0XHR2YXIgcGF0aDEgPSBwYXJzZUludChwYXRoW2ldLCAxMCk7XG5cdFx0XHR2YXIgcGF0aDIgPSBwYXJzZUludChwYXRoW2kgKyAxXSwgMTApO1xuXHRcdFx0Ly8gcGF0aEl0ZW1zKHBhdGgxIHRvIHBhdGgyKSBhcmUgaW4gMSBsaW5lLlxuXHRcdFx0dmFyIHBhdGhJdGVtcyA9IGl0ZW1zLnNsaWNlKHBhdGgxLCBwYXRoMik7XG5cdFx0XHR2YXIgcGF0aEl0ZW1zTGVuZ3RoID0gcGF0aEl0ZW1zLmxlbmd0aDtcblx0XHRcdHZhciBzaXplMSA9IHRoaXMuX2dldFNpemUocGF0aEl0ZW1zLCBzaXplMU5hbWUsIHNpemUyTmFtZSk7XG5cdFx0XHR2YXIgcG9zMSA9IGVuZFBvaW50O1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdGhJdGVtc0xlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBfaXRlbSRyZWN0O1xuXG5cdFx0XHRcdHZhciBpdGVtID0gcGF0aEl0ZW1zW2pdO1xuXHRcdFx0XHR2YXIgc2l6ZTIgPSBpdGVtLm9yZ1NpemVbc2l6ZTJOYW1lXSAvIGl0ZW0ub3JnU2l6ZVtzaXplMU5hbWVdICogc2l6ZTE7XG5cdFx0XHRcdC8vIGl0ZW0gaGFzIG1hcmdpbiBib3R0b20gYW5kIHJpZ2h0LlxuXHRcdFx0XHQvLyBmaXJzdCBpdGVtIGhhcyBub3QgbWFyZ2luLlxuXHRcdFx0XHR2YXIgcHJldkl0ZW1SZWN0ID0gaiA9PT0gMCA/IDAgOiBwYXRoSXRlbXNbaiAtIDFdLnJlY3Q7XG5cdFx0XHRcdHZhciBwb3MyID0gcHJldkl0ZW1SZWN0ID8gcHJldkl0ZW1SZWN0W3BvczJOYW1lXSArIHByZXZJdGVtUmVjdFtzaXplMk5hbWVdICsgbWFyZ2luIDogMDtcblxuXHRcdFx0XHRpdGVtLnJlY3QgPSAoX2l0ZW0kcmVjdCA9IHt9LCBfaXRlbSRyZWN0W3BvczFOYW1lXSA9IHBvczEsIF9pdGVtJHJlY3RbcG9zMk5hbWVdID0gcG9zMiwgX2l0ZW0kcmVjdFtzaXplMU5hbWVdID0gc2l6ZTEsIF9pdGVtJHJlY3Rbc2l6ZTJOYW1lXSA9IHNpemUyLCBfaXRlbSRyZWN0KTtcblx0XHRcdH1cblx0XHRcdGhlaWdodCArPSBtYXJnaW4gKyBzaXplMTtcblx0XHRcdGVuZFBvaW50ID0gc3RhcnRQb2ludCArIGhlaWdodDtcblx0XHR9XG5cdFx0dmFyIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuXHRcdHZhciBzdGFydEluZGV4ID0gaXRlbXNMZW5ndGggPyAwIDogLTE7XG5cdFx0dmFyIGVuZEluZGV4ID0gaXRlbXNMZW5ndGggPyBpdGVtc0xlbmd0aCAtIDEgOiAtMTtcblxuXHRcdGlmIChpc0FwcGVuZCkge1xuXHRcdFx0Ly8gcHJldmlvdXMgZ3JvdXAncyBlbmQgb3V0bGluZSBpcyBjdXJyZW50IGdyb3VwJ3Mgc3RhcnQgb3V0bGluZVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3RhcnQ6IFtzdGFydFBvaW50XSxcblx0XHRcdFx0ZW5kOiBbZW5kUG9pbnRdLFxuXHRcdFx0XHRzdGFydEluZGV4OiBzdGFydEluZGV4LFxuXHRcdFx0XHRlbmRJbmRleDogZW5kSW5kZXhcblx0XHRcdH07XG5cdFx0fVxuXHRcdC8vIGZvciBwcmVwZW5kLCBvbmx5IHN1YnN0cmFjdCBoZWlnaHQgZnJvbSBwb3NpdGlvbi5cblx0XHQvLyBhbHdheXMgc3RhcnQgaXMgbG93ZXIgdGhhbiBlbmQuXG5cblx0XHRmb3IgKHZhciBfaSA9IDA7IF9pIDwgaXRlbXNMZW5ndGg7ICsrX2kpIHtcblx0XHRcdHZhciBfaXRlbSA9IGl0ZW1zW19pXTtcblxuXHRcdFx0Ly8gbW92ZSBpdGVtcyBhcyBsb25nIGFzIGhlaWdodCBmb3IgcHJlcGVuZFxuXHRcdFx0X2l0ZW0ucmVjdFtwb3MxTmFtZV0gLT0gaGVpZ2h0O1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IFtzdGFydFBvaW50IC0gaGVpZ2h0XSxcblx0XHRcdGVuZDogW3N0YXJ0UG9pbnRdLCAvLyBlbmRQb2ludCAtIGhlaWdodCA9IHN0YXJ0UG9pbnRcblx0XHRcdHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG5cdFx0XHRlbmRJbmRleDogZW5kSW5kZXhcblx0XHR9O1xuXHR9O1xuXG5cdEp1c3RpZmllZExheW91dC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uIF9pbnNlcnQoaXRlbXMsIG91dGxpbmUsIHR5cGUpIHtcblx0XHQvLyB0aGlzIG9ubHkgbmVlZHMgdGhlIHNpemUgb2YgdGhlIGl0ZW0uXG5cdFx0dmFyIGNsb25lID0gKDAsIF91dGlscy5jbG9uZUl0ZW1zKShpdGVtcyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aXRlbXM6IGNsb25lLFxuXHRcdFx0b3V0bGluZXM6IHRoaXMuX2xheW91dChjbG9uZSwgb3V0bGluZSwgdHlwZSlcblx0XHR9O1xuXHR9O1xuXHQvKipcbiAgKiBTZXQgdGhlIHZpZXdwb3J0IHNpemUgb2YgdGhlIGxheW91dC5cbiAgKiBAa28g66CI7J207JWE7JuD7J2YIOqwgOyLnCDsgqzsnbTspojrpbwg7ISk7KCV7ZWc64ukLlxuICAqIEBtZXRob2QgZWcuSW5maW5pdGVHcmlkLkp1c3RpZmllZExheW91dCNzZXRTaXplXG4gICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIHZpZXdwb3J0IHNpemUgb2YgY29udGFpbmVyIGFyZWEgd2hlcmUgaXRlbXMgYXJlIGFkZGVkIHRvIGEgbGF5b3V0IDxrbz7roIjsnbTslYTsm4Psl5Ag7JWE7J207YWc7J2EIOy2lOqwgO2VmOuKlCDsu6jthYzsnbTrhIgg7JiB7Jet7J2YIOqwgOyLnCDsgqzsnbTspog8L2tvPlxuICAqIEByZXR1cm4ge2VnLkluZmluaXRlR3JpZC5KdXN0aWZpZWRMYXlvdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZjxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQuc2V0U2l6ZSg4MDApO1xuICAqL1xuXG5cblx0SnVzdGlmaWVkTGF5b3V0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZShzaXplKSB7XG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuICAqIEFkZHMgaXRlbXMgYXQgdGhlIGJvdHRvbSBvZiBhIG91dGxpbmUuXG4gICogQGtvIOyVhOydtO2FnOuTpOydhCDslYTsm4Prnbzsnbgg7JWE656Y7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5KdXN0aWZpZWRMYXlvdXQjYXBwZW5kXG4gICogQHBhcmFtIHtBcnJheX0gaXRlbXMgQXJyYXkgb2YgaXRlbXMgdG8gYmUgbGF5b3V0ZWQgPGtvPuugiOydtOyVhOybg+2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cbiAgKiBAcGFyYW0ge0FycmF5fSBbb3V0bGluZT1bXV0gQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7T2JqZWN0fSBMYXlvdXRlZCBpdGVtcyBhbmQgb3V0bGluZSBvZiBzdGFydCBhbmQgZW5kIDxrbz4g66CI7J207JWE7JuD7J20IOuQnCDslYTsnbTthZzqs7wg7Iuc7J6R6rO8IOuBneydmCDslYTsm4PrnbzsnbjsnbQg64u06ri0IOygleuztDwva28+XG4gICogQGV4YW1wbGVcbiAgKiBsYXlvdXQucHJlcGVuZChpdGVtcywgWzEwMF0pO1xuICAqL1xuXG5cblx0SnVzdGlmaWVkTGF5b3V0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoaXRlbXMsIG91dGxpbmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KGl0ZW1zLCBvdXRsaW5lLCBfY29uc3RzLkFQUEVORCk7XG5cdH07XG5cdC8qKlxuICAqIEFkZHMgaXRlbXMgYXQgdGhlIHRvcCBvZiBhIG91dGxpbmUuXG4gICogQGtvIOyVhOydtO2FnOydhCDslYTsm4Prnbzsnbgg7JyE7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5KdXN0aWZpZWRMYXlvdXQjcHJlcGVuZFxuICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIEFycmF5IG9mIGl0ZW1zIHRvIGJlIGxheW91dGVkIDxrbz7roIjsnbTslYTsm4PtlaAg7JWE7J207YWc65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHBhcmFtIHtBcnJheX0gW291dGxpbmU9W11dIEFycmF5IG9mIG91dGxpbmUgcG9pbnRzIHRvIGJlIHJlZmVyZW5jZSBwb2ludHMgPGtvPuq4sOykgOygkOydtCDrkJjripQg7JWE7JuD65287J24IOygkOuTpOydmCDrsLDsl7Q8L2tvPlxuICAqIEByZXR1cm4ge09iamVjdH0gTGF5b3V0ZWQgaXRlbXMgYW5kIG91dGxpbmUgb2Ygc3RhcnQgYW5kIGVuZCA8a28+IOugiOydtOyVhOybg+ydtCDrkJwg7JWE7J207YWc6rO8IOyLnOyekeqzvCDrgZ3snZgg7JWE7JuD65287J247J20IOuLtOq4tCDsoJXrs7Q8L2tvPlxuICAqIEBleGFtcGxlXG4gICogbGF5b3V0LnByZXBlbmQoaXRlbXMsIFsxMDBdKTtcbiAgKi9cblxuXG5cdEp1c3RpZmllZExheW91dC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoaXRlbXMsIG91dGxpbmUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0KGl0ZW1zLCBvdXRsaW5lLCBfY29uc3RzLlBSRVBFTkQpO1xuXHR9O1xuXHQvKipcbiAgKiBBZGRzIGl0ZW1zIG9mIGdyb3VwcyBhdCB0aGUgYm90dG9tIG9mIGEgb3V0bGluZS5cbiAgKiBAa28g6re466O565Ok7J2YIOyVhOydtO2FnOuTpOydhCDslYTsm4Prnbzsnbgg7JWE656Y7JeQIOy2lOqwgO2VnOuLpC5cbiAgKiBAbWV0aG9kIGVnLkluZmluaXRlR3JpZC5KdXN0aWZpZWRMYXlvdXQjbGF5b3V0XG4gICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIEFycmF5IG9mIGdyb3VwcyB0byBiZSBsYXlvdXRlZCA8a28+66CI7J207JWE7JuD7ZWgIOq3uOujueuTpOydmCDrsLDsl7Q8L2tvPlxuICAqIEBwYXJhbSB7QXJyYXl9IG91dGxpbmUgQXJyYXkgb2Ygb3V0bGluZSBwb2ludHMgdG8gYmUgcmVmZXJlbmNlIHBvaW50cyA8a28+6riw7KSA7KCQ7J20IOuQmOuKlCDslYTsm4Prnbzsnbgg7KCQ65Ok7J2YIOuwsOyXtDwva28+XG4gICogQHJldHVybiB7ZWcuSW5maW5pdGVHcmlkLkp1c3RpZmllZExheW91dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgKiBAZXhhbXBsZVxuICAqIGxheW91dC5sYXlvdXQoZ3JvdXBzLCBbMTAwXSk7XG4gICovXG5cblxuXHRKdXN0aWZpZWRMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIGxheW91dChncm91cHMsIG91dGxpbmVzKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0dmFyIHBvaW50ID0gb3V0bGluZXM7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cblx0XHRcdHBvaW50ID0gdGhpcy5fbGF5b3V0KGdyb3VwLml0ZW1zLCBwb2ludCwgX2NvbnN0cy5BUFBFTkQpO1xuXHRcdFx0Z3JvdXAub3V0bGluZXMgPSBwb2ludDtcblx0XHRcdHBvaW50ID0gcG9pbnQuZW5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyZXR1cm4gSnVzdGlmaWVkTGF5b3V0O1xufSgpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEp1c3RpZmllZExheW91dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENyZWF0ZWQgMjAwOC0wOC0xOS5cbiAqXG4gKiBEaWprc3RyYSBwYXRoLWZpbmRpbmcgZnVuY3Rpb25zLiBBZGFwdGVkIGZyb20gdGhlIERpamtzdGFyIFB5dGhvbiBwcm9qZWN0LlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAwOFxuICogICBXeWF0dCBCYWxkd2luIDxzZWxmQHd5YXR0YmFsZHdpbi5jb20+XG4gKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICogICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRpamtzdHJhID0ge1xuICAgIHNpbmdsZV9zb3VyY2Vfc2hvcnRlc3RfcGF0aHM6IGZ1bmN0aW9uIHNpbmdsZV9zb3VyY2Vfc2hvcnRlc3RfcGF0aHMoZ3JhcGgsIHMsIGQpIHtcbiAgICAgIC8vIFByZWRlY2Vzc29yIG1hcCBmb3IgZWFjaCBub2RlIHRoYXQgaGFzIGJlZW4gZW5jb3VudGVyZWQuXG4gICAgICAvLyBub2RlIElEID0+IHByZWRlY2Vzc29yIG5vZGUgSURcbiAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSB7fTtcblxuICAgICAgLy8gQ29zdHMgb2Ygc2hvcnRlc3QgcGF0aHMgZnJvbSBzIHRvIGFsbCBub2RlcyBlbmNvdW50ZXJlZC5cbiAgICAgIC8vIG5vZGUgSUQgPT4gY29zdFxuICAgICAgdmFyIGNvc3RzID0ge307XG4gICAgICBjb3N0c1tzXSA9IDA7XG5cbiAgICAgIC8vIENvc3RzIG9mIHNob3J0ZXN0IHBhdGhzIGZyb20gcyB0byBhbGwgbm9kZXMgZW5jb3VudGVyZWQ7IGRpZmZlcnMgZnJvbVxuICAgICAgLy8gYGNvc3RzYCBpbiB0aGF0IGl0IHByb3ZpZGVzIGVhc3kgYWNjZXNzIHRvIHRoZSBub2RlIHRoYXQgY3VycmVudGx5IGhhc1xuICAgICAgLy8gdGhlIGtub3duIHNob3J0ZXN0IHBhdGggZnJvbSBzLlxuICAgICAgLy8gWFhYOiBEbyB3ZSBhY3R1YWxseSBuZWVkIGJvdGggYGNvc3RzYCBhbmQgYG9wZW5gP1xuICAgICAgdmFyIG9wZW4gPSBuZXcgQmluYXJ5SGVhcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5jb3N0O1xuICAgICAgfSk7XG4gICAgICBvcGVuLnB1c2goeyB2YWx1ZTogcywgY29zdDogMCB9KTtcblxuICAgICAgdmFyIGNsb3Nlc3QsIHUsIGNvc3Rfb2Zfc190b191LCBhZGphY2VudF9ub2RlcywgY29zdF9vZl9lLCBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSwgY29zdF9vZl9zX3RvX3YsIGZpcnN0X3Zpc2l0O1xuICAgICAgd2hpbGUgKG9wZW4uc2l6ZSgpKSB7XG4gICAgICAgIC8vIEluIHRoZSBub2RlcyByZW1haW5pbmcgaW4gZ3JhcGggdGhhdCBoYXZlIGEga25vd24gY29zdCBmcm9tIHMsXG4gICAgICAgIC8vIGZpbmQgdGhlIG5vZGUsIHUsIHRoYXQgY3VycmVudGx5IGhhcyB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHMuXG4gICAgICAgIGNsb3Nlc3QgPSBvcGVuLnBvcCgpO1xuICAgICAgICB1ID0gY2xvc2VzdC52YWx1ZTtcbiAgICAgICAgY29zdF9vZl9zX3RvX3UgPSBjbG9zZXN0LmNvc3Q7XG5cbiAgICAgICAgLy8gR2V0IG5vZGVzIGFkamFjZW50IHRvIHUuLi5cbiAgICAgICAgYWRqYWNlbnRfbm9kZXMgPSBncmFwaCh1KSB8fCB7fTtcblxuICAgICAgICAvLyAuLi5hbmQgZXhwbG9yZSB0aGUgZWRnZXMgdGhhdCBjb25uZWN0IHUgdG8gdGhvc2Ugbm9kZXMsIHVwZGF0aW5nXG4gICAgICAgIC8vIHRoZSBjb3N0IG9mIHRoZSBzaG9ydGVzdCBwYXRocyB0byBhbnkgb3IgYWxsIG9mIHRob3NlIG5vZGVzIGFzXG4gICAgICAgIC8vIG5lY2Vzc2FyeS4gdiBpcyB0aGUgbm9kZSBhY3Jvc3MgdGhlIGN1cnJlbnQgZWRnZSBmcm9tIHUuXG4gICAgICAgIGZvciAodmFyIHYgaW4gYWRqYWNlbnRfbm9kZXMpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGNvc3Qgb2YgdGhlIGVkZ2UgcnVubmluZyBmcm9tIHUgdG8gdi5cbiAgICAgICAgICBjb3N0X29mX2UgPSBhZGphY2VudF9ub2Rlc1t2XTtcblxuICAgICAgICAgIC8vIENvc3Qgb2YgcyB0byB1IHBsdXMgdGhlIGNvc3Qgb2YgdSB0byB2IGFjcm9zcyBlLS10aGlzIGlzICphKlxuICAgICAgICAgIC8vIGNvc3QgZnJvbSBzIHRvIHYgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBsZXNzIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBrbm93biBjb3N0IHRvIHYuXG4gICAgICAgICAgY29zdF9vZl9zX3RvX3VfcGx1c19jb3N0X29mX2UgPSBjb3N0X29mX3NfdG9fdSArIGNvc3Rfb2ZfZTtcblxuICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgdmlzaXRlZCB2IHlldCBPUiBpZiB0aGUgY3VycmVudCBrbm93biBjb3N0IGZyb20gcyB0b1xuICAgICAgICAgIC8vIHYgaXMgZ3JlYXRlciB0aGFuIHRoZSBuZXcgY29zdCB3ZSBqdXN0IGZvdW5kIChjb3N0IG9mIHMgdG8gdSBwbHVzXG4gICAgICAgICAgLy8gY29zdCBvZiB1IHRvIHYgYWNyb3NzIGUpLCB1cGRhdGUgdidzIGNvc3QgaW4gdGhlIGNvc3QgbGlzdCBhbmRcbiAgICAgICAgICAvLyB1cGRhdGUgdidzIHByZWRlY2Vzc29yIGluIHRoZSBwcmVkZWNlc3NvciBsaXN0IChpdCdzIG5vdyB1KS5cbiAgICAgICAgICBjb3N0X29mX3NfdG9fdiA9IGNvc3RzW3ZdO1xuICAgICAgICAgIGZpcnN0X3Zpc2l0ID0gdHlwZW9mIGNvc3RzW3ZdID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICBpZiAoZmlyc3RfdmlzaXQgfHwgY29zdF9vZl9zX3RvX3YgPiBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSkge1xuICAgICAgICAgICAgY29zdHNbdl0gPSBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZTtcbiAgICAgICAgICAgIG9wZW4ucHVzaCh7IHZhbHVlOiB2LCBjb3N0OiBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSB9KTtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yc1t2XSA9IHU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29zdHNbZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtc2cgPSBbJ0NvdWxkIG5vdCBmaW5kIGEgcGF0aCBmcm9tICcsIHMsICcgdG8gJywgZCwgJy4nXS5qb2luKCcnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVkZWNlc3NvcnM7XG4gICAgfSxcblxuICAgIGV4dHJhY3Rfc2hvcnRlc3RfcGF0aF9mcm9tX3ByZWRlY2Vzc29yX2xpc3Q6IGZ1bmN0aW9uIGV4dHJhY3Rfc2hvcnRlc3RfcGF0aF9mcm9tX3ByZWRlY2Vzc29yX2xpc3QocHJlZGVjZXNzb3JzLCBkKSB7XG4gICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgIHZhciB1ID0gZDtcbiAgICAgIHZhciBwcmVkZWNlc3NvcjtcbiAgICAgIHdoaWxlICh1KSB7XG4gICAgICAgIG5vZGVzLnB1c2godSk7XG4gICAgICAgIHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3JzW3VdO1xuICAgICAgICB1ID0gcHJlZGVjZXNzb3JzW3VdO1xuICAgICAgfVxuICAgICAgbm9kZXMucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG5cbiAgICBmaW5kX3BhdGg6IGZ1bmN0aW9uIGZpbmRfcGF0aChncmFwaCwgcywgZCkge1xuICAgICAgdmFyIHByZWRlY2Vzc29ycyA9IGRpamtzdHJhLnNpbmdsZV9zb3VyY2Vfc2hvcnRlc3RfcGF0aHMoZ3JhcGgsIHMsIGQpO1xuICAgICAgcmV0dXJuIGRpamtzdHJhLmV4dHJhY3Rfc2hvcnRlc3RfcGF0aF9mcm9tX3ByZWRlY2Vzc29yX2xpc3QocHJlZGVjZXNzb3JzLCBkKTtcbiAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xuICB9XG5cbiAgQmluYXJ5SGVhcC5wcm90b3R5cGUgPSB7XG4gICAgcHVzaDogZnVuY3Rpb24gcHVzaChlbGVtZW50KSB7XG4gICAgICAvLyBBZGQgdGhlIG5ldyBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XG4gICAgICAvLyBBbGxvdyBpdCB0byBidWJibGUgdXAuXG4gICAgICB0aGlzLmJ1YmJsZVVwKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgICB9LFxuXG4gICAgcG9wOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udGVudFswXTtcbiAgICAgIC8vIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGVsZW1lbnRzIGxlZnQsIHB1dCB0aGUgZW5kIGVsZW1lbnQgYXQgdGhlXG4gICAgICAvLyBzdGFydCwgYW5kIGxldCBpdCBzaW5rIGRvd24uXG4gICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xuICAgICAgICB0aGlzLnNpbmtEb3duKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgYnViYmxlVXA6IGZ1bmN0aW9uIGJ1YmJsZVVwKG4pIHtcbiAgICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIG1vdmVkLlxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl07XG4gICAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBnbyB1cCBhbnkgZnVydGhlci5cbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXG4gICAgICAgIHZhciBwYXJlbnROID0gTWF0aC5mbG9vcigobiArIDEpIC8gMikgLSAxLFxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dO1xuICAgICAgICAvLyBTd2FwIHRoZSBlbGVtZW50cyBpZiB0aGUgcGFyZW50IGlzIGdyZWF0ZXIuXG4gICAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCkgPCB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5jb250ZW50W25dID0gcGFyZW50O1xuICAgICAgICAgIC8vIFVwZGF0ZSAnbicgdG8gY29udGludWUgYXQgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICBuID0gcGFyZW50TjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VuZCBhIHBhcmVudCB0aGF0IGlzIGxlc3MsIG5vIG5lZWQgdG8gbW92ZSBpdCBmdXJ0aGVyLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNpbmtEb3duOiBmdW5jdGlvbiBzaW5rRG93bihuKSB7XG4gICAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXSxcbiAgICAgICAgICBlbGVtU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICB2YXIgY2hpbGQyTiA9IChuICsgMSkgKiAyLFxuICAgICAgICAgICAgY2hpbGQxTiA9IGNoaWxkMk4gLSAxO1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgICAgLy8gaWYgYW55LlxuICAgICAgICB2YXIgc3dhcCA9IG51bGw7XG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICAgIGlmIChjaGlsZDFOIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXG4gICAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXSxcbiAgICAgICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcbiAgICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cbiAgICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICAgIHN3YXAgPSBjaGlsZDFOO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBjaGVja3MgZm9yIHRoZSBvdGhlciBjaGlsZC5cbiAgICAgICAgaWYgKGNoaWxkMk4gPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY2hpbGQyID0gdGhpcy5jb250ZW50W2NoaWxkMk5dLFxuICAgICAgICAgICAgICBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xuICAgICAgICAgIGlmIChjaGlsZDJTY29yZSA8IChzd2FwID09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICAgIHN3YXAgPSBjaGlsZDJOO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IG5lZWRzIHRvIGJlIG1vdmVkLCBzd2FwIGl0LCBhbmQgY29udGludWUuXG4gICAgICAgIGlmIChzd2FwICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICAgIHRoaXMuY29udGVudFtzd2FwXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgbiA9IHN3YXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCcm93c2VyaWZ5IOyngOybkOydhCDsnITtlZwg66qo65OI7ZmUIOy9lOuTnFxuICAgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuZGlqa3N0cmEgPSBkaWprc3RyYTtcbiAgfVxufSkoKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZpbml0ZWdyaWQubW9kdWxlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@egjs/infinitegrid/dist/infinitegrid.module.js\n')},"./node_modules/desandro-matches-selector/matches-selector.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  /*global define: false, module: false */\n  'use strict';\n  // universal module definition\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory() {\n  'use strict';\n\n  var matchesMethod = ( function() {\n    var ElemProto = window.Element.prototype;\n    // check for the standard method name first\n    if ( ElemProto.matches ) {\n      return 'matches';\n    }\n    // check un-prefixed\n    if ( ElemProto.matchesSelector ) {\n      return 'matchesSelector';\n    }\n    // check vendor prefixes\n    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];\n\n    for ( var i=0; i < prefixes.length; i++ ) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n      if ( ElemProto[ method ] ) {\n        return method;\n      }\n    }\n  })();\n\n  return function matchesSelector( elem, selector ) {\n    return elem[ matchesMethod ]( selector );\n  };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVzYW5kcm8tbWF0Y2hlcy1zZWxlY3Rvci9tYXRjaGVzLXNlbGVjdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3Rvci5qcz9jNzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWF0Y2hlc1NlbGVjdG9yIHYyLjAuMlxuICogbWF0Y2hlc1NlbGVjdG9yKCBlbGVtZW50LCAnLnNlbGVjdG9yJyApXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8qZ2xvYmFsIGRlZmluZTogZmFsc2UsIG1vZHVsZTogZmFsc2UgKi9cbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lm1hdGNoZXNTZWxlY3RvciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbWF0Y2hlc01ldGhvZCA9ICggZnVuY3Rpb24oKSB7XG4gICAgdmFyIEVsZW1Qcm90byA9IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZTtcbiAgICAvLyBjaGVjayBmb3IgdGhlIHN0YW5kYXJkIG1ldGhvZCBuYW1lIGZpcnN0XG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlcyApIHtcbiAgICAgIHJldHVybiAnbWF0Y2hlcyc7XG4gICAgfVxuICAgIC8vIGNoZWNrIHVuLXByZWZpeGVkXG4gICAgaWYgKCBFbGVtUHJvdG8ubWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuICdtYXRjaGVzU2VsZWN0b3InO1xuICAgIH1cbiAgICAvLyBjaGVjayB2ZW5kb3IgcHJlZml4ZXNcbiAgICB2YXIgcHJlZml4ZXMgPSBbICd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nIF07XG5cbiAgICBmb3IgKCB2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcHJlZml4ICsgJ01hdGNoZXNTZWxlY3Rvcic7XG4gICAgICBpZiAoIEVsZW1Qcm90b1sgbWV0aG9kIF0gKSB7XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoIGVsZW0sIHNlbGVjdG9yICkge1xuICAgIHJldHVybiBlbGVtWyBtYXRjaGVzTWV0aG9kIF0oIHNlbGVjdG9yICk7XG4gIH07XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxXQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/desandro-matches-selector/matches-selector.js\n")},"./node_modules/ev-emitter/ev-emitter.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXYtZW1pdHRlci9ldi1lbWl0dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcz8wOTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXZFbWl0dGVyIHYxLjEuMFxuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCk7XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICBmb3IgKCB2YXIgaT0wOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgZGVsZXRlIHRoaXMuX29uY2VFdmVudHM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ev-emitter/ev-emitter.js\n")},"./node_modules/fizzy-ui-utils/utils.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fizzy UI utils v2.0.7\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! desandro-matches-selector/matches-selector */ \"./node_modules/desandro-matches-selector/matches-selector.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( matchesSelector ) {\n      return factory( window, matchesSelector );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, matchesSelector ) {\n\n'use strict';\n\nvar utils = {};\n\n// ----- extend ----- //\n\n// extends objects\nutils.extend = function( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n};\n\n// ----- modulo ----- //\n\nutils.modulo = function( num, div ) {\n  return ( ( num % div ) + div ) % div;\n};\n\n// ----- makeArray ----- //\n\nvar arraySlice = Array.prototype.slice;\n\n// turn element or nodeList into an array\nutils.makeArray = function( obj ) {\n  if ( Array.isArray( obj ) ) {\n    // use object if already an array\n    return obj;\n  }\n  // return empty array if undefined or null. #6\n  if ( obj === null || obj === undefined ) {\n    return [];\n  }\n\n  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n  if ( isArrayLike ) {\n    // convert nodeList to array\n    return arraySlice.call( obj );\n  }\n\n  // array of single index\n  return [ obj ];\n};\n\n// ----- removeFrom ----- //\n\nutils.removeFrom = function( ary, obj ) {\n  var index = ary.indexOf( obj );\n  if ( index != -1 ) {\n    ary.splice( index, 1 );\n  }\n};\n\n// ----- getParent ----- //\n\nutils.getParent = function( elem, selector ) {\n  while ( elem.parentNode && elem != document.body ) {\n    elem = elem.parentNode;\n    if ( matchesSelector( elem, selector ) ) {\n      return elem;\n    }\n  }\n};\n\n// ----- getQueryElement ----- //\n\n// use element as selector string\nutils.getQueryElement = function( elem ) {\n  if ( typeof elem == 'string' ) {\n    return document.querySelector( elem );\n  }\n  return elem;\n};\n\n// ----- handleEvent ----- //\n\n// enable .ontype to trigger from .addEventListener( elem, 'type' )\nutils.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// ----- filterFindElements ----- //\n\nutils.filterFindElements = function( elems, selector ) {\n  // make array of elems\n  elems = utils.makeArray( elems );\n  var ffElems = [];\n\n  elems.forEach( function( elem ) {\n    // check that elem is an actual element\n    if ( !( elem instanceof HTMLElement ) ) {\n      return;\n    }\n    // add elem if no selector\n    if ( !selector ) {\n      ffElems.push( elem );\n      return;\n    }\n    // filter & find items if we have a selector\n    // filter\n    if ( matchesSelector( elem, selector ) ) {\n      ffElems.push( elem );\n    }\n    // find children\n    var childElems = elem.querySelectorAll( selector );\n    // concat childElems to filterFound array\n    for ( var i=0; i < childElems.length; i++ ) {\n      ffElems.push( childElems[i] );\n    }\n  });\n\n  return ffElems;\n};\n\n// ----- debounceMethod ----- //\n\nutils.debounceMethod = function( _class, methodName, threshold ) {\n  threshold = threshold || 100;\n  // original method\n  var method = _class.prototype[ methodName ];\n  var timeoutName = methodName + 'Timeout';\n\n  _class.prototype[ methodName ] = function() {\n    var timeout = this[ timeoutName ];\n    clearTimeout( timeout );\n\n    var args = arguments;\n    var _this = this;\n    this[ timeoutName ] = setTimeout( function() {\n      method.apply( _this, args );\n      delete _this[ timeoutName ];\n    }, threshold );\n  };\n};\n\n// ----- docReady ----- //\n\nutils.docReady = function( callback ) {\n  var readyState = document.readyState;\n  if ( readyState == 'complete' || readyState == 'interactive' ) {\n    // do async to allow for other scripts to run. metafizzy/flickity#441\n    setTimeout( callback );\n  } else {\n    document.addEventListener( 'DOMContentLoaded', callback );\n  }\n};\n\n// ----- htmlInit ----- //\n\n// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\nutils.toDashed = function( str ) {\n  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {\n    return $1 + '-' + $2;\n  }).toLowerCase();\n};\n\nvar console = window.console;\n/**\n * allow user to initialize classes via [data-namespace] or .js-namespace class\n * htmlInit( Widget, 'widgetName' )\n * options are parsed from data-namespace-options\n */\nutils.htmlInit = function( WidgetClass, namespace ) {\n  utils.docReady( function() {\n    var dashedNamespace = utils.toDashed( namespace );\n    var dataAttr = 'data-' + dashedNamespace;\n    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );\n    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );\n    var elems = utils.makeArray( dataAttrElems )\n      .concat( utils.makeArray( jsDashElems ) );\n    var dataOptionsAttr = dataAttr + '-options';\n    var jQuery = window.jQuery;\n\n    elems.forEach( function( elem ) {\n      var attr = elem.getAttribute( dataAttr ) ||\n        elem.getAttribute( dataOptionsAttr );\n      var options;\n      try {\n        options = attr && JSON.parse( attr );\n      } catch ( error ) {\n        // log error, do not initialize\n        if ( console ) {\n          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +\n          ': ' + error );\n        }\n        return;\n      }\n      // initialize\n      var instance = new WidgetClass( elem, options );\n      // make available via $().data('namespace')\n      if ( jQuery ) {\n        jQuery.data( elem, namespace, instance );\n      }\n    });\n\n  });\n};\n\n// -----  ----- //\n\nreturn utils;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZml6enktdWktdXRpbHMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZml6enktdWktdXRpbHMvdXRpbHMuanM/NjE1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZpenp5IFVJIHV0aWxzIHYyLjAuN1xuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLypqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2Rlc2FuZHJvLW1hdGNoZXMtc2VsZWN0b3IvbWF0Y2hlcy1zZWxlY3RvcidcbiAgICBdLCBmdW5jdGlvbiggbWF0Y2hlc1NlbGVjdG9yICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdkZXNhbmRyby1tYXRjaGVzLXNlbGVjdG9yJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmZpenp5VUlVdGlscyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cubWF0Y2hlc1NlbGVjdG9yXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgbWF0Y2hlc1NlbGVjdG9yICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHt9O1xuXG4vLyAtLS0tLSBleHRlbmQgLS0tLS0gLy9cblxuLy8gZXh0ZW5kcyBvYmplY3RzXG51dGlscy5leHRlbmQgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgZm9yICggdmFyIHByb3AgaW4gYiApIHtcbiAgICBhWyBwcm9wIF0gPSBiWyBwcm9wIF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vLyAtLS0tLSBtb2R1bG8gLS0tLS0gLy9cblxudXRpbHMubW9kdWxvID0gZnVuY3Rpb24oIG51bSwgZGl2ICkge1xuICByZXR1cm4gKCAoIG51bSAlIGRpdiApICsgZGl2ICkgJSBkaXY7XG59O1xuXG4vLyAtLS0tLSBtYWtlQXJyYXkgLS0tLS0gLy9cblxudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8vIHR1cm4gZWxlbWVudCBvciBub2RlTGlzdCBpbnRvIGFuIGFycmF5XG51dGlscy5tYWtlQXJyYXkgPSBmdW5jdGlvbiggb2JqICkge1xuICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuICAgIC8vIHVzZSBvYmplY3QgaWYgYWxyZWFkeSBhbiBhcnJheVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgLy8gcmV0dXJuIGVtcHR5IGFycmF5IGlmIHVuZGVmaW5lZCBvciBudWxsLiAjNlxuICBpZiAoIG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgaXNBcnJheUxpa2UgPSB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xuICBpZiAoIGlzQXJyYXlMaWtlICkge1xuICAgIC8vIGNvbnZlcnQgbm9kZUxpc3QgdG8gYXJyYXlcbiAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKCBvYmogKTtcbiAgfVxuXG4gIC8vIGFycmF5IG9mIHNpbmdsZSBpbmRleFxuICByZXR1cm4gWyBvYmogXTtcbn07XG5cbi8vIC0tLS0tIHJlbW92ZUZyb20gLS0tLS0gLy9cblxudXRpbHMucmVtb3ZlRnJvbSA9IGZ1bmN0aW9uKCBhcnksIG9iaiApIHtcbiAgdmFyIGluZGV4ID0gYXJ5LmluZGV4T2YoIG9iaiApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGFyeS5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIGdldFBhcmVudCAtLS0tLSAvL1xuXG51dGlscy5nZXRQYXJlbnQgPSBmdW5jdGlvbiggZWxlbSwgc2VsZWN0b3IgKSB7XG4gIHdoaWxlICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0gIT0gZG9jdW1lbnQuYm9keSApIHtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBnZXRRdWVyeUVsZW1lbnQgLS0tLS0gLy9cblxuLy8gdXNlIGVsZW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG51dGlscy5nZXRRdWVyeUVsZW1lbnQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gLS0tLS0gaGFuZGxlRXZlbnQgLS0tLS0gLy9cblxuLy8gZW5hYmxlIC5vbnR5cGUgdG8gdHJpZ2dlciBmcm9tIC5hZGRFdmVudExpc3RlbmVyKCBlbGVtLCAndHlwZScgKVxudXRpbHMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gZmlsdGVyRmluZEVsZW1lbnRzIC0tLS0tIC8vXG5cbnV0aWxzLmZpbHRlckZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcywgc2VsZWN0b3IgKSB7XG4gIC8vIG1ha2UgYXJyYXkgb2YgZWxlbXNcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBmZkVsZW1zID0gW107XG5cbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gY2hlY2sgdGhhdCBlbGVtIGlzIGFuIGFjdHVhbCBlbGVtZW50XG4gICAgaWYgKCAhKCBlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYWRkIGVsZW0gaWYgbm8gc2VsZWN0b3JcbiAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgIGZmRWxlbXMucHVzaCggZWxlbSApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmaWx0ZXIgJiBmaW5kIGl0ZW1zIGlmIHdlIGhhdmUgYSBzZWxlY3RvclxuICAgIC8vIGZpbHRlclxuICAgIGlmICggbWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBzZWxlY3RvciApICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBlbGVtICk7XG4gICAgfVxuICAgIC8vIGZpbmQgY2hpbGRyZW5cbiAgICB2YXIgY2hpbGRFbGVtcyA9IGVsZW0ucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcbiAgICAvLyBjb25jYXQgY2hpbGRFbGVtcyB0byBmaWx0ZXJGb3VuZCBhcnJheVxuICAgIGZvciAoIHZhciBpPTA7IGkgPCBjaGlsZEVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgZmZFbGVtcy5wdXNoKCBjaGlsZEVsZW1zW2ldICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmZFbGVtcztcbn07XG5cbi8vIC0tLS0tIGRlYm91bmNlTWV0aG9kIC0tLS0tIC8vXG5cbnV0aWxzLmRlYm91bmNlTWV0aG9kID0gZnVuY3Rpb24oIF9jbGFzcywgbWV0aG9kTmFtZSwgdGhyZXNob2xkICkge1xuICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMTAwO1xuICAvLyBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG1ldGhvZCA9IF9jbGFzcy5wcm90b3R5cGVbIG1ldGhvZE5hbWUgXTtcbiAgdmFyIHRpbWVvdXROYW1lID0gbWV0aG9kTmFtZSArICdUaW1lb3V0JztcblxuICBfY2xhc3MucHJvdG90eXBlWyBtZXRob2ROYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXNbIHRpbWVvdXROYW1lIF07XG4gICAgY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXNbIHRpbWVvdXROYW1lIF0gPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgIG1ldGhvZC5hcHBseSggX3RoaXMsIGFyZ3MgKTtcbiAgICAgIGRlbGV0ZSBfdGhpc1sgdGltZW91dE5hbWUgXTtcbiAgICB9LCB0aHJlc2hvbGQgKTtcbiAgfTtcbn07XG5cbi8vIC0tLS0tIGRvY1JlYWR5IC0tLS0tIC8vXG5cbnV0aWxzLmRvY1JlYWR5ID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuICB2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGU7XG4gIGlmICggcmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnIHx8IHJlYWR5U3RhdGUgPT0gJ2ludGVyYWN0aXZlJyApIHtcbiAgICAvLyBkbyBhc3luYyB0byBhbGxvdyBmb3Igb3RoZXIgc2NyaXB0cyB0byBydW4uIG1ldGFmaXp6eS9mbGlja2l0eSM0NDFcbiAgICBzZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2sgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gaHRtbEluaXQgLS0tLS0gLy9cblxuLy8gaHR0cDovL2phbWVzcm9iZXJ0cy5uYW1lL2Jsb2cvMjAxMC8wMi8yMi9zdHJpbmctZnVuY3Rpb25zLWZvci1qYXZhc2NyaXB0LXRyaW0tdG8tY2FtZWwtY2FzZS10by1kYXNoZWQtYW5kLXRvLXVuZGVyc2NvcmUvXG51dGlscy50b0Rhc2hlZCA9IGZ1bmN0aW9uKCBzdHIgKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSggLyguKShbQS1aXSkvZywgZnVuY3Rpb24oIG1hdGNoLCAkMSwgJDIgKSB7XG4gICAgcmV0dXJuICQxICsgJy0nICsgJDI7XG4gIH0pLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuLyoqXG4gKiBhbGxvdyB1c2VyIHRvIGluaXRpYWxpemUgY2xhc3NlcyB2aWEgW2RhdGEtbmFtZXNwYWNlXSBvciAuanMtbmFtZXNwYWNlIGNsYXNzXG4gKiBodG1sSW5pdCggV2lkZ2V0LCAnd2lkZ2V0TmFtZScgKVxuICogb3B0aW9ucyBhcmUgcGFyc2VkIGZyb20gZGF0YS1uYW1lc3BhY2Utb3B0aW9uc1xuICovXG51dGlscy5odG1sSW5pdCA9IGZ1bmN0aW9uKCBXaWRnZXRDbGFzcywgbmFtZXNwYWNlICkge1xuICB1dGlscy5kb2NSZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhc2hlZE5hbWVzcGFjZSA9IHV0aWxzLnRvRGFzaGVkKCBuYW1lc3BhY2UgKTtcbiAgICB2YXIgZGF0YUF0dHIgPSAnZGF0YS0nICsgZGFzaGVkTmFtZXNwYWNlO1xuICAgIHZhciBkYXRhQXR0ckVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggJ1snICsgZGF0YUF0dHIgKyAnXScgKTtcbiAgICB2YXIganNEYXNoRWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCAnLmpzLScgKyBkYXNoZWROYW1lc3BhY2UgKTtcbiAgICB2YXIgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGRhdGFBdHRyRWxlbXMgKVxuICAgICAgLmNvbmNhdCggdXRpbHMubWFrZUFycmF5KCBqc0Rhc2hFbGVtcyApICk7XG4gICAgdmFyIGRhdGFPcHRpb25zQXR0ciA9IGRhdGFBdHRyICsgJy1vcHRpb25zJztcbiAgICB2YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcblxuICAgIGVsZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgdmFyIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggZGF0YUF0dHIgKSB8fFxuICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggZGF0YU9wdGlvbnNBdHRyICk7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdGlvbnMgPSBhdHRyICYmIEpTT04ucGFyc2UoIGF0dHIgKTtcbiAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgLy8gbG9nIGVycm9yLCBkbyBub3QgaW5pdGlhbGl6ZVxuICAgICAgICBpZiAoIGNvbnNvbGUgKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ0Vycm9yIHBhcnNpbmcgJyArIGRhdGFBdHRyICsgJyBvbiAnICsgZWxlbS5jbGFzc05hbWUgK1xuICAgICAgICAgICc6ICcgKyBlcnJvciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXaWRnZXRDbGFzcyggZWxlbSwgb3B0aW9ucyApO1xuICAgICAgLy8gbWFrZSBhdmFpbGFibGUgdmlhICQoKS5kYXRhKCduYW1lc3BhY2UnKVxuICAgICAgaWYgKCBqUXVlcnkgKSB7XG4gICAgICAgIGpRdWVyeS5kYXRhKCBlbGVtLCBuYW1lc3BhY2UsIGluc3RhbmNlICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIHV0aWxzO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsV0FZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fizzy-ui-utils/utils.js\n")},"./node_modules/flickity/js/add-remove-cell.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// add, remove cell\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Flickity, utils ) {\n      return factory( window, Flickity, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Flickity, utils ) {\n\n'use strict';\n\n// append cells to a document fragment\nfunction getCellsFragment( cells ) {\n  var fragment = document.createDocumentFragment();\n  cells.forEach( function( cell ) {\n    fragment.appendChild( cell.element );\n  });\n  return fragment;\n}\n\n// -------------------------- add/remove cell prototype -------------------------- //\n\nvar proto = Flickity.prototype;\n\n/**\n * Insert, prepend, or append cells\n * @param {Element, Array, NodeList} elems\n * @param {Integer} index\n */\nproto.insert = function( elems, index ) {\n  var cells = this._makeCells( elems );\n  if ( !cells || !cells.length ) {\n    return;\n  }\n  var len = this.cells.length;\n  // default to append\n  index = index === undefined ? len : index;\n  // add cells with document fragment\n  var fragment = getCellsFragment( cells );\n  // append to slider\n  var isAppend = index == len;\n  if ( isAppend ) {\n    this.slider.appendChild( fragment );\n  } else {\n    var insertCellElement = this.cells[ index ].element;\n    this.slider.insertBefore( fragment, insertCellElement );\n  }\n  // add to this.cells\n  if ( index === 0 ) {\n    // prepend, add to start\n    this.cells = cells.concat( this.cells );\n  } else if ( isAppend ) {\n    // append, add to end\n    this.cells = this.cells.concat( cells );\n  } else {\n    // insert in this.cells\n    var endCells = this.cells.splice( index, len - index );\n    this.cells = this.cells.concat( cells ).concat( endCells );\n  }\n\n  this._sizeCells( cells );\n  this.cellChange( index, true );\n};\n\nproto.append = function( elems ) {\n  this.insert( elems, this.cells.length );\n};\n\nproto.prepend = function( elems ) {\n  this.insert( elems, 0 );\n};\n\n/**\n * Remove cells\n * @param {Element, Array, NodeList} elems\n */\nproto.remove = function( elems ) {\n  var cells = this.getCells( elems );\n  if ( !cells || !cells.length ) {\n    return;\n  }\n\n  var minCellIndex = this.cells.length - 1;\n  // remove cells from collection & DOM\n  cells.forEach( function( cell ) {\n    cell.remove();\n    var index = this.cells.indexOf( cell );\n    minCellIndex = Math.min( index, minCellIndex );\n    utils.removeFrom( this.cells, cell );\n  }, this );\n\n  this.cellChange( minCellIndex, true );\n};\n\n/**\n * logic to be run after a cell's size changes\n * @param {Element} elem - cell's element\n */\nproto.cellSizeChange = function( elem ) {\n  var cell = this.getCell( elem );\n  if ( !cell ) {\n    return;\n  }\n  cell.getSize();\n\n  var index = this.cells.indexOf( cell );\n  this.cellChange( index );\n};\n\n/**\n * logic any time a cell is changed: added, removed, or size changed\n * @param {Integer} changedCellIndex - index of the changed cell, optional\n */\nproto.cellChange = function( changedCellIndex, isPositioningSlider ) {\n  var prevSelectedElem = this.selectedElement;\n  this._positionCells( changedCellIndex );\n  this._getWrapShiftCells();\n  this.setGallerySize();\n  // update selectedIndex\n  // try to maintain position & select previous selected element\n  var cell = this.getCell( prevSelectedElem );\n  if ( cell ) {\n    this.selectedIndex = this.getCellSlideIndex( cell );\n  }\n  this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );\n\n  this.emitEvent( 'cellChange', [ changedCellIndex ] );\n  // position slider\n  this.select( this.selectedIndex );\n  // do not position slider after lazy load\n  if ( isPositioningSlider ) {\n    this.positionSliderAtSelected();\n  }\n};\n\n// -----  ----- //\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvYWRkLXJlbW92ZS1jZWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL2FkZC1yZW1vdmUtY2VsbC5qcz9iZDdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGFkZCwgcmVtb3ZlIGNlbGxcbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnLi9mbGlja2l0eScsXG4gICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnXG4gICAgXSwgZnVuY3Rpb24oIEZsaWNraXR5LCB1dGlscyApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCB1dGlscyApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnLi9mbGlja2l0eScpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkZsaWNraXR5LFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCB1dGlscyApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBhcHBlbmQgY2VsbHMgdG8gYSBkb2N1bWVudCBmcmFnbWVudFxuZnVuY3Rpb24gZ2V0Q2VsbHNGcmFnbWVudCggY2VsbHMgKSB7XG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNlbGwuZWxlbWVudCApO1xuICB9KTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBhZGQvcmVtb3ZlIGNlbGwgcHJvdG90eXBlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBwcm90byA9IEZsaWNraXR5LnByb3RvdHlwZTtcblxuLyoqXG4gKiBJbnNlcnQsIHByZXBlbmQsIG9yIGFwcGVuZCBjZWxsc1xuICogQHBhcmFtIHtFbGVtZW50LCBBcnJheSwgTm9kZUxpc3R9IGVsZW1zXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4XG4gKi9cbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKCBlbGVtcywgaW5kZXggKSB7XG4gIHZhciBjZWxscyA9IHRoaXMuX21ha2VDZWxscyggZWxlbXMgKTtcbiAgaWYgKCAhY2VsbHMgfHwgIWNlbGxzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuY2VsbHMubGVuZ3RoO1xuICAvLyBkZWZhdWx0IHRvIGFwcGVuZFxuICBpbmRleCA9IGluZGV4ID09PSB1bmRlZmluZWQgPyBsZW4gOiBpbmRleDtcbiAgLy8gYWRkIGNlbGxzIHdpdGggZG9jdW1lbnQgZnJhZ21lbnRcbiAgdmFyIGZyYWdtZW50ID0gZ2V0Q2VsbHNGcmFnbWVudCggY2VsbHMgKTtcbiAgLy8gYXBwZW5kIHRvIHNsaWRlclxuICB2YXIgaXNBcHBlbmQgPSBpbmRleCA9PSBsZW47XG4gIGlmICggaXNBcHBlbmQgKSB7XG4gICAgdGhpcy5zbGlkZXIuYXBwZW5kQ2hpbGQoIGZyYWdtZW50ICk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc2VydENlbGxFbGVtZW50ID0gdGhpcy5jZWxsc1sgaW5kZXggXS5lbGVtZW50O1xuICAgIHRoaXMuc2xpZGVyLmluc2VydEJlZm9yZSggZnJhZ21lbnQsIGluc2VydENlbGxFbGVtZW50ICk7XG4gIH1cbiAgLy8gYWRkIHRvIHRoaXMuY2VsbHNcbiAgaWYgKCBpbmRleCA9PT0gMCApIHtcbiAgICAvLyBwcmVwZW5kLCBhZGQgdG8gc3RhcnRcbiAgICB0aGlzLmNlbGxzID0gY2VsbHMuY29uY2F0KCB0aGlzLmNlbGxzICk7XG4gIH0gZWxzZSBpZiAoIGlzQXBwZW5kICkge1xuICAgIC8vIGFwcGVuZCwgYWRkIHRvIGVuZFxuICAgIHRoaXMuY2VsbHMgPSB0aGlzLmNlbGxzLmNvbmNhdCggY2VsbHMgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbnNlcnQgaW4gdGhpcy5jZWxsc1xuICAgIHZhciBlbmRDZWxscyA9IHRoaXMuY2VsbHMuc3BsaWNlKCBpbmRleCwgbGVuIC0gaW5kZXggKTtcbiAgICB0aGlzLmNlbGxzID0gdGhpcy5jZWxscy5jb25jYXQoIGNlbGxzICkuY29uY2F0KCBlbmRDZWxscyApO1xuICB9XG5cbiAgdGhpcy5fc2l6ZUNlbGxzKCBjZWxscyApO1xuICB0aGlzLmNlbGxDaGFuZ2UoIGluZGV4LCB0cnVlICk7XG59O1xuXG5wcm90by5hcHBlbmQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHRoaXMuaW5zZXJ0KCBlbGVtcywgdGhpcy5jZWxscy5sZW5ndGggKTtcbn07XG5cbnByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHRoaXMuaW5zZXJ0KCBlbGVtcywgMCApO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2VsbHNcbiAqIEBwYXJhbSB7RWxlbWVudCwgQXJyYXksIE5vZGVMaXN0fSBlbGVtc1xuICovXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoIGVsZW1zICk7XG4gIGlmICggIWNlbGxzIHx8ICFjZWxscy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1pbkNlbGxJbmRleCA9IHRoaXMuY2VsbHMubGVuZ3RoIC0gMTtcbiAgLy8gcmVtb3ZlIGNlbGxzIGZyb20gY29sbGVjdGlvbiAmIERPTVxuICBjZWxscy5mb3JFYWNoKCBmdW5jdGlvbiggY2VsbCApIHtcbiAgICBjZWxsLnJlbW92ZSgpO1xuICAgIHZhciBpbmRleCA9IHRoaXMuY2VsbHMuaW5kZXhPZiggY2VsbCApO1xuICAgIG1pbkNlbGxJbmRleCA9IE1hdGgubWluKCBpbmRleCwgbWluQ2VsbEluZGV4ICk7XG4gICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5jZWxscywgY2VsbCApO1xuICB9LCB0aGlzICk7XG5cbiAgdGhpcy5jZWxsQ2hhbmdlKCBtaW5DZWxsSW5kZXgsIHRydWUgKTtcbn07XG5cbi8qKlxuICogbG9naWMgdG8gYmUgcnVuIGFmdGVyIGEgY2VsbCdzIHNpemUgY2hhbmdlc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gY2VsbCdzIGVsZW1lbnRcbiAqL1xucHJvdG8uY2VsbFNpemVDaGFuZ2UgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGwoIGVsZW0gKTtcbiAgaWYgKCAhY2VsbCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY2VsbC5nZXRTaXplKCk7XG5cbiAgdmFyIGluZGV4ID0gdGhpcy5jZWxscy5pbmRleE9mKCBjZWxsICk7XG4gIHRoaXMuY2VsbENoYW5nZSggaW5kZXggKTtcbn07XG5cbi8qKlxuICogbG9naWMgYW55IHRpbWUgYSBjZWxsIGlzIGNoYW5nZWQ6IGFkZGVkLCByZW1vdmVkLCBvciBzaXplIGNoYW5nZWRcbiAqIEBwYXJhbSB7SW50ZWdlcn0gY2hhbmdlZENlbGxJbmRleCAtIGluZGV4IG9mIHRoZSBjaGFuZ2VkIGNlbGwsIG9wdGlvbmFsXG4gKi9cbnByb3RvLmNlbGxDaGFuZ2UgPSBmdW5jdGlvbiggY2hhbmdlZENlbGxJbmRleCwgaXNQb3NpdGlvbmluZ1NsaWRlciApIHtcbiAgdmFyIHByZXZTZWxlY3RlZEVsZW0gPSB0aGlzLnNlbGVjdGVkRWxlbWVudDtcbiAgdGhpcy5fcG9zaXRpb25DZWxscyggY2hhbmdlZENlbGxJbmRleCApO1xuICB0aGlzLl9nZXRXcmFwU2hpZnRDZWxscygpO1xuICB0aGlzLnNldEdhbGxlcnlTaXplKCk7XG4gIC8vIHVwZGF0ZSBzZWxlY3RlZEluZGV4XG4gIC8vIHRyeSB0byBtYWludGFpbiBwb3NpdGlvbiAmIHNlbGVjdCBwcmV2aW91cyBzZWxlY3RlZCBlbGVtZW50XG4gIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKCBwcmV2U2VsZWN0ZWRFbGVtICk7XG4gIGlmICggY2VsbCApIHtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLmdldENlbGxTbGlkZUluZGV4KCBjZWxsICk7XG4gIH1cbiAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5taW4oIHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEsIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuXG4gIHRoaXMuZW1pdEV2ZW50KCAnY2VsbENoYW5nZScsIFsgY2hhbmdlZENlbGxJbmRleCBdICk7XG4gIC8vIHBvc2l0aW9uIHNsaWRlclxuICB0aGlzLnNlbGVjdCggdGhpcy5zZWxlY3RlZEluZGV4ICk7XG4gIC8vIGRvIG5vdCBwb3NpdGlvbiBzbGlkZXIgYWZ0ZXIgbGF6eSBsb2FkXG4gIGlmICggaXNQb3NpdGlvbmluZ1NsaWRlciApIHtcbiAgICB0aGlzLnBvc2l0aW9uU2xpZGVyQXRTZWxlY3RlZCgpO1xuICB9XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsV0FjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/add-remove-cell.js\n")},"./node_modules/flickity/js/animate.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// animate\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( utils ) {\n      return factory( window, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, utils ) {\n\n'use strict';\n\n// -------------------------- animate -------------------------- //\n\nvar proto = {};\n\nproto.startAnimation = function() {\n  if ( this.isAnimating ) {\n    return;\n  }\n\n  this.isAnimating = true;\n  this.restingFrames = 0;\n  this.animate();\n};\n\nproto.animate = function() {\n  this.applyDragForce();\n  this.applySelectedAttraction();\n\n  var previousX = this.x;\n\n  this.integratePhysics();\n  this.positionSlider();\n  this.settle( previousX );\n  // animate next frame\n  if ( this.isAnimating ) {\n    var _this = this;\n    requestAnimationFrame( function animateFrame() {\n      _this.animate();\n    });\n  }\n};\n\nproto.positionSlider = function() {\n  var x = this.x;\n  // wrap position around\n  if ( this.options.wrapAround && this.cells.length > 1 ) {\n    x = utils.modulo( x, this.slideableWidth );\n    x = x - this.slideableWidth;\n    this.shiftWrapCells( x );\n  }\n\n  x = x + this.cursorPosition;\n  // reverse if right-to-left and using transform\n  x = this.options.rightToLeft ? -x : x;\n  var value = this.getPositionValue( x );\n  // use 3D tranforms for hardware acceleration on iOS\n  // but use 2D when settled, for better font-rendering\n  this.slider.style.transform = this.isAnimating ?\n    'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';\n\n  // scroll event\n  var firstSlide = this.slides[0];\n  if ( firstSlide ) {\n    var positionX = -this.x - firstSlide.target;\n    var progress = positionX / this.slidesWidth;\n    this.dispatchEvent( 'scroll', null, [ progress, positionX ] );\n  }\n};\n\nproto.positionSliderAtSelected = function() {\n  if ( !this.cells.length ) {\n    return;\n  }\n  this.x = -this.selectedSlide.target;\n  this.velocity = 0; // stop wobble\n  this.positionSlider();\n};\n\nproto.getPositionValue = function( position ) {\n  if ( this.options.percentPosition ) {\n    // percent position, round to 2 digits, like 12.34%\n    return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 )+ '%';\n  } else {\n    // pixel positioning\n    return Math.round( position ) + 'px';\n  }\n};\n\nproto.settle = function( previousX ) {\n  // keep track of frames where x hasn't moved\n  if ( !this.isPointerDown && Math.round( this.x * 100 ) == Math.round( previousX * 100 ) ) {\n    this.restingFrames++;\n  }\n  // stop animating if resting for 3 or more frames\n  if ( this.restingFrames > 2 ) {\n    this.isAnimating = false;\n    delete this.isFreeScrolling;\n    // render position with translateX when settled\n    this.positionSlider();\n    this.dispatchEvent( 'settle', null, [ this.selectedIndex ] );\n  }\n};\n\nproto.shiftWrapCells = function( x ) {\n  // shift before cells\n  var beforeGap = this.cursorPosition + x;\n  this._shiftCells( this.beforeShiftCells, beforeGap, -1 );\n  // shift after cells\n  var afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );\n  this._shiftCells( this.afterShiftCells, afterGap, 1 );\n};\n\nproto._shiftCells = function( cells, gap, shift ) {\n  for ( var i=0; i < cells.length; i++ ) {\n    var cell = cells[i];\n    var cellShift = gap > 0 ? shift : 0;\n    cell.wrapShift( cellShift );\n    gap -= cell.size.outerWidth;\n  }\n};\n\nproto._unshiftCells = function( cells ) {\n  if ( !cells || !cells.length ) {\n    return;\n  }\n  for ( var i=0; i < cells.length; i++ ) {\n    cells[i].wrapShift( 0 );\n  }\n};\n\n// -------------------------- physics -------------------------- //\n\nproto.integratePhysics = function() {\n  this.x += this.velocity;\n  this.velocity *= this.getFrictionFactor();\n};\n\nproto.applyForce = function( force ) {\n  this.velocity += force;\n};\n\nproto.getFrictionFactor = function() {\n  return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];\n};\n\nproto.getRestingPosition = function() {\n  // my thanks to Steven Wittens, who simplified this math greatly\n  return this.x + this.velocity / ( 1 - this.getFrictionFactor() );\n};\n\nproto.applyDragForce = function() {\n  if ( !this.isDraggable || !this.isPointerDown ) {\n    return;\n  }\n  // change the position to drag position by applying force\n  var dragVelocity = this.dragX - this.x;\n  var dragForce = dragVelocity - this.velocity;\n  this.applyForce( dragForce );\n};\n\nproto.applySelectedAttraction = function() {\n  // do not attract if pointer down or no slides\n  var dragDown = this.isDraggable && this.isPointerDown;\n  if ( dragDown || this.isFreeScrolling || !this.slides.length ) {\n    return;\n  }\n  var distance = this.selectedSlide.target * -1 - this.x;\n  var force = distance * this.options.selectedAttraction;\n  this.applyForce( force );\n};\n\nreturn proto;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvYW5pbWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9hbmltYXRlLmpzPzAxNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYW5pbWF0ZVxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCB1dGlscyApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuRmxpY2tpdHkgPSB3aW5kb3cuRmxpY2tpdHkgfHwge307XG4gICAgd2luZG93LkZsaWNraXR5LmFuaW1hdGVQcm90b3R5cGUgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIHV0aWxzICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGFuaW1hdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIHByb3RvID0ge307XG5cbnByb3RvLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5pc0FuaW1hdGluZyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgdGhpcy5yZXN0aW5nRnJhbWVzID0gMDtcbiAgdGhpcy5hbmltYXRlKCk7XG59O1xuXG5wcm90by5hbmltYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYXBwbHlEcmFnRm9yY2UoKTtcbiAgdGhpcy5hcHBseVNlbGVjdGVkQXR0cmFjdGlvbigpO1xuXG4gIHZhciBwcmV2aW91c1ggPSB0aGlzLng7XG5cbiAgdGhpcy5pbnRlZ3JhdGVQaHlzaWNzKCk7XG4gIHRoaXMucG9zaXRpb25TbGlkZXIoKTtcbiAgdGhpcy5zZXR0bGUoIHByZXZpb3VzWCApO1xuICAvLyBhbmltYXRlIG5leHQgZnJhbWVcbiAgaWYgKCB0aGlzLmlzQW5pbWF0aW5nICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmdW5jdGlvbiBhbmltYXRlRnJhbWUoKSB7XG4gICAgICBfdGhpcy5hbmltYXRlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnByb3RvLnBvc2l0aW9uU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcy54O1xuICAvLyB3cmFwIHBvc2l0aW9uIGFyb3VuZFxuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kICYmIHRoaXMuY2VsbHMubGVuZ3RoID4gMSApIHtcbiAgICB4ID0gdXRpbHMubW9kdWxvKCB4LCB0aGlzLnNsaWRlYWJsZVdpZHRoICk7XG4gICAgeCA9IHggLSB0aGlzLnNsaWRlYWJsZVdpZHRoO1xuICAgIHRoaXMuc2hpZnRXcmFwQ2VsbHMoIHggKTtcbiAgfVxuXG4gIHggPSB4ICsgdGhpcy5jdXJzb3JQb3NpdGlvbjtcbiAgLy8gcmV2ZXJzZSBpZiByaWdodC10by1sZWZ0IGFuZCB1c2luZyB0cmFuc2Zvcm1cbiAgeCA9IHRoaXMub3B0aW9ucy5yaWdodFRvTGVmdCA/IC14IDogeDtcbiAgdmFyIHZhbHVlID0gdGhpcy5nZXRQb3NpdGlvblZhbHVlKCB4ICk7XG4gIC8vIHVzZSAzRCB0cmFuZm9ybXMgZm9yIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiBvbiBpT1NcbiAgLy8gYnV0IHVzZSAyRCB3aGVuIHNldHRsZWQsIGZvciBiZXR0ZXIgZm9udC1yZW5kZXJpbmdcbiAgdGhpcy5zbGlkZXIuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5pc0FuaW1hdGluZyA/XG4gICAgJ3RyYW5zbGF0ZTNkKCcgKyB2YWx1ZSArICcsMCwwKScgOiAndHJhbnNsYXRlWCgnICsgdmFsdWUgKyAnKSc7XG5cbiAgLy8gc2Nyb2xsIGV2ZW50XG4gIHZhciBmaXJzdFNsaWRlID0gdGhpcy5zbGlkZXNbMF07XG4gIGlmICggZmlyc3RTbGlkZSApIHtcbiAgICB2YXIgcG9zaXRpb25YID0gLXRoaXMueCAtIGZpcnN0U2xpZGUudGFyZ2V0O1xuICAgIHZhciBwcm9ncmVzcyA9IHBvc2l0aW9uWCAvIHRoaXMuc2xpZGVzV2lkdGg7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnc2Nyb2xsJywgbnVsbCwgWyBwcm9ncmVzcywgcG9zaXRpb25YIF0gKTtcbiAgfVxufTtcblxucHJvdG8ucG9zaXRpb25TbGlkZXJBdFNlbGVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuY2VsbHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnggPSAtdGhpcy5zZWxlY3RlZFNsaWRlLnRhcmdldDtcbiAgdGhpcy52ZWxvY2l0eSA9IDA7IC8vIHN0b3Agd29iYmxlXG4gIHRoaXMucG9zaXRpb25TbGlkZXIoKTtcbn07XG5cbnByb3RvLmdldFBvc2l0aW9uVmFsdWUgPSBmdW5jdGlvbiggcG9zaXRpb24gKSB7XG4gIGlmICggdGhpcy5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiApIHtcbiAgICAvLyBwZXJjZW50IHBvc2l0aW9uLCByb3VuZCB0byAyIGRpZ2l0cywgbGlrZSAxMi4zNCVcbiAgICByZXR1cm4gKCBNYXRoLnJvdW5kKCAoIHBvc2l0aW9uIC8gdGhpcy5zaXplLmlubmVyV2lkdGggKSAqIDEwMDAwICkgKiAwLjAxICkrICclJztcbiAgfSBlbHNlIHtcbiAgICAvLyBwaXhlbCBwb3NpdGlvbmluZ1xuICAgIHJldHVybiBNYXRoLnJvdW5kKCBwb3NpdGlvbiApICsgJ3B4JztcbiAgfVxufTtcblxucHJvdG8uc2V0dGxlID0gZnVuY3Rpb24oIHByZXZpb3VzWCApIHtcbiAgLy8ga2VlcCB0cmFjayBvZiBmcmFtZXMgd2hlcmUgeCBoYXNuJ3QgbW92ZWRcbiAgaWYgKCAhdGhpcy5pc1BvaW50ZXJEb3duICYmIE1hdGgucm91bmQoIHRoaXMueCAqIDEwMCApID09IE1hdGgucm91bmQoIHByZXZpb3VzWCAqIDEwMCApICkge1xuICAgIHRoaXMucmVzdGluZ0ZyYW1lcysrO1xuICB9XG4gIC8vIHN0b3AgYW5pbWF0aW5nIGlmIHJlc3RpbmcgZm9yIDMgb3IgbW9yZSBmcmFtZXNcbiAgaWYgKCB0aGlzLnJlc3RpbmdGcmFtZXMgPiAyICkge1xuICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBkZWxldGUgdGhpcy5pc0ZyZWVTY3JvbGxpbmc7XG4gICAgLy8gcmVuZGVyIHBvc2l0aW9uIHdpdGggdHJhbnNsYXRlWCB3aGVuIHNldHRsZWRcbiAgICB0aGlzLnBvc2l0aW9uU2xpZGVyKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnc2V0dGxlJywgbnVsbCwgWyB0aGlzLnNlbGVjdGVkSW5kZXggXSApO1xuICB9XG59O1xuXG5wcm90by5zaGlmdFdyYXBDZWxscyA9IGZ1bmN0aW9uKCB4ICkge1xuICAvLyBzaGlmdCBiZWZvcmUgY2VsbHNcbiAgdmFyIGJlZm9yZUdhcCA9IHRoaXMuY3Vyc29yUG9zaXRpb24gKyB4O1xuICB0aGlzLl9zaGlmdENlbGxzKCB0aGlzLmJlZm9yZVNoaWZ0Q2VsbHMsIGJlZm9yZUdhcCwgLTEgKTtcbiAgLy8gc2hpZnQgYWZ0ZXIgY2VsbHNcbiAgdmFyIGFmdGVyR2FwID0gdGhpcy5zaXplLmlubmVyV2lkdGggLSAoIHggKyB0aGlzLnNsaWRlYWJsZVdpZHRoICsgdGhpcy5jdXJzb3JQb3NpdGlvbiApO1xuICB0aGlzLl9zaGlmdENlbGxzKCB0aGlzLmFmdGVyU2hpZnRDZWxscywgYWZ0ZXJHYXAsIDEgKTtcbn07XG5cbnByb3RvLl9zaGlmdENlbGxzID0gZnVuY3Rpb24oIGNlbGxzLCBnYXAsIHNoaWZ0ICkge1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgY2VsbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGNlbGwgPSBjZWxsc1tpXTtcbiAgICB2YXIgY2VsbFNoaWZ0ID0gZ2FwID4gMCA/IHNoaWZ0IDogMDtcbiAgICBjZWxsLndyYXBTaGlmdCggY2VsbFNoaWZ0ICk7XG4gICAgZ2FwIC09IGNlbGwuc2l6ZS5vdXRlcldpZHRoO1xuICB9XG59O1xuXG5wcm90by5fdW5zaGlmdENlbGxzID0gZnVuY3Rpb24oIGNlbGxzICkge1xuICBpZiAoICFjZWxscyB8fCAhY2VsbHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKCB2YXIgaT0wOyBpIDwgY2VsbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgY2VsbHNbaV0ud3JhcFNoaWZ0KCAwICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHBoeXNpY3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucHJvdG8uaW50ZWdyYXRlUGh5c2ljcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnggKz0gdGhpcy52ZWxvY2l0eTtcbiAgdGhpcy52ZWxvY2l0eSAqPSB0aGlzLmdldEZyaWN0aW9uRmFjdG9yKCk7XG59O1xuXG5wcm90by5hcHBseUZvcmNlID0gZnVuY3Rpb24oIGZvcmNlICkge1xuICB0aGlzLnZlbG9jaXR5ICs9IGZvcmNlO1xufTtcblxucHJvdG8uZ2V0RnJpY3Rpb25GYWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDEgLSB0aGlzLm9wdGlvbnNbIHRoaXMuaXNGcmVlU2Nyb2xsaW5nID8gJ2ZyZWVTY3JvbGxGcmljdGlvbicgOiAnZnJpY3Rpb24nIF07XG59O1xuXG5wcm90by5nZXRSZXN0aW5nUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgLy8gbXkgdGhhbmtzIHRvIFN0ZXZlbiBXaXR0ZW5zLCB3aG8gc2ltcGxpZmllZCB0aGlzIG1hdGggZ3JlYXRseVxuICByZXR1cm4gdGhpcy54ICsgdGhpcy52ZWxvY2l0eSAvICggMSAtIHRoaXMuZ2V0RnJpY3Rpb25GYWN0b3IoKSApO1xufTtcblxucHJvdG8uYXBwbHlEcmFnRm9yY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0RyYWdnYWJsZSB8fCAhdGhpcy5pc1BvaW50ZXJEb3duICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjaGFuZ2UgdGhlIHBvc2l0aW9uIHRvIGRyYWcgcG9zaXRpb24gYnkgYXBwbHlpbmcgZm9yY2VcbiAgdmFyIGRyYWdWZWxvY2l0eSA9IHRoaXMuZHJhZ1ggLSB0aGlzLng7XG4gIHZhciBkcmFnRm9yY2UgPSBkcmFnVmVsb2NpdHkgLSB0aGlzLnZlbG9jaXR5O1xuICB0aGlzLmFwcGx5Rm9yY2UoIGRyYWdGb3JjZSApO1xufTtcblxucHJvdG8uYXBwbHlTZWxlY3RlZEF0dHJhY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gbm90IGF0dHJhY3QgaWYgcG9pbnRlciBkb3duIG9yIG5vIHNsaWRlc1xuICB2YXIgZHJhZ0Rvd24gPSB0aGlzLmlzRHJhZ2dhYmxlICYmIHRoaXMuaXNQb2ludGVyRG93bjtcbiAgaWYgKCBkcmFnRG93biB8fCB0aGlzLmlzRnJlZVNjcm9sbGluZyB8fCAhdGhpcy5zbGlkZXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGlzdGFuY2UgPSB0aGlzLnNlbGVjdGVkU2xpZGUudGFyZ2V0ICogLTEgLSB0aGlzLng7XG4gIHZhciBmb3JjZSA9IGRpc3RhbmNlICogdGhpcy5vcHRpb25zLnNlbGVjdGVkQXR0cmFjdGlvbjtcbiAgdGhpcy5hcHBseUZvcmNlKCBmb3JjZSApO1xufTtcblxucmV0dXJuIHByb3RvO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/animate.js\n")},"./node_modules/flickity/js/cell.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Flickity.Cell\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( getSize ) {\n      return factory( window, getSize );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, getSize ) {\n\n'use strict';\n\nfunction Cell( elem, parent ) {\n  this.element = elem;\n  this.parent = parent;\n\n  this.create();\n}\n\nvar proto = Cell.prototype;\n\nproto.create = function() {\n  this.element.style.position = 'absolute';\n  this.element.setAttribute( 'aria-selected', 'false' );\n  this.x = 0;\n  this.shift = 0;\n};\n\nproto.destroy = function() {\n  // reset style\n  this.element.style.position = '';\n  var side = this.parent.originSide;\n  this.element.removeAttribute('aria-selected');\n  this.element.style[ side ] = '';\n};\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n};\n\nproto.setPosition = function( x ) {\n  this.x = x;\n  this.updateTarget();\n  this.renderPosition( x );\n};\n\n// setDefaultTarget v1 method, backwards compatibility, remove in v3\nproto.updateTarget = proto.setDefaultTarget = function() {\n  var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';\n  this.target = this.x + this.size[ marginProperty ] +\n    this.size.width * this.parent.cellAlign;\n};\n\nproto.renderPosition = function( x ) {\n  // render position of cell with in slider\n  var side = this.parent.originSide;\n  this.element.style[ side ] = this.parent.getPositionValue( x );\n};\n\n/**\n * @param {Integer} factor - 0, 1, or -1\n**/\nproto.wrapShift = function( shift ) {\n  this.shift = shift;\n  this.renderPosition( this.x + this.parent.slideableWidth * shift );\n};\n\nproto.remove = function() {\n  this.element.parentNode.removeChild( this.element );\n};\n\nreturn Cell;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvY2VsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9jZWxsLmpzP2M4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmxpY2tpdHkuQ2VsbFxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZSdcbiAgICBdLCBmdW5jdGlvbiggZ2V0U2l6ZSApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LkZsaWNraXR5ID0gd2luZG93LkZsaWNraXR5IHx8IHt9O1xuICAgIHdpbmRvdy5GbGlja2l0eS5DZWxsID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgZ2V0U2l6ZSApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBDZWxsKCBlbGVtLCBwYXJlbnQgKSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW07XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbnZhciBwcm90byA9IENlbGwucHJvdG90eXBlO1xuXG5wcm90by5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSggJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnICk7XG4gIHRoaXMueCA9IDA7XG4gIHRoaXMuc2hpZnQgPSAwO1xufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZXNldCBzdHlsZVxuICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgdmFyIHNpZGUgPSB0aGlzLnBhcmVudC5vcmlnaW5TaWRlO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XG4gIHRoaXMuZWxlbWVudC5zdHlsZVsgc2lkZSBdID0gJyc7XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xufTtcblxucHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiggeCApIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy51cGRhdGVUYXJnZXQoKTtcbiAgdGhpcy5yZW5kZXJQb3NpdGlvbiggeCApO1xufTtcblxuLy8gc2V0RGVmYXVsdFRhcmdldCB2MSBtZXRob2QsIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZW1vdmUgaW4gdjNcbnByb3RvLnVwZGF0ZVRhcmdldCA9IHByb3RvLnNldERlZmF1bHRUYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1hcmdpblByb3BlcnR5ID0gdGhpcy5wYXJlbnQub3JpZ2luU2lkZSA9PSAnbGVmdCcgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnO1xuICB0aGlzLnRhcmdldCA9IHRoaXMueCArIHRoaXMuc2l6ZVsgbWFyZ2luUHJvcGVydHkgXSArXG4gICAgdGhpcy5zaXplLndpZHRoICogdGhpcy5wYXJlbnQuY2VsbEFsaWduO1xufTtcblxucHJvdG8ucmVuZGVyUG9zaXRpb24gPSBmdW5jdGlvbiggeCApIHtcbiAgLy8gcmVuZGVyIHBvc2l0aW9uIG9mIGNlbGwgd2l0aCBpbiBzbGlkZXJcbiAgdmFyIHNpZGUgPSB0aGlzLnBhcmVudC5vcmlnaW5TaWRlO1xuICB0aGlzLmVsZW1lbnQuc3R5bGVbIHNpZGUgXSA9IHRoaXMucGFyZW50LmdldFBvc2l0aW9uVmFsdWUoIHggKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfSBmYWN0b3IgLSAwLCAxLCBvciAtMVxuKiovXG5wcm90by53cmFwU2hpZnQgPSBmdW5jdGlvbiggc2hpZnQgKSB7XG4gIHRoaXMuc2hpZnQgPSBzaGlmdDtcbiAgdGhpcy5yZW5kZXJQb3NpdGlvbiggdGhpcy54ICsgdGhpcy5wYXJlbnQuc2xpZGVhYmxlV2lkdGggKiBzaGlmdCApO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbnJldHVybiBDZWxsO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/cell.js\n")},"./node_modules/flickity/js/drag.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// drag\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"),\n      __webpack_require__(/*! unidragger/unidragger */ \"./node_modules/unidragger/unidragger.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Flickity, Unidragger, utils ) {\n      return factory( window, Flickity, Unidragger, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Flickity, Unidragger, utils ) {\n\n'use strict';\n\n// ----- defaults ----- //\n\nutils.extend( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n});\n\n// ----- create ----- //\n\nFlickity.createMethods.push('_createDrag');\n\n// -------------------------- drag prototype -------------------------- //\n\nvar proto = Flickity.prototype;\nutils.extend( proto, Unidragger.prototype );\nproto._touchActionValue = 'pan-y';\n\n// --------------------------  -------------------------- //\n\nvar isTouch = 'createTouch' in document;\nvar isTouchmoveScrollCanceled = false;\n\nproto._createDrag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'childUIPointerDown', this._childUIPointerDownDrag );\n  this.on( 'deactivate', this.unbindDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  // TODO updateDraggable on resize? if groupCells & slides change\n  // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n  // #457, RubaXa/Sortable#973\n  if ( isTouch && !isTouchmoveScrollCanceled ) {\n    window.addEventListener( 'touchmove', function() {});\n    isTouchmoveScrollCanceled = true;\n  }\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable == '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  if ( this.isDraggable ) {\n    this.element.classList.add('is-draggable');\n  } else {\n    this.element.classList.remove('is-draggable');\n  }\n};\n\n// backwards compatibility\nproto.bindDrag = function() {\n  this.options.draggable = true;\n  this.updateDraggable();\n};\n\nproto.unbindDrag = function() {\n  this.options.draggable = false;\n  this.updateDraggable();\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\nproto._childUIPointerDownDrag = function( event ) {\n  // allow focus & preventDefault even when not draggable\n  // so child UI elements keep focus on carousel. #721\n  event.preventDefault();\n  this.pointerDownFocus( event );\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.pointerDown = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    this._pointerDownDefault( event, pointer );\n    return;\n  }\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n\n  this._pointerDownPreventDefault( event );\n  this.pointerDownFocus( event );\n  // blur\n  if ( document.activeElement != this.element ) {\n    // do not blur if already focused\n    this.pointerDownBlur();\n  }\n\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n\n  this._pointerDownDefault( event, pointer );\n};\n\n// default pointerDown logic, used for staticClick\nproto._pointerDownDefault = function( event, pointer ) {\n  // track start event position\n  this.pointerDownPointer = pointer;\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.dispatchEvent( 'pointerDown', event, [ pointer ] );\n};\n\nvar focusNodes = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n};\n\nproto.pointerDownFocus = function( event ) {\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isFocusNode ) {\n    this.focus();\n  }\n};\n\nproto._pointerDownPreventDefault = function( event ) {\n  var isTouchStart = event.type == 'touchstart';\n  var isTouchPointer = event.pointerType == 'touch';\n  var isFocusNode = focusNodes[ event.target.nodeName ];\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) {\n    event.preventDefault();\n  }\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.pointerUp = function( event, pointer ) {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n  this.dispatchEvent( 'pointerUp', event, [ pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto.pointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n};\n\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  var direction = this.options.rightToLeft ? -1 : 1;\n  if ( this.options.wrapAround ) {\n    // wrap around move. #589\n    moveVector.x = moveVector.x % this.slideableWidth;\n  }\n  var dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.options.wrapAround && this.slides.length ) {\n    // slow drag\n    var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n\n  this.dragMoveTime = new Date();\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isDraggable ) {\n    return;\n  }\n  if ( this.options.freeScroll ) {\n    this.isFreeScrolling = true;\n  }\n  // set selectedIndex based on where flick will end up\n  var index = this.dragEndRestingSelect();\n\n  if ( this.options.freeScroll && !this.options.wrapAround ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    var restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !this.options.freeScroll && index == this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // TODO refactor this, selecting here feels weird\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.options.wrapAround;\n  this.select( index );\n  delete this.isDragSelect;\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\nproto.dragEndRestingSelect = function() {\n  var restingX = this.getRestingPosition();\n  // how far away from selected slide\n  var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  var positiveResting = this._getClosestResting( restingX, distance, 1 );\n  var negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  var index = positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n  return index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  var index = this.selectedIndex;\n  var minDistance = Infinity;\n  var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function( d, md ) { return d <= md; } : function( d, md ) { return d < md; };\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) {\n      break;\n    }\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x\n * @param {Integer} index - slide index\n */\nproto.getSlideDistance = function( x, index ) {\n  var len = this.slides.length;\n  // wrap around if at least 2 slides\n  var isWrapAround = this.options.wrapAround && len > 1;\n  var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  var slide = this.slides[ slideIndex ];\n  if ( !slide ) {\n    return null;\n  }\n  // add distance for wrap-around slides\n  var wrap = isWrapAround ? this.slideableWidth * Math.floor( index / len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  var delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  // get clickedCell, if cell was clicked\n  var clickedCell = this.getParentCell( event.target );\n  var cellElem = clickedCell && clickedCell.element;\n  var cellIndex = clickedCell && this.cells.indexOf( clickedCell );\n  this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  var scroll = getScrollPosition();\n  var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this._pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvZHJhZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9kcmFnLmpzPzQ5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZHJhZ1xuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICd1bmlkcmFnZ2VyL3VuaWRyYWdnZXInLFxuICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJ1xuICAgIF0sIGZ1bmN0aW9uKCBGbGlja2l0eSwgVW5pZHJhZ2dlciwgdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgVW5pZHJhZ2dlciwgdXRpbHMgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKSxcbiAgICAgIHJlcXVpcmUoJ3VuaWRyYWdnZXInKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LkZsaWNraXR5ID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5GbGlja2l0eSxcbiAgICAgIHdpbmRvdy5VbmlkcmFnZ2VyLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCBVbmlkcmFnZ2VyLCB1dGlscyApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLSBkZWZhdWx0cyAtLS0tLSAvL1xuXG51dGlscy5leHRlbmQoIEZsaWNraXR5LmRlZmF1bHRzLCB7XG4gIGRyYWdnYWJsZTogJz4xJyxcbiAgZHJhZ1RocmVzaG9sZDogMyxcbn0pO1xuXG4vLyAtLS0tLSBjcmVhdGUgLS0tLS0gLy9cblxuRmxpY2tpdHkuY3JlYXRlTWV0aG9kcy5wdXNoKCdfY3JlYXRlRHJhZycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIHByb3RvdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG51dGlscy5leHRlbmQoIHByb3RvLCBVbmlkcmFnZ2VyLnByb3RvdHlwZSApO1xucHJvdG8uX3RvdWNoQWN0aW9uVmFsdWUgPSAncGFuLXknO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIGlzVG91Y2ggPSAnY3JlYXRlVG91Y2gnIGluIGRvY3VtZW50O1xudmFyIGlzVG91Y2htb3ZlU2Nyb2xsQ2FuY2VsZWQgPSBmYWxzZTtcblxucHJvdG8uX2NyZWF0ZURyYWcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vbiggJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlRHJhZyApO1xuICB0aGlzLm9uKCAndWlDaGFuZ2UnLCB0aGlzLl91aUNoYW5nZURyYWcgKTtcbiAgdGhpcy5vbiggJ2NoaWxkVUlQb2ludGVyRG93bicsIHRoaXMuX2NoaWxkVUlQb2ludGVyRG93bkRyYWcgKTtcbiAgdGhpcy5vbiggJ2RlYWN0aXZhdGUnLCB0aGlzLnVuYmluZERyYWcgKTtcbiAgdGhpcy5vbiggJ2NlbGxDaGFuZ2UnLCB0aGlzLnVwZGF0ZURyYWdnYWJsZSApO1xuICAvLyBUT0RPIHVwZGF0ZURyYWdnYWJsZSBvbiByZXNpemU/IGlmIGdyb3VwQ2VsbHMgJiBzbGlkZXMgY2hhbmdlXG4gIC8vIEhBQ0sgLSBhZGQgc2VlbWluZ2x5IGlubm9jdW91cyBoYW5kbGVyIHRvIGZpeCBpT1MgMTAgc2Nyb2xsIGJlaGF2aW9yXG4gIC8vICM0NTcsIFJ1YmFYYS9Tb3J0YWJsZSM5NzNcbiAgaWYgKCBpc1RvdWNoICYmICFpc1RvdWNobW92ZVNjcm9sbENhbmNlbGVkICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgZnVuY3Rpb24oKSB7fSk7XG4gICAgaXNUb3VjaG1vdmVTY3JvbGxDYW5jZWxlZCA9IHRydWU7XG4gIH1cbn07XG5cbnByb3RvLm9uQWN0aXZhdGVEcmFnID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaGFuZGxlcyA9IFsgdGhpcy52aWV3cG9ydCBdO1xuICB0aGlzLmJpbmRIYW5kbGVzKCk7XG4gIHRoaXMudXBkYXRlRHJhZ2dhYmxlKCk7XG59O1xuXG5wcm90by5vbkRlYWN0aXZhdGVEcmFnID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudW5iaW5kSGFuZGxlcygpO1xuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZHJhZ2dhYmxlJyk7XG59O1xuXG5wcm90by51cGRhdGVEcmFnZ2FibGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZGlzYWJsZSBkcmFnZ2luZyBpZiBsZXNzIHRoYW4gMiBzbGlkZXMuICMyNzhcbiAgaWYgKCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID09ICc+MScgKSB7XG4gICAgdGhpcy5pc0RyYWdnYWJsZSA9IHRoaXMuc2xpZGVzLmxlbmd0aCA+IDE7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XG4gIH1cbiAgaWYgKCB0aGlzLmlzRHJhZ2dhYmxlICkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpcy1kcmFnZ2FibGUnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZHJhZ2dhYmxlJyk7XG4gIH1cbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5wcm90by5iaW5kRHJhZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGVEcmFnZ2FibGUoKTtcbn07XG5cbnByb3RvLnVuYmluZERyYWcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZURyYWdnYWJsZSgpO1xufTtcblxucHJvdG8uX3VpQ2hhbmdlRHJhZyA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5pc0ZyZWVTY3JvbGxpbmc7XG59O1xuXG5wcm90by5fY2hpbGRVSVBvaW50ZXJEb3duRHJhZyA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gYWxsb3cgZm9jdXMgJiBwcmV2ZW50RGVmYXVsdCBldmVuIHdoZW4gbm90IGRyYWdnYWJsZVxuICAvLyBzbyBjaGlsZCBVSSBlbGVtZW50cyBrZWVwIGZvY3VzIG9uIGNhcm91c2VsLiAjNzIxXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucG9pbnRlckRvd25Gb2N1cyggZXZlbnQgKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHBvaW50ZXIgZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRHJhZ2dhYmxlICkge1xuICAgIHRoaXMuX3BvaW50ZXJEb3duRGVmYXVsdCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzT2theSA9IHRoaXMub2theVBvaW50ZXJEb3duKCBldmVudCApO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcG9pbnRlckRvd25QcmV2ZW50RGVmYXVsdCggZXZlbnQgKTtcbiAgdGhpcy5wb2ludGVyRG93bkZvY3VzKCBldmVudCApO1xuICAvLyBibHVyXG4gIGlmICggZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmVsZW1lbnQgKSB7XG4gICAgLy8gZG8gbm90IGJsdXIgaWYgYWxyZWFkeSBmb2N1c2VkXG4gICAgdGhpcy5wb2ludGVyRG93bkJsdXIoKTtcbiAgfVxuXG4gIC8vIHN0b3AgaWYgaXQgd2FzIG1vdmluZ1xuICB0aGlzLmRyYWdYID0gdGhpcy54O1xuICB0aGlzLnZpZXdwb3J0LmNsYXNzTGlzdC5hZGQoJ2lzLXBvaW50ZXItZG93bicpO1xuICAvLyB0cmFjayBzY3JvbGxpbmdcbiAgdGhpcy5wb2ludGVyRG93blNjcm9sbCA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcyApO1xuXG4gIHRoaXMuX3BvaW50ZXJEb3duRGVmYXVsdCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIGRlZmF1bHQgcG9pbnRlckRvd24gbG9naWMsIHVzZWQgZm9yIHN0YXRpY0NsaWNrXG5wcm90by5fcG9pbnRlckRvd25EZWZhdWx0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyB0cmFjayBzdGFydCBldmVudCBwb3NpdGlvblxuICB0aGlzLnBvaW50ZXJEb3duUG9pbnRlciA9IHBvaW50ZXI7XG4gIC8vIGJpbmQgbW92ZSBhbmQgZW5kIGV2ZW50c1xuICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdwb2ludGVyRG93bicsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xufTtcblxudmFyIGZvY3VzTm9kZXMgPSB7XG4gIElOUFVUOiB0cnVlLFxuICBURVhUQVJFQTogdHJ1ZSxcbiAgU0VMRUNUOiB0cnVlLFxufTtcblxucHJvdG8ucG9pbnRlckRvd25Gb2N1cyA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIGlzRm9jdXNOb2RlID0gZm9jdXNOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIGlmICggIWlzRm9jdXNOb2RlICkge1xuICAgIHRoaXMuZm9jdXMoKTtcbiAgfVxufTtcblxucHJvdG8uX3BvaW50ZXJEb3duUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc1RvdWNoU3RhcnQgPSBldmVudC50eXBlID09ICd0b3VjaHN0YXJ0JztcbiAgdmFyIGlzVG91Y2hQb2ludGVyID0gZXZlbnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJztcbiAgdmFyIGlzRm9jdXNOb2RlID0gZm9jdXNOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIGlmICggIWlzVG91Y2hTdGFydCAmJiAhaXNUb3VjaFBvaW50ZXIgJiYgIWlzRm9jdXNOb2RlICkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIG1vdmUgLS0tLS0gLy9cblxucHJvdG8uaGFzRHJhZ1N0YXJ0ZWQgPSBmdW5jdGlvbiggbW92ZVZlY3RvciApIHtcbiAgcmV0dXJuIE1hdGguYWJzKCBtb3ZlVmVjdG9yLnggKSA+IHRoaXMub3B0aW9ucy5kcmFnVGhyZXNob2xkO1xufTtcblxuLy8gLS0tLS0gdXAgLS0tLS0gLy9cblxucHJvdG8ucG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBkZWxldGUgdGhpcy5pc1RvdWNoU2Nyb2xsaW5nO1xuICB0aGlzLnZpZXdwb3J0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXBvaW50ZXItZG93bicpO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdwb2ludGVyVXAnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbiAgdGhpcy5fZHJhZ1BvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLnBvaW50ZXJEb25lID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcyApO1xuICBkZWxldGUgdGhpcy5wb2ludGVyRG93blNjcm9sbDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRyYWdnaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCAhdGhpcy5pc0RyYWdnYWJsZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5kcmFnU3RhcnRQb3NpdGlvbiA9IHRoaXMueDtcbiAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Njcm9sbCcsIHRoaXMgKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ1N0YXJ0JywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB0aGlzLl9kcmFnUG9pbnRlck1vdmUoIGV2ZW50LCBwb2ludGVyICk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3BvaW50ZXJNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XG4gIHRoaXMuX2RyYWdNb3ZlKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApO1xufTtcblxucHJvdG8uZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIGlmICggIXRoaXMuaXNEcmFnZ2FibGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdGhpcy5wcmV2aW91c0RyYWdYID0gdGhpcy5kcmFnWDtcbiAgLy8gcmV2ZXJzZSBpZiByaWdodC10by1sZWZ0XG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMucmlnaHRUb0xlZnQgPyAtMSA6IDE7XG4gIGlmICggdGhpcy5vcHRpb25zLndyYXBBcm91bmQgKSB7XG4gICAgLy8gd3JhcCBhcm91bmQgbW92ZS4gIzU4OVxuICAgIG1vdmVWZWN0b3IueCA9IG1vdmVWZWN0b3IueCAlIHRoaXMuc2xpZGVhYmxlV2lkdGg7XG4gIH1cbiAgdmFyIGRyYWdYID0gdGhpcy5kcmFnU3RhcnRQb3NpdGlvbiArIG1vdmVWZWN0b3IueCAqIGRpcmVjdGlvbjtcblxuICBpZiAoICF0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCAmJiB0aGlzLnNsaWRlcy5sZW5ndGggKSB7XG4gICAgLy8gc2xvdyBkcmFnXG4gICAgdmFyIG9yaWdpbkJvdW5kID0gTWF0aC5tYXgoIC10aGlzLnNsaWRlc1swXS50YXJnZXQsIHRoaXMuZHJhZ1N0YXJ0UG9zaXRpb24gKTtcbiAgICBkcmFnWCA9IGRyYWdYID4gb3JpZ2luQm91bmQgPyAoIGRyYWdYICsgb3JpZ2luQm91bmQgKSAqIDAuNSA6IGRyYWdYO1xuICAgIHZhciBlbmRCb3VuZCA9IE1hdGgubWluKCAtdGhpcy5nZXRMYXN0U2xpZGUoKS50YXJnZXQsIHRoaXMuZHJhZ1N0YXJ0UG9zaXRpb24gKTtcbiAgICBkcmFnWCA9IGRyYWdYIDwgZW5kQm91bmQgPyAoIGRyYWdYICsgZW5kQm91bmQgKSAqIDAuNSA6IGRyYWdYO1xuICB9XG5cbiAgdGhpcy5kcmFnWCA9IGRyYWdYO1xuXG4gIHRoaXMuZHJhZ01vdmVUaW1lID0gbmV3IERhdGUoKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ01vdmUnLCBldmVudCwgWyBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcbn07XG5cbnByb3RvLmRyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIGlmICggIXRoaXMuaXNEcmFnZ2FibGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICggdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgKSB7XG4gICAgdGhpcy5pc0ZyZWVTY3JvbGxpbmcgPSB0cnVlO1xuICB9XG4gIC8vIHNldCBzZWxlY3RlZEluZGV4IGJhc2VkIG9uIHdoZXJlIGZsaWNrIHdpbGwgZW5kIHVwXG4gIHZhciBpbmRleCA9IHRoaXMuZHJhZ0VuZFJlc3RpbmdTZWxlY3QoKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsICYmICF0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCApIHtcbiAgICAvLyBpZiBmcmVlLXNjcm9sbCAmIG5vdCB3cmFwIGFyb3VuZFxuICAgIC8vIGRvIG5vdCBmcmVlLXNjcm9sbCBpZiBnb2luZyBvdXRzaWRlIG9mIGJvdW5kaW5nIHNsaWRlc1xuICAgIC8vIHNvIGJvdW5kaW5nIHNsaWRlcyBjYW4gYXR0cmFjdCBzbGlkZXIsIGFuZCBrZWVwIGl0IGluIGJvdW5kc1xuICAgIHZhciByZXN0aW5nWCA9IHRoaXMuZ2V0UmVzdGluZ1Bvc2l0aW9uKCk7XG4gICAgdGhpcy5pc0ZyZWVTY3JvbGxpbmcgPSAtcmVzdGluZ1ggPiB0aGlzLnNsaWRlc1swXS50YXJnZXQgJiZcbiAgICAgIC1yZXN0aW5nWCA8IHRoaXMuZ2V0TGFzdFNsaWRlKCkudGFyZ2V0O1xuICB9IGVsc2UgaWYgKCAhdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgJiYgaW5kZXggPT0gdGhpcy5zZWxlY3RlZEluZGV4ICkge1xuICAgIC8vIGJvb3N0IHNlbGVjdGlvbiBpZiBzZWxlY3RlZCBpbmRleCBoYXMgbm90IGNoYW5nZWRcbiAgICBpbmRleCArPSB0aGlzLmRyYWdFbmRCb29zdFNlbGVjdCgpO1xuICB9XG4gIGRlbGV0ZSB0aGlzLnByZXZpb3VzRHJhZ1g7XG4gIC8vIGFwcGx5IHNlbGVjdGlvblxuICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMsIHNlbGVjdGluZyBoZXJlIGZlZWxzIHdlaXJkXG4gIC8vIEhBQ0ssIHNldCBmbGFnIHNvIGRyYWdnaW5nIHN0YXlzIGluIGNvcnJlY3QgZGlyZWN0aW9uXG4gIHRoaXMuaXNEcmFnU2VsZWN0ID0gdGhpcy5vcHRpb25zLndyYXBBcm91bmQ7XG4gIHRoaXMuc2VsZWN0KCBpbmRleCApO1xuICBkZWxldGUgdGhpcy5pc0RyYWdTZWxlY3Q7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdFbmQnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbnByb3RvLmRyYWdFbmRSZXN0aW5nU2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN0aW5nWCA9IHRoaXMuZ2V0UmVzdGluZ1Bvc2l0aW9uKCk7XG4gIC8vIGhvdyBmYXIgYXdheSBmcm9tIHNlbGVjdGVkIHNsaWRlXG4gIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKCB0aGlzLmdldFNsaWRlRGlzdGFuY2UoIC1yZXN0aW5nWCwgdGhpcy5zZWxlY3RlZEluZGV4ICkgKTtcbiAgLy8gZ2V0IGNsb3NldCByZXN0aW5nIGdvaW5nIHVwIGFuZCBnb2luZyBkb3duXG4gIHZhciBwb3NpdGl2ZVJlc3RpbmcgPSB0aGlzLl9nZXRDbG9zZXN0UmVzdGluZyggcmVzdGluZ1gsIGRpc3RhbmNlLCAxICk7XG4gIHZhciBuZWdhdGl2ZVJlc3RpbmcgPSB0aGlzLl9nZXRDbG9zZXN0UmVzdGluZyggcmVzdGluZ1gsIGRpc3RhbmNlLCAtMSApO1xuICAvLyB1c2UgY2xvc2VyIHJlc3RpbmcgZm9yIHdyYXAtYXJvdW5kXG4gIHZhciBpbmRleCA9IHBvc2l0aXZlUmVzdGluZy5kaXN0YW5jZSA8IG5lZ2F0aXZlUmVzdGluZy5kaXN0YW5jZSA/XG4gICAgcG9zaXRpdmVSZXN0aW5nLmluZGV4IDogbmVnYXRpdmVSZXN0aW5nLmluZGV4O1xuICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIGdpdmVuIHJlc3RpbmcgWCBhbmQgZGlzdGFuY2UgdG8gc2VsZWN0ZWQgY2VsbFxuICogZ2V0IHRoZSBkaXN0YW5jZSBhbmQgaW5kZXggb2YgdGhlIGNsb3Nlc3QgY2VsbFxuICogQHBhcmFtIHtOdW1iZXJ9IHJlc3RpbmdYIC0gZXN0aW1hdGVkIHBvc3QtZmxpY2sgcmVzdGluZyBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIC0gZGlzdGFuY2UgdG8gc2VsZWN0ZWQgY2VsbFxuICogQHBhcmFtIHtJbnRlZ2VyfSBpbmNyZW1lbnQgLSArMSBvciAtMSwgZ29pbmcgdXAgb3IgZG93blxuICogQHJldHVybnMge09iamVjdH0gLSB7IGRpc3RhbmNlOiB7TnVtYmVyfSwgaW5kZXg6IHtJbnRlZ2VyfSB9XG4gKi9cbnByb3RvLl9nZXRDbG9zZXN0UmVzdGluZyA9IGZ1bmN0aW9uKCByZXN0aW5nWCwgZGlzdGFuY2UsIGluY3JlbWVudCApIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICB2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgdmFyIGNvbmRpdGlvbiA9IHRoaXMub3B0aW9ucy5jb250YWluICYmICF0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCA/XG4gICAgLy8gaWYgY29udGFpbiwga2VlcCBnb2luZyBpZiBkaXN0YW5jZSBpcyBlcXVhbCB0byBtaW5EaXN0YW5jZVxuICAgIGZ1bmN0aW9uKCBkLCBtZCApIHsgcmV0dXJuIGQgPD0gbWQ7IH0gOiBmdW5jdGlvbiggZCwgbWQgKSB7IHJldHVybiBkIDwgbWQ7IH07XG4gIHdoaWxlICggY29uZGl0aW9uKCBkaXN0YW5jZSwgbWluRGlzdGFuY2UgKSApIHtcbiAgICAvLyBtZWFzdXJlIGRpc3RhbmNlIHRvIG5leHQgY2VsbFxuICAgIGluZGV4ICs9IGluY3JlbWVudDtcbiAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIGRpc3RhbmNlID0gdGhpcy5nZXRTbGlkZURpc3RhbmNlKCAtcmVzdGluZ1gsIGluZGV4ICk7XG4gICAgaWYgKCBkaXN0YW5jZSA9PT0gbnVsbCApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGlzdGFuY2U6IG1pbkRpc3RhbmNlLFxuICAgIC8vIHNlbGVjdGVkIHdhcyBwcmV2aW91cyBpbmRleFxuICAgIGluZGV4OiBpbmRleCAtIGluY3JlbWVudFxuICB9O1xufTtcblxuLyoqXG4gKiBtZWFzdXJlIGRpc3RhbmNlIGJldHdlZW4geCBhbmQgYSBzbGlkZSB0YXJnZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IC0gc2xpZGUgaW5kZXhcbiAqL1xucHJvdG8uZ2V0U2xpZGVEaXN0YW5jZSA9IGZ1bmN0aW9uKCB4LCBpbmRleCApIHtcbiAgdmFyIGxlbiA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgLy8gd3JhcCBhcm91bmQgaWYgYXQgbGVhc3QgMiBzbGlkZXNcbiAgdmFyIGlzV3JhcEFyb3VuZCA9IHRoaXMub3B0aW9ucy53cmFwQXJvdW5kICYmIGxlbiA+IDE7XG4gIHZhciBzbGlkZUluZGV4ID0gaXNXcmFwQXJvdW5kID8gdXRpbHMubW9kdWxvKCBpbmRleCwgbGVuICkgOiBpbmRleDtcbiAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZXNbIHNsaWRlSW5kZXggXTtcbiAgaWYgKCAhc2xpZGUgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gYWRkIGRpc3RhbmNlIGZvciB3cmFwLWFyb3VuZCBzbGlkZXNcbiAgdmFyIHdyYXAgPSBpc1dyYXBBcm91bmQgPyB0aGlzLnNsaWRlYWJsZVdpZHRoICogTWF0aC5mbG9vciggaW5kZXggLyBsZW4gKSA6IDA7XG4gIHJldHVybiB4IC0gKCBzbGlkZS50YXJnZXQgKyB3cmFwICk7XG59O1xuXG5wcm90by5kcmFnRW5kQm9vc3RTZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gbm90IGJvb3N0IGlmIG5vIHByZXZpb3VzRHJhZ1ggb3IgZHJhZ01vdmVUaW1lXG4gIGlmICggdGhpcy5wcmV2aW91c0RyYWdYID09PSB1bmRlZmluZWQgfHwgIXRoaXMuZHJhZ01vdmVUaW1lIHx8XG4gICAgLy8gb3IgaWYgZHJhZyB3YXMgaGVsZCBmb3IgMTAwIG1zXG4gICAgbmV3IERhdGUoKSAtIHRoaXMuZHJhZ01vdmVUaW1lID4gMTAwICkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRpc3RhbmNlID0gdGhpcy5nZXRTbGlkZURpc3RhbmNlKCAtdGhpcy5kcmFnWCwgdGhpcy5zZWxlY3RlZEluZGV4ICk7XG4gIHZhciBkZWx0YSA9IHRoaXMucHJldmlvdXNEcmFnWCAtIHRoaXMuZHJhZ1g7XG4gIGlmICggZGlzdGFuY2UgPiAwICYmIGRlbHRhID4gMCApIHtcbiAgICAvLyBib29zdCB0byBuZXh0IGlmIG1vdmluZyB0b3dhcmRzIHRoZSByaWdodCwgYW5kIHBvc2l0aXZlIHZlbG9jaXR5XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoIGRpc3RhbmNlIDwgMCAmJiBkZWx0YSA8IDAgKSB7XG4gICAgLy8gYm9vc3QgdG8gcHJldmlvdXMgaWYgbW92aW5nIHRvd2FyZHMgdGhlIGxlZnQsIGFuZCBuZWdhdGl2ZSB2ZWxvY2l0eVxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbi8vIC0tLS0tIHN0YXRpY0NsaWNrIC0tLS0tIC8vXG5cbnByb3RvLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBnZXQgY2xpY2tlZENlbGwsIGlmIGNlbGwgd2FzIGNsaWNrZWRcbiAgdmFyIGNsaWNrZWRDZWxsID0gdGhpcy5nZXRQYXJlbnRDZWxsKCBldmVudC50YXJnZXQgKTtcbiAgdmFyIGNlbGxFbGVtID0gY2xpY2tlZENlbGwgJiYgY2xpY2tlZENlbGwuZWxlbWVudDtcbiAgdmFyIGNlbGxJbmRleCA9IGNsaWNrZWRDZWxsICYmIHRoaXMuY2VsbHMuaW5kZXhPZiggY2xpY2tlZENlbGwgKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnc3RhdGljQ2xpY2snLCBldmVudCwgWyBwb2ludGVyLCBjZWxsRWxlbSwgY2VsbEluZGV4IF0gKTtcbn07XG5cbi8vIC0tLS0tIHNjcm9sbCAtLS0tLSAvL1xuXG5wcm90by5vbnNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2Nyb2xsID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgdmFyIHNjcm9sbE1vdmVYID0gdGhpcy5wb2ludGVyRG93blNjcm9sbC54IC0gc2Nyb2xsLng7XG4gIHZhciBzY3JvbGxNb3ZlWSA9IHRoaXMucG9pbnRlckRvd25TY3JvbGwueSAtIHNjcm9sbC55O1xuICAvLyBjYW5jZWwgY2xpY2svdGFwIGlmIHNjcm9sbCBpcyB0b28gbXVjaFxuICBpZiAoIE1hdGguYWJzKCBzY3JvbGxNb3ZlWCApID4gMyB8fCBNYXRoLmFicyggc2Nyb2xsTW92ZVkgKSA+IDMgKSB7XG4gICAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gdXRpbHMgLS0tLS0gLy9cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9O1xufVxuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/drag.js\n")},"./node_modules/flickity/js/flickity.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Flickity main\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"),\n      __webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\"),\n      __webpack_require__(/*! ./cell */ \"./node_modules/flickity/js/cell.js\"),\n      __webpack_require__(/*! ./slide */ \"./node_modules/flickity/js/slide.js\"),\n      __webpack_require__(/*! ./animate */ \"./node_modules/flickity/js/animate.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter, getSize, utils, Cell, Slide, animatePrototype ) {\n      return factory( window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var _Flickity; }\n\n}( window, function factory( window, EvEmitter, getSize,\n  utils, Cell, Slide, animatePrototype ) {\n\n'use strict';\n\n// vars\nvar jQuery = window.jQuery;\nvar getComputedStyle = window.getComputedStyle;\nvar console = window.console;\n\nfunction moveElements( elems, toElem ) {\n  elems = utils.makeArray( elems );\n  while ( elems.length ) {\n    toElem.appendChild( elems.shift() );\n  }\n}\n\n// -------------------------- Flickity -------------------------- //\n\n// globally unique identifiers\nvar GUID = 0;\n// internal store of all Flickity intances\nvar instances = {};\n\nfunction Flickity( element, options ) {\n  var queryElement = utils.getQueryElement( element );\n  if ( !queryElement ) {\n    if ( console ) {\n      console.error( 'Bad element for Flickity: ' + ( queryElement || element ) );\n    }\n    return;\n  }\n  this.element = queryElement;\n  // do not initialize twice on same element\n  if ( this.element.flickityGUID ) {\n    var instance = instances[ this.element.flickityGUID ];\n    instance.option( options );\n    return instance;\n  }\n\n  // add jQuery\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n  // options\n  this.options = utils.extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  // kick things off\n  this._create();\n}\n\nFlickity.defaults = {\n  accessibility: true,\n  // adaptiveHeight: false,\n  cellAlign: 'center',\n  // cellSelector: undefined,\n  // contain: false,\n  freeScrollFriction: 0.075, // friction when free-scrolling\n  friction: 0.28, // friction when selecting\n  namespaceJQueryEvents: true,\n  // initialIndex: 0,\n  percentPosition: true,\n  resize: true,\n  selectedAttraction: 0.025,\n  setGallerySize: true\n  // watchCSS: false,\n  // wrapAround: false\n};\n\n// hash of methods triggered on _create()\nFlickity.createMethods = [];\n\nvar proto = Flickity.prototype;\n// inherit EventEmitter\nutils.extend( proto, EvEmitter.prototype );\n\nproto._create = function() {\n  // add id for Flickity.data\n  var id = this.guid = ++GUID;\n  this.element.flickityGUID = id; // expando\n  instances[ id ] = this; // associate via id\n  // initial properties\n  this.selectedIndex = 0;\n  // how many frames slider has been in same position\n  this.restingFrames = 0;\n  // initial physics properties\n  this.x = 0;\n  this.velocity = 0;\n  this.originSide = this.options.rightToLeft ? 'right' : 'left';\n  // create viewport & slider\n  this.viewport = document.createElement('div');\n  this.viewport.className = 'flickity-viewport';\n  this._createSlider();\n\n  if ( this.options.resize || this.options.watchCSS ) {\n    window.addEventListener( 'resize', this );\n  }\n\n  // add listeners from on option\n  for ( var eventName in this.options.on ) {\n    var listener = this.options.on[ eventName ];\n    this.on( eventName, listener );\n  }\n\n  Flickity.createMethods.forEach( function( method ) {\n    this[ method ]();\n  }, this );\n\n  if ( this.options.watchCSS ) {\n    this.watchCSS();\n  } else {\n    this.activate();\n  }\n\n};\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  utils.extend( this.options, opts );\n};\n\nproto.activate = function() {\n  if ( this.isActive ) {\n    return;\n  }\n  this.isActive = true;\n  this.element.classList.add('flickity-enabled');\n  if ( this.options.rightToLeft ) {\n    this.element.classList.add('flickity-rtl');\n  }\n\n  this.getSize();\n  // move initial cell elements so they can be loaded as cells\n  var cellElems = this._filterFindCellElements( this.element.children );\n  moveElements( cellElems, this.slider );\n  this.viewport.appendChild( this.slider );\n  this.element.appendChild( this.viewport );\n  // get cells from children\n  this.reloadCells();\n\n  if ( this.options.accessibility ) {\n    // allow element to focusable\n    this.element.tabIndex = 0;\n    // listen for key presses\n    this.element.addEventListener( 'keydown', this );\n  }\n\n  this.emitEvent('activate');\n\n  var index;\n  var initialIndex = this.options.initialIndex;\n  if ( this.isInitActivated ) {\n    index = this.selectedIndex;\n  } else if ( initialIndex !== undefined ) {\n    index = this.cells[ initialIndex ] ? initialIndex : 0;\n  } else {\n    index = 0;\n  }\n  // select instantly\n  this.select( index, false, true );\n  // flag for initial activation, for using initialIndex\n  this.isInitActivated = true;\n  // ready event. #493\n  this.dispatchEvent('ready');\n};\n\n// slider positions the cells\nproto._createSlider = function() {\n  // slider element does all the positioning\n  var slider = document.createElement('div');\n  slider.className = 'flickity-slider';\n  slider.style[ this.originSide ] = 0;\n  this.slider = slider;\n};\n\nproto._filterFindCellElements = function( elems ) {\n  return utils.filterFindElements( elems, this.options.cellSelector );\n};\n\n// goes through all children\nproto.reloadCells = function() {\n  // collection of item elements\n  this.cells = this._makeCells( this.slider.children );\n  this.positionCells();\n  this._getWrapShiftCells();\n  this.setGallerySize();\n};\n\n/**\n * turn elements into Flickity.Cells\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Flickity Cells\n */\nproto._makeCells = function( elems ) {\n  var cellElems = this._filterFindCellElements( elems );\n\n  // create new Flickity for collection\n  var cells = cellElems.map( function( cellElem ) {\n    return new Cell( cellElem, this );\n  }, this );\n\n  return cells;\n};\n\nproto.getLastCell = function() {\n  return this.cells[ this.cells.length - 1 ];\n};\n\nproto.getLastSlide = function() {\n  return this.slides[ this.slides.length - 1 ];\n};\n\n// positions all cells\nproto.positionCells = function() {\n  // size all cells\n  this._sizeCells( this.cells );\n  // position all cells\n  this._positionCells( 0 );\n};\n\n/**\n * position certain cells\n * @param {Integer} index - which cell to start with\n */\nproto._positionCells = function( index ) {\n  index = index || 0;\n  // also measure maxCellHeight\n  // start 0 if positioning all cells\n  this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\n  var cellX = 0;\n  // get cellX\n  if ( index > 0 ) {\n    var startCell = this.cells[ index - 1 ];\n    cellX = startCell.x + startCell.size.outerWidth;\n  }\n  var len = this.cells.length;\n  for ( var i=index; i < len; i++ ) {\n    var cell = this.cells[i];\n    cell.setPosition( cellX );\n    cellX += cell.size.outerWidth;\n    this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );\n  }\n  // keep track of cellX for wrap-around\n  this.slideableWidth = cellX;\n  // slides\n  this.updateSlides();\n  // contain slides target\n  this._containSlides();\n  // update slidesWidth\n  this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;\n};\n\n/**\n * cell.getSize() on multiple cells\n * @param {Array} cells\n */\nproto._sizeCells = function( cells ) {\n  cells.forEach( function( cell ) {\n    cell.getSize();\n  });\n};\n\n// --------------------------  -------------------------- //\n\nproto.updateSlides = function() {\n  this.slides = [];\n  if ( !this.cells.length ) {\n    return;\n  }\n\n  var slide = new Slide( this );\n  this.slides.push( slide );\n  var isOriginLeft = this.originSide == 'left';\n  var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';\n\n  var canCellFit = this._getCanCellFit();\n\n  this.cells.forEach( function( cell, i ) {\n    // just add cell if first cell in slide\n    if ( !slide.cells.length ) {\n      slide.addCell( cell );\n      return;\n    }\n\n    var slideWidth = ( slide.outerWidth - slide.firstMargin ) +\n      ( cell.size.outerWidth - cell.size[ nextMargin ] );\n\n    if ( canCellFit.call( this, i, slideWidth ) ) {\n      slide.addCell( cell );\n    } else {\n      // doesn't fit, new slide\n      slide.updateTarget();\n\n      slide = new Slide( this );\n      this.slides.push( slide );\n      slide.addCell( cell );\n    }\n  }, this );\n  // last slide\n  slide.updateTarget();\n  // update .selectedSlide\n  this.updateSelectedSlide();\n};\n\nproto._getCanCellFit = function() {\n  var groupCells = this.options.groupCells;\n  if ( !groupCells ) {\n    return function() {\n      return false;\n    };\n  } else if ( typeof groupCells == 'number' ) {\n    // group by number. 3 -> [0,1,2], [3,4,5], ...\n    var number = parseInt( groupCells, 10 );\n    return function( i ) {\n      return ( i % number ) !== 0;\n    };\n  }\n  // default, group by width of slide\n  // parse '75%\n  var percentMatch = typeof groupCells == 'string' &&\n    groupCells.match(/^(\\d+)%$/);\n  var percent = percentMatch ? parseInt( percentMatch[1], 10 ) / 100 : 1;\n  return function( i, slideWidth ) {\n    return slideWidth <= ( this.size.innerWidth + 1 ) * percent;\n  };\n};\n\n// alias _init for jQuery plugin .flickity()\nproto._init =\nproto.reposition = function() {\n  this.positionCells();\n  this.positionSliderAtSelected();\n};\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n  this.setCellAlign();\n  this.cursorPosition = this.size.innerWidth * this.cellAlign;\n};\n\nvar cellAlignShorthands = {\n  // cell align, then based on origin side\n  center: {\n    left: 0.5,\n    right: 0.5\n  },\n  left: {\n    left: 0,\n    right: 1\n  },\n  right: {\n    right: 0,\n    left: 1\n  }\n};\n\nproto.setCellAlign = function() {\n  var shorthand = cellAlignShorthands[ this.options.cellAlign ];\n  this.cellAlign = shorthand ? shorthand[ this.originSide ] : this.options.cellAlign;\n};\n\nproto.setGallerySize = function() {\n  if ( this.options.setGallerySize ) {\n    var height = this.options.adaptiveHeight && this.selectedSlide ?\n      this.selectedSlide.height : this.maxCellHeight;\n    this.viewport.style.height = height + 'px';\n  }\n};\n\nproto._getWrapShiftCells = function() {\n  // only for wrap-around\n  if ( !this.options.wrapAround ) {\n    return;\n  }\n  // unshift previous cells\n  this._unshiftCells( this.beforeShiftCells );\n  this._unshiftCells( this.afterShiftCells );\n  // get before cells\n  // initial gap\n  var gapX = this.cursorPosition;\n  var cellIndex = this.cells.length - 1;\n  this.beforeShiftCells = this._getGapCells( gapX, cellIndex, -1 );\n  // get after cells\n  // ending gap between last cell and end of gallery viewport\n  gapX = this.size.innerWidth - this.cursorPosition;\n  // start cloning at first cell, working forwards\n  this.afterShiftCells = this._getGapCells( gapX, 0, 1 );\n};\n\nproto._getGapCells = function( gapX, cellIndex, increment ) {\n  // keep adding cells until the cover the initial gap\n  var cells = [];\n  while ( gapX > 0 ) {\n    var cell = this.cells[ cellIndex ];\n    if ( !cell ) {\n      break;\n    }\n    cells.push( cell );\n    cellIndex += increment;\n    gapX -= cell.size.outerWidth;\n  }\n  return cells;\n};\n\n// ----- contain ----- //\n\n// contain cell targets so no excess sliding\nproto._containSlides = function() {\n  if ( !this.options.contain || this.options.wrapAround || !this.cells.length ) {\n    return;\n  }\n  var isRightToLeft = this.options.rightToLeft;\n  var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';\n  var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';\n  var contentWidth = this.slideableWidth - this.getLastCell().size[ endMargin ];\n  // content is less than gallery size\n  var isContentSmaller = contentWidth < this.size.innerWidth;\n  // bounds\n  var beginBound = this.cursorPosition + this.cells[0].size[ beginMargin ];\n  var endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );\n  // contain each cell target\n  this.slides.forEach( function( slide ) {\n    if ( isContentSmaller ) {\n      // all cells fit inside gallery\n      slide.target = contentWidth * this.cellAlign;\n    } else {\n      // contain to bounds\n      slide.target = Math.max( slide.target, beginBound );\n      slide.target = Math.min( slide.target, endBound );\n    }\n  }, this );\n};\n\n// -----  ----- //\n\n/**\n * emits events via eventEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  var emitArgs = event ? [ event ].concat( args ) : args;\n  this.emitEvent( type, emitArgs );\n\n  if ( jQuery && this.$element ) {\n    // default trigger with type if no event\n    type += this.options.namespaceJQueryEvents ? '.flickity' : '';\n    var $event = type;\n    if ( event ) {\n      // create jQuery event\n      var jQEvent = jQuery.Event( event );\n      jQEvent.type = type;\n      $event = jQEvent;\n    }\n    this.$element.trigger( $event, args );\n  }\n};\n\n// -------------------------- select -------------------------- //\n\n/**\n * @param {Integer} index - index of the slide\n * @param {Boolean} isWrap - will wrap-around to last/first if at the end\n * @param {Boolean} isInstant - will immediately set position at selected cell\n */\nproto.select = function( index, isWrap, isInstant ) {\n  if ( !this.isActive ) {\n    return;\n  }\n  index = parseInt( index, 10 );\n  this._wrapSelect( index );\n\n  if ( this.options.wrapAround || isWrap ) {\n    index = utils.modulo( index, this.slides.length );\n  }\n  // bail if invalid index\n  if ( !this.slides[ index ] ) {\n    return;\n  }\n  var prevIndex = this.selectedIndex;\n  this.selectedIndex = index;\n  this.updateSelectedSlide();\n  if ( isInstant ) {\n    this.positionSliderAtSelected();\n  } else {\n    this.startAnimation();\n  }\n  if ( this.options.adaptiveHeight ) {\n    this.setGallerySize();\n  }\n  // events\n  this.dispatchEvent( 'select', null, [ index ] );\n  // change event if new index\n  if ( index != prevIndex ) {\n    this.dispatchEvent( 'change', null, [ index ] );\n  }\n  // old v1 event name, remove in v3\n  this.dispatchEvent('cellSelect');\n};\n\n// wraps position for wrapAround, to move to closest slide. #113\nproto._wrapSelect = function( index ) {\n  var len = this.slides.length;\n  var isWrapping = this.options.wrapAround && len > 1;\n  if ( !isWrapping ) {\n    return index;\n  }\n  var wrapIndex = utils.modulo( index, len );\n  // go to shortest\n  var delta = Math.abs( wrapIndex - this.selectedIndex );\n  var backWrapDelta = Math.abs( ( wrapIndex + len ) - this.selectedIndex );\n  var forewardWrapDelta = Math.abs( ( wrapIndex - len ) - this.selectedIndex );\n  if ( !this.isDragSelect && backWrapDelta < delta ) {\n    index += len;\n  } else if ( !this.isDragSelect && forewardWrapDelta < delta ) {\n    index -= len;\n  }\n  // wrap position so slider is within normal area\n  if ( index < 0 ) {\n    this.x -= this.slideableWidth;\n  } else if ( index >= len ) {\n    this.x += this.slideableWidth;\n  }\n};\n\nproto.previous = function( isWrap, isInstant ) {\n  this.select( this.selectedIndex - 1, isWrap, isInstant );\n};\n\nproto.next = function( isWrap, isInstant ) {\n  this.select( this.selectedIndex + 1, isWrap, isInstant );\n};\n\nproto.updateSelectedSlide = function() {\n  var slide = this.slides[ this.selectedIndex ];\n  // selectedIndex could be outside of slides, if triggered before resize()\n  if ( !slide ) {\n    return;\n  }\n  // unselect previous selected slide\n  this.unselectSelectedSlide();\n  // update new selected slide\n  this.selectedSlide = slide;\n  slide.select();\n  this.selectedCells = slide.cells;\n  this.selectedElements = slide.getCellElements();\n  // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\n  // Remove in v3?\n  this.selectedCell = slide.cells[0];\n  this.selectedElement = this.selectedElements[0];\n};\n\nproto.unselectSelectedSlide = function() {\n  if ( this.selectedSlide ) {\n    this.selectedSlide.unselect();\n  }\n};\n\n/**\n * select slide from number or cell element\n * @param {Element or Number} elem\n */\nproto.selectCell = function( value, isWrap, isInstant ) {\n  // get cell\n  var cell = this.queryCell( value );\n  if ( !cell ) {\n    return;\n  }\n\n  var index = this.getCellSlideIndex( cell );\n  this.select( index, isWrap, isInstant );\n};\n\nproto.getCellSlideIndex = function( cell ) {\n  // get index of slides that has cell\n  for ( var i=0; i < this.slides.length; i++ ) {\n    var slide = this.slides[i];\n    var index = slide.cells.indexOf( cell );\n    if ( index != -1 ) {\n      return i;\n    }\n  }\n};\n\n// -------------------------- get cells -------------------------- //\n\n/**\n * get Flickity.Cell, given an Element\n * @param {Element} elem\n * @returns {Flickity.Cell} item\n */\nproto.getCell = function( elem ) {\n  // loop through cells to get the one that matches\n  for ( var i=0; i < this.cells.length; i++ ) {\n    var cell = this.cells[i];\n    if ( cell.element == elem ) {\n      return cell;\n    }\n  }\n};\n\n/**\n * get collection of Flickity.Cells, given Elements\n * @param {Element, Array, NodeList} elems\n * @returns {Array} cells - Flickity.Cells\n */\nproto.getCells = function( elems ) {\n  elems = utils.makeArray( elems );\n  var cells = [];\n  elems.forEach( function( elem ) {\n    var cell = this.getCell( elem );\n    if ( cell ) {\n      cells.push( cell );\n    }\n  }, this );\n  return cells;\n};\n\n/**\n * get cell elements\n * @returns {Array} cellElems\n */\nproto.getCellElements = function() {\n  return this.cells.map( function( cell ) {\n    return cell.element;\n  });\n};\n\n/**\n * get parent cell from an element\n * @param {Element} elem\n * @returns {Flickit.Cell} cell\n */\nproto.getParentCell = function( elem ) {\n  // first check if elem is cell\n  var cell = this.getCell( elem );\n  if ( cell ) {\n    return cell;\n  }\n  // try to get parent cell elem\n  elem = utils.getParent( elem, '.flickity-slider > *' );\n  return this.getCell( elem );\n};\n\n/**\n * get cells adjacent to a slide\n * @param {Integer} adjCount - number of adjacent slides\n * @param {Integer} index - index of slide to start\n * @returns {Array} cells - array of Flickity.Cells\n */\nproto.getAdjacentCellElements = function( adjCount, index ) {\n  if ( !adjCount ) {\n    return this.selectedSlide.getCellElements();\n  }\n  index = index === undefined ? this.selectedIndex : index;\n\n  var len = this.slides.length;\n  if ( 1 + ( adjCount * 2 ) >= len ) {\n    return this.getCellElements();\n  }\n\n  var cellElems = [];\n  for ( var i = index - adjCount; i <= index + adjCount ; i++ ) {\n    var slideIndex = this.options.wrapAround ? utils.modulo( i, len ) : i;\n    var slide = this.slides[ slideIndex ];\n    if ( slide ) {\n      cellElems = cellElems.concat( slide.getCellElements() );\n    }\n  }\n  return cellElems;\n};\n\n/**\n * select slide from number or cell element\n * @param {Element, Selector String, or Number} selector\n */\nproto.queryCell = function( selector ) {\n  if ( typeof selector == 'number' ) {\n    // use number as index\n    return this.cells[ selector ];\n  }\n  if ( typeof selector == 'string' ) {\n    // use string as selector, get element\n    selector = this.element.querySelector( selector );\n  }\n  // get cell from element\n  return this.getCell( selector );\n};\n\n// -------------------------- events -------------------------- //\n\nproto.uiChange = function() {\n  this.emitEvent('uiChange');\n};\n\nproto.childUIPointerDown = function( event ) {\n  this.emitEvent( 'childUIPointerDown', [ event ] );\n};\n\n// ----- resize ----- //\n\nproto.onresize = function() {\n  this.watchCSS();\n  this.resize();\n};\n\nutils.debounceMethod( Flickity, 'onresize', 150 );\n\nproto.resize = function() {\n  if ( !this.isActive ) {\n    return;\n  }\n  this.getSize();\n  // wrap values\n  if ( this.options.wrapAround ) {\n    this.x = utils.modulo( this.x, this.slideableWidth );\n  }\n  this.positionCells();\n  this._getWrapShiftCells();\n  this.setGallerySize();\n  this.emitEvent('resize');\n  // update selected index for group slides, instant\n  // TODO: position can be lost between groups of various numbers\n  var selectedElement = this.selectedElements && this.selectedElements[0];\n  this.selectCell( selectedElement, false, true );\n};\n\n// watches the :after property, activates/deactivates\nproto.watchCSS = function() {\n  var watchOption = this.options.watchCSS;\n  if ( !watchOption ) {\n    return;\n  }\n\n  var afterContent = getComputedStyle( this.element, ':after' ).content;\n  // activate if :after { content: 'flickity' }\n  if ( afterContent.indexOf('flickity') != -1 ) {\n    this.activate();\n  } else {\n    this.deactivate();\n  }\n};\n\n// ----- keydown ----- //\n\n// go previous/next if left/right keys pressed\nproto.onkeydown = function( event ) {\n  // only work if element is in focus\n  var isNotFocused = document.activeElement && document.activeElement != this.element;\n  if ( !this.options.accessibility ||isNotFocused ) {\n    return;\n  }\n\n  var handler = Flickity.keyboardHandlers[ event.keyCode ];\n  if ( handler ) {\n    handler.call( this );\n  }\n};\n\nFlickity.keyboardHandlers = {\n  // left arrow\n  37: function() {\n    var leftMethod = this.options.rightToLeft ? 'next' : 'previous';\n    this.uiChange();\n    this[ leftMethod ]();\n  },\n  // right arrow\n  39: function() {\n    var rightMethod = this.options.rightToLeft ? 'previous' : 'next';\n    this.uiChange();\n    this[ rightMethod ]();\n  },\n};\n\n// ----- focus ----- //\n\nproto.focus = function() {\n  var prevScrollY = window.pageYOffset;\n  this.element.focus();\n  // hack to fix scroll jump after focus, #76\n  if ( window.pageYOffset != prevScrollY ) {\n    window.scrollTo( window.pageXOffset, prevScrollY );\n  }\n};\n\n// -------------------------- destroy -------------------------- //\n\n// deactivate all Flickity functionality, but keep stuff available\nproto.deactivate = function() {\n  if ( !this.isActive ) {\n    return;\n  }\n  this.element.classList.remove('flickity-enabled');\n  this.element.classList.remove('flickity-rtl');\n  this.unselectSelectedSlide();\n  // destroy cells\n  this.cells.forEach( function( cell ) {\n    cell.destroy();\n  });\n  this.element.removeChild( this.viewport );\n  // move child elements back into element\n  moveElements( this.slider.children, this.element );\n  if ( this.options.accessibility ) {\n    this.element.removeAttribute('tabIndex');\n    this.element.removeEventListener( 'keydown', this );\n  }\n  // set flags\n  this.isActive = false;\n  this.emitEvent('deactivate');\n};\n\nproto.destroy = function() {\n  this.deactivate();\n  window.removeEventListener( 'resize', this );\n  this.emitEvent('destroy');\n  if ( jQuery && this.$element ) {\n    jQuery.removeData( this.element, 'flickity' );\n  }\n  delete this.element.flickityGUID;\n  delete instances[ this.guid ];\n};\n\n// -------------------------- prototype -------------------------- //\n\nutils.extend( proto, animatePrototype );\n\n// -------------------------- extras -------------------------- //\n\n/**\n * get Flickity instance from element\n * @param {Element} elem\n * @returns {Flickity}\n */\nFlickity.data = function( elem ) {\n  elem = utils.getQueryElement( elem );\n  var id = elem && elem.flickityGUID;\n  return id && instances[ id ];\n};\n\nutils.htmlInit( Flickity, 'flickity' );\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'flickity', Flickity );\n}\n\n// set internal jQuery, for Webpack + jQuery v3, #478\nFlickity.setJQuery = function( jq ) {\n  jQuery = jq;\n};\n\nFlickity.Cell = Cell;\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvZmxpY2tpdHkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvZmxpY2tpdHkuanM/MTM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGbGlja2l0eSBtYWluXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAnZ2V0LXNpemUvZ2V0LXNpemUnLFxuICAgICAgJ2Zpenp5LXVpLXV0aWxzL3V0aWxzJyxcbiAgICAgICcuL2NlbGwnLFxuICAgICAgJy4vc2xpZGUnLFxuICAgICAgJy4vYW5pbWF0ZSdcbiAgICBdLCBmdW5jdGlvbiggRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgQ2VsbCwgU2xpZGUsIGFuaW1hdGVQcm90b3R5cGUgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsIHV0aWxzLCBDZWxsLCBTbGlkZSwgYW5pbWF0ZVByb3RvdHlwZSApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJyksXG4gICAgICByZXF1aXJlKCcuL2NlbGwnKSxcbiAgICAgIHJlcXVpcmUoJy4vc2xpZGUnKSxcbiAgICAgIHJlcXVpcmUoJy4vYW5pbWF0ZScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHZhciBfRmxpY2tpdHkgPSB3aW5kb3cuRmxpY2tpdHk7XG5cbiAgICB3aW5kb3cuRmxpY2tpdHkgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5nZXRTaXplLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlscyxcbiAgICAgIF9GbGlja2l0eS5DZWxsLFxuICAgICAgX0ZsaWNraXR5LlNsaWRlLFxuICAgICAgX0ZsaWNraXR5LmFuaW1hdGVQcm90b3R5cGVcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIsIGdldFNpemUsXG4gIHV0aWxzLCBDZWxsLCBTbGlkZSwgYW5pbWF0ZVByb3RvdHlwZSApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyB2YXJzXG52YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcbnZhciBnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGU7XG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG5mdW5jdGlvbiBtb3ZlRWxlbWVudHMoIGVsZW1zLCB0b0VsZW0gKSB7XG4gIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBlbGVtcyApO1xuICB3aGlsZSAoIGVsZW1zLmxlbmd0aCApIHtcbiAgICB0b0VsZW0uYXBwZW5kQ2hpbGQoIGVsZW1zLnNoaWZ0KCkgKTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGbGlja2l0eSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllcnNcbnZhciBHVUlEID0gMDtcbi8vIGludGVybmFsIHN0b3JlIG9mIGFsbCBGbGlja2l0eSBpbnRhbmNlc1xudmFyIGluc3RhbmNlcyA9IHt9O1xuXG5mdW5jdGlvbiBGbGlja2l0eSggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgdmFyIHF1ZXJ5RWxlbWVudCA9IHV0aWxzLmdldFF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBpZiAoICFxdWVyeUVsZW1lbnQgKSB7XG4gICAgaWYgKCBjb25zb2xlICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ0JhZCBlbGVtZW50IGZvciBGbGlja2l0eTogJyArICggcXVlcnlFbGVtZW50IHx8IGVsZW1lbnQgKSApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50ID0gcXVlcnlFbGVtZW50O1xuICAvLyBkbyBub3QgaW5pdGlhbGl6ZSB0d2ljZSBvbiBzYW1lIGVsZW1lbnRcbiAgaWYgKCB0aGlzLmVsZW1lbnQuZmxpY2tpdHlHVUlEICkge1xuICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1sgdGhpcy5lbGVtZW50LmZsaWNraXR5R1VJRCBdO1xuICAgIGluc3RhbmNlLm9wdGlvbiggb3B0aW9ucyApO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIC8vIGFkZCBqUXVlcnlcbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gIH1cbiAgLy8gb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XG5cbiAgLy8ga2ljayB0aGluZ3Mgb2ZmXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG5GbGlja2l0eS5kZWZhdWx0cyA9IHtcbiAgYWNjZXNzaWJpbGl0eTogdHJ1ZSxcbiAgLy8gYWRhcHRpdmVIZWlnaHQ6IGZhbHNlLFxuICBjZWxsQWxpZ246ICdjZW50ZXInLFxuICAvLyBjZWxsU2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gY29udGFpbjogZmFsc2UsXG4gIGZyZWVTY3JvbGxGcmljdGlvbjogMC4wNzUsIC8vIGZyaWN0aW9uIHdoZW4gZnJlZS1zY3JvbGxpbmdcbiAgZnJpY3Rpb246IDAuMjgsIC8vIGZyaWN0aW9uIHdoZW4gc2VsZWN0aW5nXG4gIG5hbWVzcGFjZUpRdWVyeUV2ZW50czogdHJ1ZSxcbiAgLy8gaW5pdGlhbEluZGV4OiAwLFxuICBwZXJjZW50UG9zaXRpb246IHRydWUsXG4gIHJlc2l6ZTogdHJ1ZSxcbiAgc2VsZWN0ZWRBdHRyYWN0aW9uOiAwLjAyNSxcbiAgc2V0R2FsbGVyeVNpemU6IHRydWVcbiAgLy8gd2F0Y2hDU1M6IGZhbHNlLFxuICAvLyB3cmFwQXJvdW5kOiBmYWxzZVxufTtcblxuLy8gaGFzaCBvZiBtZXRob2RzIHRyaWdnZXJlZCBvbiBfY3JlYXRlKClcbkZsaWNraXR5LmNyZWF0ZU1ldGhvZHMgPSBbXTtcblxudmFyIHByb3RvID0gRmxpY2tpdHkucHJvdG90eXBlO1xuLy8gaW5oZXJpdCBFdmVudEVtaXR0ZXJcbnV0aWxzLmV4dGVuZCggcHJvdG8sIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBhZGQgaWQgZm9yIEZsaWNraXR5LmRhdGFcbiAgdmFyIGlkID0gdGhpcy5ndWlkID0gKytHVUlEO1xuICB0aGlzLmVsZW1lbnQuZmxpY2tpdHlHVUlEID0gaWQ7IC8vIGV4cGFuZG9cbiAgaW5zdGFuY2VzWyBpZCBdID0gdGhpczsgLy8gYXNzb2NpYXRlIHZpYSBpZFxuICAvLyBpbml0aWFsIHByb3BlcnRpZXNcbiAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcbiAgLy8gaG93IG1hbnkgZnJhbWVzIHNsaWRlciBoYXMgYmVlbiBpbiBzYW1lIHBvc2l0aW9uXG4gIHRoaXMucmVzdGluZ0ZyYW1lcyA9IDA7XG4gIC8vIGluaXRpYWwgcGh5c2ljcyBwcm9wZXJ0aWVzXG4gIHRoaXMueCA9IDA7XG4gIHRoaXMudmVsb2NpdHkgPSAwO1xuICB0aGlzLm9yaWdpblNpZGUgPSB0aGlzLm9wdGlvbnMucmlnaHRUb0xlZnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAvLyBjcmVhdGUgdmlld3BvcnQgJiBzbGlkZXJcbiAgdGhpcy52aWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLnZpZXdwb3J0LmNsYXNzTmFtZSA9ICdmbGlja2l0eS12aWV3cG9ydCc7XG4gIHRoaXMuX2NyZWF0ZVNsaWRlcigpO1xuXG4gIGlmICggdGhpcy5vcHRpb25zLnJlc2l6ZSB8fCB0aGlzLm9wdGlvbnMud2F0Y2hDU1MgKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIH1cblxuICAvLyBhZGQgbGlzdGVuZXJzIGZyb20gb24gb3B0aW9uXG4gIGZvciAoIHZhciBldmVudE5hbWUgaW4gdGhpcy5vcHRpb25zLm9uICkge1xuICAgIHZhciBsaXN0ZW5lciA9IHRoaXMub3B0aW9ucy5vblsgZXZlbnROYW1lIF07XG4gICAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICB9XG5cbiAgRmxpY2tpdHkuY3JlYXRlTWV0aG9kcy5mb3JFYWNoKCBmdW5jdGlvbiggbWV0aG9kICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCk7XG4gIH0sIHRoaXMgKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy53YXRjaENTUyApIHtcbiAgICB0aGlzLndhdGNoQ1NTKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hY3RpdmF0ZSgpO1xuICB9XG5cbn07XG5cbi8qKlxuICogc2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICB1dGlscy5leHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xufTtcblxucHJvdG8uYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLmlzQWN0aXZlICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZsaWNraXR5LWVuYWJsZWQnKTtcbiAgaWYgKCB0aGlzLm9wdGlvbnMucmlnaHRUb0xlZnQgKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZsaWNraXR5LXJ0bCcpO1xuICB9XG5cbiAgdGhpcy5nZXRTaXplKCk7XG4gIC8vIG1vdmUgaW5pdGlhbCBjZWxsIGVsZW1lbnRzIHNvIHRoZXkgY2FuIGJlIGxvYWRlZCBhcyBjZWxsc1xuICB2YXIgY2VsbEVsZW1zID0gdGhpcy5fZmlsdGVyRmluZENlbGxFbGVtZW50cyggdGhpcy5lbGVtZW50LmNoaWxkcmVuICk7XG4gIG1vdmVFbGVtZW50cyggY2VsbEVsZW1zLCB0aGlzLnNsaWRlciApO1xuICB0aGlzLnZpZXdwb3J0LmFwcGVuZENoaWxkKCB0aGlzLnNsaWRlciApO1xuICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoIHRoaXMudmlld3BvcnQgKTtcbiAgLy8gZ2V0IGNlbGxzIGZyb20gY2hpbGRyZW5cbiAgdGhpcy5yZWxvYWRDZWxscygpO1xuXG4gIGlmICggdGhpcy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgKSB7XG4gICAgLy8gYWxsb3cgZWxlbWVudCB0byBmb2N1c2FibGVcbiAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIC8vIGxpc3RlbiBmb3Iga2V5IHByZXNzZXNcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCB0aGlzICk7XG4gIH1cblxuICB0aGlzLmVtaXRFdmVudCgnYWN0aXZhdGUnKTtcblxuICB2YXIgaW5kZXg7XG4gIHZhciBpbml0aWFsSW5kZXggPSB0aGlzLm9wdGlvbnMuaW5pdGlhbEluZGV4O1xuICBpZiAoIHRoaXMuaXNJbml0QWN0aXZhdGVkICkge1xuICAgIGluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICB9IGVsc2UgaWYgKCBpbml0aWFsSW5kZXggIT09IHVuZGVmaW5lZCApIHtcbiAgICBpbmRleCA9IHRoaXMuY2VsbHNbIGluaXRpYWxJbmRleCBdID8gaW5pdGlhbEluZGV4IDogMDtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCA9IDA7XG4gIH1cbiAgLy8gc2VsZWN0IGluc3RhbnRseVxuICB0aGlzLnNlbGVjdCggaW5kZXgsIGZhbHNlLCB0cnVlICk7XG4gIC8vIGZsYWcgZm9yIGluaXRpYWwgYWN0aXZhdGlvbiwgZm9yIHVzaW5nIGluaXRpYWxJbmRleFxuICB0aGlzLmlzSW5pdEFjdGl2YXRlZCA9IHRydWU7XG4gIC8vIHJlYWR5IGV2ZW50LiAjNDkzXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVhZHknKTtcbn07XG5cbi8vIHNsaWRlciBwb3NpdGlvbnMgdGhlIGNlbGxzXG5wcm90by5fY3JlYXRlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNsaWRlciBlbGVtZW50IGRvZXMgYWxsIHRoZSBwb3NpdGlvbmluZ1xuICB2YXIgc2xpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNsaWRlci5jbGFzc05hbWUgPSAnZmxpY2tpdHktc2xpZGVyJztcbiAgc2xpZGVyLnN0eWxlWyB0aGlzLm9yaWdpblNpZGUgXSA9IDA7XG4gIHRoaXMuc2xpZGVyID0gc2xpZGVyO1xufTtcblxucHJvdG8uX2ZpbHRlckZpbmRDZWxsRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHJldHVybiB1dGlscy5maWx0ZXJGaW5kRWxlbWVudHMoIGVsZW1zLCB0aGlzLm9wdGlvbnMuY2VsbFNlbGVjdG9yICk7XG59O1xuXG4vLyBnb2VzIHRocm91Z2ggYWxsIGNoaWxkcmVuXG5wcm90by5yZWxvYWRDZWxscyA9IGZ1bmN0aW9uKCkge1xuICAvLyBjb2xsZWN0aW9uIG9mIGl0ZW0gZWxlbWVudHNcbiAgdGhpcy5jZWxscyA9IHRoaXMuX21ha2VDZWxscyggdGhpcy5zbGlkZXIuY2hpbGRyZW4gKTtcbiAgdGhpcy5wb3NpdGlvbkNlbGxzKCk7XG4gIHRoaXMuX2dldFdyYXBTaGlmdENlbGxzKCk7XG4gIHRoaXMuc2V0R2FsbGVyeVNpemUoKTtcbn07XG5cbi8qKlxuICogdHVybiBlbGVtZW50cyBpbnRvIEZsaWNraXR5LkNlbGxzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGNvbGxlY3Rpb24gb2YgbmV3IEZsaWNraXR5IENlbGxzXG4gKi9cbnByb3RvLl9tYWtlQ2VsbHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBjZWxsRWxlbXMgPSB0aGlzLl9maWx0ZXJGaW5kQ2VsbEVsZW1lbnRzKCBlbGVtcyApO1xuXG4gIC8vIGNyZWF0ZSBuZXcgRmxpY2tpdHkgZm9yIGNvbGxlY3Rpb25cbiAgdmFyIGNlbGxzID0gY2VsbEVsZW1zLm1hcCggZnVuY3Rpb24oIGNlbGxFbGVtICkge1xuICAgIHJldHVybiBuZXcgQ2VsbCggY2VsbEVsZW0sIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIHJldHVybiBjZWxscztcbn07XG5cbnByb3RvLmdldExhc3RDZWxsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNlbGxzWyB0aGlzLmNlbGxzLmxlbmd0aCAtIDEgXTtcbn07XG5cbnByb3RvLmdldExhc3RTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zbGlkZXNbIHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEgXTtcbn07XG5cbi8vIHBvc2l0aW9ucyBhbGwgY2VsbHNcbnByb3RvLnBvc2l0aW9uQ2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2l6ZSBhbGwgY2VsbHNcbiAgdGhpcy5fc2l6ZUNlbGxzKCB0aGlzLmNlbGxzICk7XG4gIC8vIHBvc2l0aW9uIGFsbCBjZWxsc1xuICB0aGlzLl9wb3NpdGlvbkNlbGxzKCAwICk7XG59O1xuXG4vKipcbiAqIHBvc2l0aW9uIGNlcnRhaW4gY2VsbHNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSB3aGljaCBjZWxsIHRvIHN0YXJ0IHdpdGhcbiAqL1xucHJvdG8uX3Bvc2l0aW9uQ2VsbHMgPSBmdW5jdGlvbiggaW5kZXggKSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgLy8gYWxzbyBtZWFzdXJlIG1heENlbGxIZWlnaHRcbiAgLy8gc3RhcnQgMCBpZiBwb3NpdGlvbmluZyBhbGwgY2VsbHNcbiAgdGhpcy5tYXhDZWxsSGVpZ2h0ID0gaW5kZXggPyB0aGlzLm1heENlbGxIZWlnaHQgfHwgMCA6IDA7XG4gIHZhciBjZWxsWCA9IDA7XG4gIC8vIGdldCBjZWxsWFxuICBpZiAoIGluZGV4ID4gMCApIHtcbiAgICB2YXIgc3RhcnRDZWxsID0gdGhpcy5jZWxsc1sgaW5kZXggLSAxIF07XG4gICAgY2VsbFggPSBzdGFydENlbGwueCArIHN0YXJ0Q2VsbC5zaXplLm91dGVyV2lkdGg7XG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuY2VsbHMubGVuZ3RoO1xuICBmb3IgKCB2YXIgaT1pbmRleDsgaSA8IGxlbjsgaSsrICkge1xuICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1tpXTtcbiAgICBjZWxsLnNldFBvc2l0aW9uKCBjZWxsWCApO1xuICAgIGNlbGxYICs9IGNlbGwuc2l6ZS5vdXRlcldpZHRoO1xuICAgIHRoaXMubWF4Q2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsLnNpemUub3V0ZXJIZWlnaHQsIHRoaXMubWF4Q2VsbEhlaWdodCApO1xuICB9XG4gIC8vIGtlZXAgdHJhY2sgb2YgY2VsbFggZm9yIHdyYXAtYXJvdW5kXG4gIHRoaXMuc2xpZGVhYmxlV2lkdGggPSBjZWxsWDtcbiAgLy8gc2xpZGVzXG4gIHRoaXMudXBkYXRlU2xpZGVzKCk7XG4gIC8vIGNvbnRhaW4gc2xpZGVzIHRhcmdldFxuICB0aGlzLl9jb250YWluU2xpZGVzKCk7XG4gIC8vIHVwZGF0ZSBzbGlkZXNXaWR0aFxuICB0aGlzLnNsaWRlc1dpZHRoID0gbGVuID8gdGhpcy5nZXRMYXN0U2xpZGUoKS50YXJnZXQgLSB0aGlzLnNsaWRlc1swXS50YXJnZXQgOiAwO1xufTtcblxuLyoqXG4gKiBjZWxsLmdldFNpemUoKSBvbiBtdWx0aXBsZSBjZWxsc1xuICogQHBhcmFtIHtBcnJheX0gY2VsbHNcbiAqL1xucHJvdG8uX3NpemVDZWxscyA9IGZ1bmN0aW9uKCBjZWxscyApIHtcbiAgY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5nZXRTaXplKCk7XG4gIH0pO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLnVwZGF0ZVNsaWRlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNsaWRlcyA9IFtdO1xuICBpZiAoICF0aGlzLmNlbGxzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2xpZGUgPSBuZXcgU2xpZGUoIHRoaXMgKTtcbiAgdGhpcy5zbGlkZXMucHVzaCggc2xpZGUgKTtcbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMub3JpZ2luU2lkZSA9PSAnbGVmdCc7XG4gIHZhciBuZXh0TWFyZ2luID0gaXNPcmlnaW5MZWZ0ID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5MZWZ0JztcblxuICB2YXIgY2FuQ2VsbEZpdCA9IHRoaXMuX2dldENhbkNlbGxGaXQoKTtcblxuICB0aGlzLmNlbGxzLmZvckVhY2goIGZ1bmN0aW9uKCBjZWxsLCBpICkge1xuICAgIC8vIGp1c3QgYWRkIGNlbGwgaWYgZmlyc3QgY2VsbCBpbiBzbGlkZVxuICAgIGlmICggIXNsaWRlLmNlbGxzLmxlbmd0aCApIHtcbiAgICAgIHNsaWRlLmFkZENlbGwoIGNlbGwgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2xpZGVXaWR0aCA9ICggc2xpZGUub3V0ZXJXaWR0aCAtIHNsaWRlLmZpcnN0TWFyZ2luICkgK1xuICAgICAgKCBjZWxsLnNpemUub3V0ZXJXaWR0aCAtIGNlbGwuc2l6ZVsgbmV4dE1hcmdpbiBdICk7XG5cbiAgICBpZiAoIGNhbkNlbGxGaXQuY2FsbCggdGhpcywgaSwgc2xpZGVXaWR0aCApICkge1xuICAgICAgc2xpZGUuYWRkQ2VsbCggY2VsbCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2Vzbid0IGZpdCwgbmV3IHNsaWRlXG4gICAgICBzbGlkZS51cGRhdGVUYXJnZXQoKTtcblxuICAgICAgc2xpZGUgPSBuZXcgU2xpZGUoIHRoaXMgKTtcbiAgICAgIHRoaXMuc2xpZGVzLnB1c2goIHNsaWRlICk7XG4gICAgICBzbGlkZS5hZGRDZWxsKCBjZWxsICk7XG4gICAgfVxuICB9LCB0aGlzICk7XG4gIC8vIGxhc3Qgc2xpZGVcbiAgc2xpZGUudXBkYXRlVGFyZ2V0KCk7XG4gIC8vIHVwZGF0ZSAuc2VsZWN0ZWRTbGlkZVxuICB0aGlzLnVwZGF0ZVNlbGVjdGVkU2xpZGUoKTtcbn07XG5cbnByb3RvLl9nZXRDYW5DZWxsRml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBncm91cENlbGxzID0gdGhpcy5vcHRpb25zLmdyb3VwQ2VsbHM7XG4gIGlmICggIWdyb3VwQ2VsbHMgKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBncm91cENlbGxzID09ICdudW1iZXInICkge1xuICAgIC8vIGdyb3VwIGJ5IG51bWJlci4gMyAtPiBbMCwxLDJdLCBbMyw0LDVdLCAuLi5cbiAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQoIGdyb3VwQ2VsbHMsIDEwICk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBpICkge1xuICAgICAgcmV0dXJuICggaSAlIG51bWJlciApICE9PSAwO1xuICAgIH07XG4gIH1cbiAgLy8gZGVmYXVsdCwgZ3JvdXAgYnkgd2lkdGggb2Ygc2xpZGVcbiAgLy8gcGFyc2UgJzc1JVxuICB2YXIgcGVyY2VudE1hdGNoID0gdHlwZW9mIGdyb3VwQ2VsbHMgPT0gJ3N0cmluZycgJiZcbiAgICBncm91cENlbGxzLm1hdGNoKC9eKFxcZCspJSQvKTtcbiAgdmFyIHBlcmNlbnQgPSBwZXJjZW50TWF0Y2ggPyBwYXJzZUludCggcGVyY2VudE1hdGNoWzFdLCAxMCApIC8gMTAwIDogMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpLCBzbGlkZVdpZHRoICkge1xuICAgIHJldHVybiBzbGlkZVdpZHRoIDw9ICggdGhpcy5zaXplLmlubmVyV2lkdGggKyAxICkgKiBwZXJjZW50O1xuICB9O1xufTtcblxuLy8gYWxpYXMgX2luaXQgZm9yIGpRdWVyeSBwbHVnaW4gLmZsaWNraXR5KClcbnByb3RvLl9pbml0ID1cbnByb3RvLnJlcG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wb3NpdGlvbkNlbGxzKCk7XG4gIHRoaXMucG9zaXRpb25TbGlkZXJBdFNlbGVjdGVkKCk7XG59O1xuXG5wcm90by5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xuICB0aGlzLnNldENlbGxBbGlnbigpO1xuICB0aGlzLmN1cnNvclBvc2l0aW9uID0gdGhpcy5zaXplLmlubmVyV2lkdGggKiB0aGlzLmNlbGxBbGlnbjtcbn07XG5cbnZhciBjZWxsQWxpZ25TaG9ydGhhbmRzID0ge1xuICAvLyBjZWxsIGFsaWduLCB0aGVuIGJhc2VkIG9uIG9yaWdpbiBzaWRlXG4gIGNlbnRlcjoge1xuICAgIGxlZnQ6IDAuNSxcbiAgICByaWdodDogMC41XG4gIH0sXG4gIGxlZnQ6IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAxXG4gIH0sXG4gIHJpZ2h0OiB7XG4gICAgcmlnaHQ6IDAsXG4gICAgbGVmdDogMVxuICB9XG59O1xuXG5wcm90by5zZXRDZWxsQWxpZ24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNob3J0aGFuZCA9IGNlbGxBbGlnblNob3J0aGFuZHNbIHRoaXMub3B0aW9ucy5jZWxsQWxpZ24gXTtcbiAgdGhpcy5jZWxsQWxpZ24gPSBzaG9ydGhhbmQgPyBzaG9ydGhhbmRbIHRoaXMub3JpZ2luU2lkZSBdIDogdGhpcy5vcHRpb25zLmNlbGxBbGlnbjtcbn07XG5cbnByb3RvLnNldEdhbGxlcnlTaXplID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5vcHRpb25zLnNldEdhbGxlcnlTaXplICkge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVIZWlnaHQgJiYgdGhpcy5zZWxlY3RlZFNsaWRlID9cbiAgICAgIHRoaXMuc2VsZWN0ZWRTbGlkZS5oZWlnaHQgOiB0aGlzLm1heENlbGxIZWlnaHQ7XG4gICAgdGhpcy52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG59O1xuXG5wcm90by5fZ2V0V3JhcFNoaWZ0Q2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gb25seSBmb3Igd3JhcC1hcm91bmRcbiAgaWYgKCAhdGhpcy5vcHRpb25zLndyYXBBcm91bmQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVuc2hpZnQgcHJldmlvdXMgY2VsbHNcbiAgdGhpcy5fdW5zaGlmdENlbGxzKCB0aGlzLmJlZm9yZVNoaWZ0Q2VsbHMgKTtcbiAgdGhpcy5fdW5zaGlmdENlbGxzKCB0aGlzLmFmdGVyU2hpZnRDZWxscyApO1xuICAvLyBnZXQgYmVmb3JlIGNlbGxzXG4gIC8vIGluaXRpYWwgZ2FwXG4gIHZhciBnYXBYID0gdGhpcy5jdXJzb3JQb3NpdGlvbjtcbiAgdmFyIGNlbGxJbmRleCA9IHRoaXMuY2VsbHMubGVuZ3RoIC0gMTtcbiAgdGhpcy5iZWZvcmVTaGlmdENlbGxzID0gdGhpcy5fZ2V0R2FwQ2VsbHMoIGdhcFgsIGNlbGxJbmRleCwgLTEgKTtcbiAgLy8gZ2V0IGFmdGVyIGNlbGxzXG4gIC8vIGVuZGluZyBnYXAgYmV0d2VlbiBsYXN0IGNlbGwgYW5kIGVuZCBvZiBnYWxsZXJ5IHZpZXdwb3J0XG4gIGdhcFggPSB0aGlzLnNpemUuaW5uZXJXaWR0aCAtIHRoaXMuY3Vyc29yUG9zaXRpb247XG4gIC8vIHN0YXJ0IGNsb25pbmcgYXQgZmlyc3QgY2VsbCwgd29ya2luZyBmb3J3YXJkc1xuICB0aGlzLmFmdGVyU2hpZnRDZWxscyA9IHRoaXMuX2dldEdhcENlbGxzKCBnYXBYLCAwLCAxICk7XG59O1xuXG5wcm90by5fZ2V0R2FwQ2VsbHMgPSBmdW5jdGlvbiggZ2FwWCwgY2VsbEluZGV4LCBpbmNyZW1lbnQgKSB7XG4gIC8vIGtlZXAgYWRkaW5nIGNlbGxzIHVudGlsIHRoZSBjb3ZlciB0aGUgaW5pdGlhbCBnYXBcbiAgdmFyIGNlbGxzID0gW107XG4gIHdoaWxlICggZ2FwWCA+IDAgKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzWyBjZWxsSW5kZXggXTtcbiAgICBpZiAoICFjZWxsICkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNlbGxzLnB1c2goIGNlbGwgKTtcbiAgICBjZWxsSW5kZXggKz0gaW5jcmVtZW50O1xuICAgIGdhcFggLT0gY2VsbC5zaXplLm91dGVyV2lkdGg7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufTtcblxuLy8gLS0tLS0gY29udGFpbiAtLS0tLSAvL1xuXG4vLyBjb250YWluIGNlbGwgdGFyZ2V0cyBzbyBubyBleGNlc3Mgc2xpZGluZ1xucHJvdG8uX2NvbnRhaW5TbGlkZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLmNvbnRhaW4gfHwgdGhpcy5vcHRpb25zLndyYXBBcm91bmQgfHwgIXRoaXMuY2VsbHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaXNSaWdodFRvTGVmdCA9IHRoaXMub3B0aW9ucy5yaWdodFRvTGVmdDtcbiAgdmFyIGJlZ2luTWFyZ2luID0gaXNSaWdodFRvTGVmdCA/ICdtYXJnaW5SaWdodCcgOiAnbWFyZ2luTGVmdCc7XG4gIHZhciBlbmRNYXJnaW4gPSBpc1JpZ2h0VG9MZWZ0ID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0JztcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IHRoaXMuc2xpZGVhYmxlV2lkdGggLSB0aGlzLmdldExhc3RDZWxsKCkuc2l6ZVsgZW5kTWFyZ2luIF07XG4gIC8vIGNvbnRlbnQgaXMgbGVzcyB0aGFuIGdhbGxlcnkgc2l6ZVxuICB2YXIgaXNDb250ZW50U21hbGxlciA9IGNvbnRlbnRXaWR0aCA8IHRoaXMuc2l6ZS5pbm5lcldpZHRoO1xuICAvLyBib3VuZHNcbiAgdmFyIGJlZ2luQm91bmQgPSB0aGlzLmN1cnNvclBvc2l0aW9uICsgdGhpcy5jZWxsc1swXS5zaXplWyBiZWdpbk1hcmdpbiBdO1xuICB2YXIgZW5kQm91bmQgPSBjb250ZW50V2lkdGggLSB0aGlzLnNpemUuaW5uZXJXaWR0aCAqICggMSAtIHRoaXMuY2VsbEFsaWduICk7XG4gIC8vIGNvbnRhaW4gZWFjaCBjZWxsIHRhcmdldFxuICB0aGlzLnNsaWRlcy5mb3JFYWNoKCBmdW5jdGlvbiggc2xpZGUgKSB7XG4gICAgaWYgKCBpc0NvbnRlbnRTbWFsbGVyICkge1xuICAgICAgLy8gYWxsIGNlbGxzIGZpdCBpbnNpZGUgZ2FsbGVyeVxuICAgICAgc2xpZGUudGFyZ2V0ID0gY29udGVudFdpZHRoICogdGhpcy5jZWxsQWxpZ247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnRhaW4gdG8gYm91bmRzXG4gICAgICBzbGlkZS50YXJnZXQgPSBNYXRoLm1heCggc2xpZGUudGFyZ2V0LCBiZWdpbkJvdW5kICk7XG4gICAgICBzbGlkZS50YXJnZXQgPSBNYXRoLm1pbiggc2xpZGUudGFyZ2V0LCBlbmRCb3VuZCApO1xuICAgIH1cbiAgfSwgdGhpcyApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbi8qKlxuICogZW1pdHMgZXZlbnRzIHZpYSBldmVudEVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gbmFtZSBvZiBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxuICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xuICovXG5wcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xuICB2YXIgZW1pdEFyZ3MgPSBldmVudCA/IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKSA6IGFyZ3M7XG4gIHRoaXMuZW1pdEV2ZW50KCB0eXBlLCBlbWl0QXJncyApO1xuXG4gIGlmICggalF1ZXJ5ICYmIHRoaXMuJGVsZW1lbnQgKSB7XG4gICAgLy8gZGVmYXVsdCB0cmlnZ2VyIHdpdGggdHlwZSBpZiBubyBldmVudFxuICAgIHR5cGUgKz0gdGhpcy5vcHRpb25zLm5hbWVzcGFjZUpRdWVyeUV2ZW50cyA/ICcuZmxpY2tpdHknIDogJyc7XG4gICAgdmFyICRldmVudCA9IHR5cGU7XG4gICAgaWYgKCBldmVudCApIHtcbiAgICAgIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgICAgIHZhciBqUUV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xuICAgICAgalFFdmVudC50eXBlID0gdHlwZTtcbiAgICAgICRldmVudCA9IGpRRXZlbnQ7XG4gICAgfVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggJGV2ZW50LCBhcmdzICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNlbGVjdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSBpbmRleCBvZiB0aGUgc2xpZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNXcmFwIC0gd2lsbCB3cmFwLWFyb3VuZCB0byBsYXN0L2ZpcnN0IGlmIGF0IHRoZSBlbmRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50IC0gd2lsbCBpbW1lZGlhdGVseSBzZXQgcG9zaXRpb24gYXQgc2VsZWN0ZWQgY2VsbFxuICovXG5wcm90by5zZWxlY3QgPSBmdW5jdGlvbiggaW5kZXgsIGlzV3JhcCwgaXNJbnN0YW50ICkge1xuICBpZiAoICF0aGlzLmlzQWN0aXZlICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpbmRleCA9IHBhcnNlSW50KCBpbmRleCwgMTAgKTtcbiAgdGhpcy5fd3JhcFNlbGVjdCggaW5kZXggKTtcblxuICBpZiAoIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kIHx8IGlzV3JhcCApIHtcbiAgICBpbmRleCA9IHV0aWxzLm1vZHVsbyggaW5kZXgsIHRoaXMuc2xpZGVzLmxlbmd0aCApO1xuICB9XG4gIC8vIGJhaWwgaWYgaW52YWxpZCBpbmRleFxuICBpZiAoICF0aGlzLnNsaWRlc1sgaW5kZXggXSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZXZJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gIHRoaXMudXBkYXRlU2VsZWN0ZWRTbGlkZSgpO1xuICBpZiAoIGlzSW5zdGFudCApIHtcbiAgICB0aGlzLnBvc2l0aW9uU2xpZGVyQXRTZWxlY3RlZCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcbiAgfVxuICBpZiAoIHRoaXMub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCApIHtcbiAgICB0aGlzLnNldEdhbGxlcnlTaXplKCk7XG4gIH1cbiAgLy8gZXZlbnRzXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3NlbGVjdCcsIG51bGwsIFsgaW5kZXggXSApO1xuICAvLyBjaGFuZ2UgZXZlbnQgaWYgbmV3IGluZGV4XG4gIGlmICggaW5kZXggIT0gcHJldkluZGV4ICkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2NoYW5nZScsIG51bGwsIFsgaW5kZXggXSApO1xuICB9XG4gIC8vIG9sZCB2MSBldmVudCBuYW1lLCByZW1vdmUgaW4gdjNcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjZWxsU2VsZWN0Jyk7XG59O1xuXG4vLyB3cmFwcyBwb3NpdGlvbiBmb3Igd3JhcEFyb3VuZCwgdG8gbW92ZSB0byBjbG9zZXN0IHNsaWRlLiAjMTEzXG5wcm90by5fd3JhcFNlbGVjdCA9IGZ1bmN0aW9uKCBpbmRleCApIHtcbiAgdmFyIGxlbiA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgdmFyIGlzV3JhcHBpbmcgPSB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCAmJiBsZW4gPiAxO1xuICBpZiAoICFpc1dyYXBwaW5nICkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICB2YXIgd3JhcEluZGV4ID0gdXRpbHMubW9kdWxvKCBpbmRleCwgbGVuICk7XG4gIC8vIGdvIHRvIHNob3J0ZXN0XG4gIHZhciBkZWx0YSA9IE1hdGguYWJzKCB3cmFwSW5kZXggLSB0aGlzLnNlbGVjdGVkSW5kZXggKTtcbiAgdmFyIGJhY2tXcmFwRGVsdGEgPSBNYXRoLmFicyggKCB3cmFwSW5kZXggKyBsZW4gKSAtIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICB2YXIgZm9yZXdhcmRXcmFwRGVsdGEgPSBNYXRoLmFicyggKCB3cmFwSW5kZXggLSBsZW4gKSAtIHRoaXMuc2VsZWN0ZWRJbmRleCApO1xuICBpZiAoICF0aGlzLmlzRHJhZ1NlbGVjdCAmJiBiYWNrV3JhcERlbHRhIDwgZGVsdGEgKSB7XG4gICAgaW5kZXggKz0gbGVuO1xuICB9IGVsc2UgaWYgKCAhdGhpcy5pc0RyYWdTZWxlY3QgJiYgZm9yZXdhcmRXcmFwRGVsdGEgPCBkZWx0YSApIHtcbiAgICBpbmRleCAtPSBsZW47XG4gIH1cbiAgLy8gd3JhcCBwb3NpdGlvbiBzbyBzbGlkZXIgaXMgd2l0aGluIG5vcm1hbCBhcmVhXG4gIGlmICggaW5kZXggPCAwICkge1xuICAgIHRoaXMueCAtPSB0aGlzLnNsaWRlYWJsZVdpZHRoO1xuICB9IGVsc2UgaWYgKCBpbmRleCA+PSBsZW4gKSB7XG4gICAgdGhpcy54ICs9IHRoaXMuc2xpZGVhYmxlV2lkdGg7XG4gIH1cbn07XG5cbnByb3RvLnByZXZpb3VzID0gZnVuY3Rpb24oIGlzV3JhcCwgaXNJbnN0YW50ICkge1xuICB0aGlzLnNlbGVjdCggdGhpcy5zZWxlY3RlZEluZGV4IC0gMSwgaXNXcmFwLCBpc0luc3RhbnQgKTtcbn07XG5cbnByb3RvLm5leHQgPSBmdW5jdGlvbiggaXNXcmFwLCBpc0luc3RhbnQgKSB7XG4gIHRoaXMuc2VsZWN0KCB0aGlzLnNlbGVjdGVkSW5kZXggKyAxLCBpc1dyYXAsIGlzSW5zdGFudCApO1xufTtcblxucHJvdG8udXBkYXRlU2VsZWN0ZWRTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1sgdGhpcy5zZWxlY3RlZEluZGV4IF07XG4gIC8vIHNlbGVjdGVkSW5kZXggY291bGQgYmUgb3V0c2lkZSBvZiBzbGlkZXMsIGlmIHRyaWdnZXJlZCBiZWZvcmUgcmVzaXplKClcbiAgaWYgKCAhc2xpZGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGVkIHNsaWRlXG4gIHRoaXMudW5zZWxlY3RTZWxlY3RlZFNsaWRlKCk7XG4gIC8vIHVwZGF0ZSBuZXcgc2VsZWN0ZWQgc2xpZGVcbiAgdGhpcy5zZWxlY3RlZFNsaWRlID0gc2xpZGU7XG4gIHNsaWRlLnNlbGVjdCgpO1xuICB0aGlzLnNlbGVjdGVkQ2VsbHMgPSBzbGlkZS5jZWxscztcbiAgdGhpcy5zZWxlY3RlZEVsZW1lbnRzID0gc2xpZGUuZ2V0Q2VsbEVsZW1lbnRzKCk7XG4gIC8vIEhBQ0s6IHNlbGVjdGVkQ2VsbCAmIHNlbGVjdGVkRWxlbWVudCBpcyBmaXJzdCBjZWxsIGluIHNsaWRlLCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAvLyBSZW1vdmUgaW4gdjM/XG4gIHRoaXMuc2VsZWN0ZWRDZWxsID0gc2xpZGUuY2VsbHNbMF07XG4gIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gdGhpcy5zZWxlY3RlZEVsZW1lbnRzWzBdO1xufTtcblxucHJvdG8udW5zZWxlY3RTZWxlY3RlZFNsaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5zZWxlY3RlZFNsaWRlICkge1xuICAgIHRoaXMuc2VsZWN0ZWRTbGlkZS51bnNlbGVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIHNlbGVjdCBzbGlkZSBmcm9tIG51bWJlciBvciBjZWxsIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudCBvciBOdW1iZXJ9IGVsZW1cbiAqL1xucHJvdG8uc2VsZWN0Q2VsbCA9IGZ1bmN0aW9uKCB2YWx1ZSwgaXNXcmFwLCBpc0luc3RhbnQgKSB7XG4gIC8vIGdldCBjZWxsXG4gIHZhciBjZWxsID0gdGhpcy5xdWVyeUNlbGwoIHZhbHVlICk7XG4gIGlmICggIWNlbGwgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gdGhpcy5nZXRDZWxsU2xpZGVJbmRleCggY2VsbCApO1xuICB0aGlzLnNlbGVjdCggaW5kZXgsIGlzV3JhcCwgaXNJbnN0YW50ICk7XG59O1xuXG5wcm90by5nZXRDZWxsU2xpZGVJbmRleCA9IGZ1bmN0aW9uKCBjZWxsICkge1xuICAvLyBnZXQgaW5kZXggb2Ygc2xpZGVzIHRoYXQgaGFzIGNlbGxcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW2ldO1xuICAgIHZhciBpbmRleCA9IHNsaWRlLmNlbGxzLmluZGV4T2YoIGNlbGwgKTtcbiAgICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXQgY2VsbHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXQgRmxpY2tpdHkuQ2VsbCwgZ2l2ZW4gYW4gRWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7RmxpY2tpdHkuQ2VsbH0gaXRlbVxuICovXG5wcm90by5nZXRDZWxsID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGxvb3AgdGhyb3VnaCBjZWxscyB0byBnZXQgdGhlIG9uZSB0aGF0IG1hdGNoZXNcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2ldO1xuICAgIGlmICggY2VsbC5lbGVtZW50ID09IGVsZW0gKSB7XG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IGNvbGxlY3Rpb24gb2YgRmxpY2tpdHkuQ2VsbHMsIGdpdmVuIEVsZW1lbnRzXG4gKiBAcGFyYW0ge0VsZW1lbnQsIEFycmF5LCBOb2RlTGlzdH0gZWxlbXNcbiAqIEByZXR1cm5zIHtBcnJheX0gY2VsbHMgLSBGbGlja2l0eS5DZWxsc1xuICovXG5wcm90by5nZXRDZWxscyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHZhciBjZWxscyA9IFtdO1xuICBlbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xuICAgIGlmICggY2VsbCApIHtcbiAgICAgIGNlbGxzLnB1c2goIGNlbGwgKTtcbiAgICB9XG4gIH0sIHRoaXMgKTtcbiAgcmV0dXJuIGNlbGxzO1xufTtcblxuLyoqXG4gKiBnZXQgY2VsbCBlbGVtZW50c1xuICogQHJldHVybnMge0FycmF5fSBjZWxsRWxlbXNcbiAqL1xucHJvdG8uZ2V0Q2VsbEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNlbGxzLm1hcCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgcmV0dXJuIGNlbGwuZWxlbWVudDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGdldCBwYXJlbnQgY2VsbCBmcm9tIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge0ZsaWNraXQuQ2VsbH0gY2VsbFxuICovXG5wcm90by5nZXRQYXJlbnRDZWxsID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIC8vIGZpcnN0IGNoZWNrIGlmIGVsZW0gaXMgY2VsbFxuICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xuICBpZiAoIGNlbGwgKSB7XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgLy8gdHJ5IHRvIGdldCBwYXJlbnQgY2VsbCBlbGVtXG4gIGVsZW0gPSB1dGlscy5nZXRQYXJlbnQoIGVsZW0sICcuZmxpY2tpdHktc2xpZGVyID4gKicgKTtcbiAgcmV0dXJuIHRoaXMuZ2V0Q2VsbCggZWxlbSApO1xufTtcblxuLyoqXG4gKiBnZXQgY2VsbHMgYWRqYWNlbnQgdG8gYSBzbGlkZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBhZGpDb3VudCAtIG51bWJlciBvZiBhZGphY2VudCBzbGlkZXNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXggLSBpbmRleCBvZiBzbGlkZSB0byBzdGFydFxuICogQHJldHVybnMge0FycmF5fSBjZWxscyAtIGFycmF5IG9mIEZsaWNraXR5LkNlbGxzXG4gKi9cbnByb3RvLmdldEFkamFjZW50Q2VsbEVsZW1lbnRzID0gZnVuY3Rpb24oIGFkakNvdW50LCBpbmRleCApIHtcbiAgaWYgKCAhYWRqQ291bnQgKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRTbGlkZS5nZXRDZWxsRWxlbWVudHMoKTtcbiAgfVxuICBpbmRleCA9IGluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLnNlbGVjdGVkSW5kZXggOiBpbmRleDtcblxuICB2YXIgbGVuID0gdGhpcy5zbGlkZXMubGVuZ3RoO1xuICBpZiAoIDEgKyAoIGFkakNvdW50ICogMiApID49IGxlbiApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsRWxlbWVudHMoKTtcbiAgfVxuXG4gIHZhciBjZWxsRWxlbXMgPSBbXTtcbiAgZm9yICggdmFyIGkgPSBpbmRleCAtIGFkakNvdW50OyBpIDw9IGluZGV4ICsgYWRqQ291bnQgOyBpKysgKSB7XG4gICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZCA/IHV0aWxzLm1vZHVsbyggaSwgbGVuICkgOiBpO1xuICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzWyBzbGlkZUluZGV4IF07XG4gICAgaWYgKCBzbGlkZSApIHtcbiAgICAgIGNlbGxFbGVtcyA9IGNlbGxFbGVtcy5jb25jYXQoIHNsaWRlLmdldENlbGxFbGVtZW50cygpICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjZWxsRWxlbXM7XG59O1xuXG4vKipcbiAqIHNlbGVjdCBzbGlkZSBmcm9tIG51bWJlciBvciBjZWxsIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudCwgU2VsZWN0b3IgU3RyaW5nLCBvciBOdW1iZXJ9IHNlbGVjdG9yXG4gKi9cbnByb3RvLnF1ZXJ5Q2VsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT0gJ251bWJlcicgKSB7XG4gICAgLy8gdXNlIG51bWJlciBhcyBpbmRleFxuICAgIHJldHVybiB0aGlzLmNlbGxzWyBzZWxlY3RvciBdO1xuICB9XG4gIGlmICggdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnICkge1xuICAgIC8vIHVzZSBzdHJpbmcgYXMgc2VsZWN0b3IsIGdldCBlbGVtZW50XG4gICAgc2VsZWN0b3IgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvciggc2VsZWN0b3IgKTtcbiAgfVxuICAvLyBnZXQgY2VsbCBmcm9tIGVsZW1lbnRcbiAgcmV0dXJuIHRoaXMuZ2V0Q2VsbCggc2VsZWN0b3IgKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGV2ZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5wcm90by51aUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXRFdmVudCgndWlDaGFuZ2UnKTtcbn07XG5cbnByb3RvLmNoaWxkVUlQb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdjaGlsZFVJUG9pbnRlckRvd24nLCBbIGV2ZW50IF0gKTtcbn07XG5cbi8vIC0tLS0tIHJlc2l6ZSAtLS0tLSAvL1xuXG5wcm90by5vbnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndhdGNoQ1NTKCk7XG4gIHRoaXMucmVzaXplKCk7XG59O1xuXG51dGlscy5kZWJvdW5jZU1ldGhvZCggRmxpY2tpdHksICdvbnJlc2l6ZScsIDE1MCApO1xuXG5wcm90by5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0FjdGl2ZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5nZXRTaXplKCk7XG4gIC8vIHdyYXAgdmFsdWVzXG4gIGlmICggdGhpcy5vcHRpb25zLndyYXBBcm91bmQgKSB7XG4gICAgdGhpcy54ID0gdXRpbHMubW9kdWxvKCB0aGlzLngsIHRoaXMuc2xpZGVhYmxlV2lkdGggKTtcbiAgfVxuICB0aGlzLnBvc2l0aW9uQ2VsbHMoKTtcbiAgdGhpcy5fZ2V0V3JhcFNoaWZ0Q2VsbHMoKTtcbiAgdGhpcy5zZXRHYWxsZXJ5U2l6ZSgpO1xuICB0aGlzLmVtaXRFdmVudCgncmVzaXplJyk7XG4gIC8vIHVwZGF0ZSBzZWxlY3RlZCBpbmRleCBmb3IgZ3JvdXAgc2xpZGVzLCBpbnN0YW50XG4gIC8vIFRPRE86IHBvc2l0aW9uIGNhbiBiZSBsb3N0IGJldHdlZW4gZ3JvdXBzIG9mIHZhcmlvdXMgbnVtYmVyc1xuICB2YXIgc2VsZWN0ZWRFbGVtZW50ID0gdGhpcy5zZWxlY3RlZEVsZW1lbnRzICYmIHRoaXMuc2VsZWN0ZWRFbGVtZW50c1swXTtcbiAgdGhpcy5zZWxlY3RDZWxsKCBzZWxlY3RlZEVsZW1lbnQsIGZhbHNlLCB0cnVlICk7XG59O1xuXG4vLyB3YXRjaGVzIHRoZSA6YWZ0ZXIgcHJvcGVydHksIGFjdGl2YXRlcy9kZWFjdGl2YXRlc1xucHJvdG8ud2F0Y2hDU1MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdhdGNoT3B0aW9uID0gdGhpcy5vcHRpb25zLndhdGNoQ1NTO1xuICBpZiAoICF3YXRjaE9wdGlvbiApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWZ0ZXJDb250ZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50LCAnOmFmdGVyJyApLmNvbnRlbnQ7XG4gIC8vIGFjdGl2YXRlIGlmIDphZnRlciB7IGNvbnRlbnQ6ICdmbGlja2l0eScgfVxuICBpZiAoIGFmdGVyQ29udGVudC5pbmRleE9mKCdmbGlja2l0eScpICE9IC0xICkge1xuICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0ga2V5ZG93biAtLS0tLSAvL1xuXG4vLyBnbyBwcmV2aW91cy9uZXh0IGlmIGxlZnQvcmlnaHQga2V5cyBwcmVzc2VkXG5wcm90by5vbmtleWRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIC8vIG9ubHkgd29yayBpZiBlbGVtZW50IGlzIGluIGZvY3VzXG4gIHZhciBpc05vdEZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5lbGVtZW50O1xuICBpZiAoICF0aGlzLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSB8fGlzTm90Rm9jdXNlZCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IEZsaWNraXR5LmtleWJvYXJkSGFuZGxlcnNbIGV2ZW50LmtleUNvZGUgXTtcbiAgaWYgKCBoYW5kbGVyICkge1xuICAgIGhhbmRsZXIuY2FsbCggdGhpcyApO1xuICB9XG59O1xuXG5GbGlja2l0eS5rZXlib2FyZEhhbmRsZXJzID0ge1xuICAvLyBsZWZ0IGFycm93XG4gIDM3OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVmdE1ldGhvZCA9IHRoaXMub3B0aW9ucy5yaWdodFRvTGVmdCA/ICduZXh0JyA6ICdwcmV2aW91cyc7XG4gICAgdGhpcy51aUNoYW5nZSgpO1xuICAgIHRoaXNbIGxlZnRNZXRob2QgXSgpO1xuICB9LFxuICAvLyByaWdodCBhcnJvd1xuICAzOTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpZ2h0TWV0aG9kID0gdGhpcy5vcHRpb25zLnJpZ2h0VG9MZWZ0ID8gJ3ByZXZpb3VzJyA6ICduZXh0JztcbiAgICB0aGlzLnVpQ2hhbmdlKCk7XG4gICAgdGhpc1sgcmlnaHRNZXRob2QgXSgpO1xuICB9LFxufTtcblxuLy8gLS0tLS0gZm9jdXMgLS0tLS0gLy9cblxucHJvdG8uZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByZXZTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgLy8gaGFjayB0byBmaXggc2Nyb2xsIGp1bXAgYWZ0ZXIgZm9jdXMsICM3NlxuICBpZiAoIHdpbmRvdy5wYWdlWU9mZnNldCAhPSBwcmV2U2Nyb2xsWSApIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8oIHdpbmRvdy5wYWdlWE9mZnNldCwgcHJldlNjcm9sbFkgKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGVzdHJveSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBkZWFjdGl2YXRlIGFsbCBGbGlja2l0eSBmdW5jdGlvbmFsaXR5LCBidXQga2VlcCBzdHVmZiBhdmFpbGFibGVcbnByb3RvLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0FjdGl2ZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ZsaWNraXR5LWVuYWJsZWQnKTtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ZsaWNraXR5LXJ0bCcpO1xuICB0aGlzLnVuc2VsZWN0U2VsZWN0ZWRTbGlkZSgpO1xuICAvLyBkZXN0cm95IGNlbGxzXG4gIHRoaXMuY2VsbHMuZm9yRWFjaCggZnVuY3Rpb24oIGNlbGwgKSB7XG4gICAgY2VsbC5kZXN0cm95KCk7XG4gIH0pO1xuICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRoaXMudmlld3BvcnQgKTtcbiAgLy8gbW92ZSBjaGlsZCBlbGVtZW50cyBiYWNrIGludG8gZWxlbWVudFxuICBtb3ZlRWxlbWVudHMoIHRoaXMuc2xpZGVyLmNoaWxkcmVuLCB0aGlzLmVsZW1lbnQgKTtcbiAgaWYgKCB0aGlzLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSApIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIHRoaXMgKTtcbiAgfVxuICAvLyBzZXQgZmxhZ3NcbiAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmVtaXRFdmVudCgnZGVhY3RpdmF0ZScpO1xufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuZW1pdEV2ZW50KCdkZXN0cm95Jyk7XG4gIGlmICggalF1ZXJ5ICYmIHRoaXMuJGVsZW1lbnQgKSB7XG4gICAgalF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMuZWxlbWVudCwgJ2ZsaWNraXR5JyApO1xuICB9XG4gIGRlbGV0ZSB0aGlzLmVsZW1lbnQuZmxpY2tpdHlHVUlEO1xuICBkZWxldGUgaW5zdGFuY2VzWyB0aGlzLmd1aWQgXTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHByb3RvdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG51dGlscy5leHRlbmQoIHByb3RvLCBhbmltYXRlUHJvdG90eXBlICk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGV4dHJhcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGdldCBGbGlja2l0eSBpbnN0YW5jZSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge0ZsaWNraXR5fVxuICovXG5GbGlja2l0eS5kYXRhID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIGVsZW0gPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW0gKTtcbiAgdmFyIGlkID0gZWxlbSAmJiBlbGVtLmZsaWNraXR5R1VJRDtcbiAgcmV0dXJuIGlkICYmIGluc3RhbmNlc1sgaWQgXTtcbn07XG5cbnV0aWxzLmh0bWxJbml0KCBGbGlja2l0eSwgJ2ZsaWNraXR5JyApO1xuXG5pZiAoIGpRdWVyeSAmJiBqUXVlcnkuYnJpZGdldCApIHtcbiAgalF1ZXJ5LmJyaWRnZXQoICdmbGlja2l0eScsIEZsaWNraXR5ICk7XG59XG5cbi8vIHNldCBpbnRlcm5hbCBqUXVlcnksIGZvciBXZWJwYWNrICsgalF1ZXJ5IHYzLCAjNDc4XG5GbGlja2l0eS5zZXRKUXVlcnkgPSBmdW5jdGlvbigganEgKSB7XG4gIGpRdWVyeSA9IGpxO1xufTtcblxuRmxpY2tpdHkuQ2VsbCA9IENlbGw7XG5cbnJldHVybiBGbGlja2l0eTtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsMkJBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/flickity.js\n")},"./node_modules/flickity/js/index.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Flickity v2.1.1\n * Touch, responsive, flickable carousels\n *\n * Licensed GPLv3 for open source use\n * or Flickity Commercial License for commercial use\n *\n * https://flickity.metafizzy.co\n * Copyright 2015-2018 Metafizzy\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ "./node_modules/flickity/js/flickity.js"),\n      __webpack_require__(/*! ./drag */ "./node_modules/flickity/js/drag.js"),\n      __webpack_require__(/*! ./prev-next-button */ "./node_modules/flickity/js/prev-next-button.js"),\n      __webpack_require__(/*! ./page-dots */ "./node_modules/flickity/js/page-dots.js"),\n      __webpack_require__(/*! ./player */ "./node_modules/flickity/js/player.js"),\n      __webpack_require__(/*! ./add-remove-cell */ "./node_modules/flickity/js/add-remove-cell.js"),\n      __webpack_require__(/*! ./lazyload */ "./node_modules/flickity/js/lazyload.js")\n    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( window, function factory( Flickity ) {\n  /*jshint strict: false*/\n  return Flickity;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvaW5kZXguanM/MjE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZsaWNraXR5IHYyLjEuMVxuICogVG91Y2gsIHJlc3BvbnNpdmUsIGZsaWNrYWJsZSBjYXJvdXNlbHNcbiAqXG4gKiBMaWNlbnNlZCBHUEx2MyBmb3Igb3BlbiBzb3VyY2UgdXNlXG4gKiBvciBGbGlja2l0eSBDb21tZXJjaWFsIExpY2Vuc2UgZm9yIGNvbW1lcmNpYWwgdXNlXG4gKlxuICogaHR0cHM6Ly9mbGlja2l0eS5tZXRhZml6enkuY29cbiAqIENvcHlyaWdodCAyMDE1LTIwMTggTWV0YWZpenp5XG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICcuL2RyYWcnLFxuICAgICAgJy4vcHJldi1uZXh0LWJ1dHRvbicsXG4gICAgICAnLi9wYWdlLWRvdHMnLFxuICAgICAgJy4vcGxheWVyJyxcbiAgICAgICcuL2FkZC1yZW1vdmUtY2VsbCcsXG4gICAgICAnLi9sYXp5bG9hZCdcbiAgICBdLCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCcuL2ZsaWNraXR5JyksXG4gICAgICByZXF1aXJlKCcuL2RyYWcnKSxcbiAgICAgIHJlcXVpcmUoJy4vcHJldi1uZXh0LWJ1dHRvbicpLFxuICAgICAgcmVxdWlyZSgnLi9wYWdlLWRvdHMnKSxcbiAgICAgIHJlcXVpcmUoJy4vcGxheWVyJyksXG4gICAgICByZXF1aXJlKCcuL2FkZC1yZW1vdmUtY2VsbCcpLFxuICAgICAgcmVxdWlyZSgnLi9sYXp5bG9hZCcpXG4gICAgKTtcbiAgfVxuXG59KSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBGbGlja2l0eSApIHtcbiAgLypqc2hpbnQgc3RyaWN0OiBmYWxzZSovXG4gIHJldHVybiBGbGlja2l0eTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/index.js\n')},"./node_modules/flickity/js/lazyload.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// lazyload\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Flickity, utils ) {\n      return factory( window, Flickity, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Flickity, utils ) {\n'use strict';\n\nFlickity.createMethods.push('_createLazyload');\nvar proto = Flickity.prototype;\n\nproto._createLazyload = function() {\n  this.on( 'select', this.lazyLoad );\n};\n\nproto.lazyLoad = function() {\n  var lazyLoad = this.options.lazyLoad;\n  if ( !lazyLoad ) {\n    return;\n  }\n  // get adjacent cells, use lazyLoad option for adjacent count\n  var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;\n  var cellElems = this.getAdjacentCellElements( adjCount );\n  // get lazy images in those cells\n  var lazyImages = [];\n  cellElems.forEach( function( cellElem ) {\n    var lazyCellImages = getCellLazyImages( cellElem );\n    lazyImages = lazyImages.concat( lazyCellImages );\n  });\n  // load lazy images\n  lazyImages.forEach( function( img ) {\n    new LazyLoader( img, this );\n  }, this );\n};\n\nfunction getCellLazyImages( cellElem ) {\n  // check if cell element is lazy image\n  if ( cellElem.nodeName == 'IMG' ) {\n    var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');\n    var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');\n    var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');\n    if ( lazyloadAttr || srcAttr || srcsetAttr ) {\n      return [ cellElem ];\n    }\n  }\n  // select lazy images in cell\n  var lazySelector = 'img[data-flickity-lazyload], ' +\n    'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';\n  var imgs = cellElem.querySelectorAll( lazySelector );\n  return utils.makeArray( imgs );\n}\n\n// -------------------------- LazyLoader -------------------------- //\n\n/**\n * class to handle loading images\n */\nfunction LazyLoader( img, flickity ) {\n  this.img = img;\n  this.flickity = flickity;\n  this.load();\n}\n\nLazyLoader.prototype.handleEvent = utils.handleEvent;\n\nLazyLoader.prototype.load = function() {\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  // get src & srcset\n  var src = this.img.getAttribute('data-flickity-lazyload') ||\n    this.img.getAttribute('data-flickity-lazyload-src');\n  var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');\n  // set src & serset\n  this.img.src = src;\n  if ( srcset ) {\n    this.img.setAttribute( 'srcset', srcset );\n  }\n  // remove attr\n  this.img.removeAttribute('data-flickity-lazyload');\n  this.img.removeAttribute('data-flickity-lazyload-src');\n  this.img.removeAttribute('data-flickity-lazyload-srcset');\n};\n\nLazyLoader.prototype.onload = function( event ) {\n  this.complete( event, 'flickity-lazyloaded' );\n};\n\nLazyLoader.prototype.onerror = function( event ) {\n  this.complete( event, 'flickity-lazyerror' );\n};\n\nLazyLoader.prototype.complete = function( event, className ) {\n  // unbind events\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n\n  var cell = this.flickity.getParentCell( this.img );\n  var cellElem = cell && cell.element;\n  this.flickity.cellSizeChange( cellElem );\n\n  this.img.classList.add( className );\n  this.flickity.dispatchEvent( 'lazyLoad', event, cellElem );\n};\n\n// -----  ----- //\n\nFlickity.LazyLoader = LazyLoader;\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvbGF6eWxvYWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvbGF6eWxvYWQuanM/OGExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsYXp5bG9hZFxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggRmxpY2tpdHksIHV0aWxzICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIHV0aWxzICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCcuL2ZsaWNraXR5JyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRmxpY2tpdHksXG4gICAgICB3aW5kb3cuZml6enlVSVV0aWxzXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRmxpY2tpdHksIHV0aWxzICkge1xuJ3VzZSBzdHJpY3QnO1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVMYXp5bG9hZCcpO1xudmFyIHByb3RvID0gRmxpY2tpdHkucHJvdG90eXBlO1xuXG5wcm90by5fY3JlYXRlTGF6eWxvYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vbiggJ3NlbGVjdCcsIHRoaXMubGF6eUxvYWQgKTtcbn07XG5cbnByb3RvLmxhenlMb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYXp5TG9hZCA9IHRoaXMub3B0aW9ucy5sYXp5TG9hZDtcbiAgaWYgKCAhbGF6eUxvYWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldCBhZGphY2VudCBjZWxscywgdXNlIGxhenlMb2FkIG9wdGlvbiBmb3IgYWRqYWNlbnQgY291bnRcbiAgdmFyIGFkakNvdW50ID0gdHlwZW9mIGxhenlMb2FkID09ICdudW1iZXInID8gbGF6eUxvYWQgOiAwO1xuICB2YXIgY2VsbEVsZW1zID0gdGhpcy5nZXRBZGphY2VudENlbGxFbGVtZW50cyggYWRqQ291bnQgKTtcbiAgLy8gZ2V0IGxhenkgaW1hZ2VzIGluIHRob3NlIGNlbGxzXG4gIHZhciBsYXp5SW1hZ2VzID0gW107XG4gIGNlbGxFbGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggY2VsbEVsZW0gKSB7XG4gICAgdmFyIGxhenlDZWxsSW1hZ2VzID0gZ2V0Q2VsbExhenlJbWFnZXMoIGNlbGxFbGVtICk7XG4gICAgbGF6eUltYWdlcyA9IGxhenlJbWFnZXMuY29uY2F0KCBsYXp5Q2VsbEltYWdlcyApO1xuICB9KTtcbiAgLy8gbG9hZCBsYXp5IGltYWdlc1xuICBsYXp5SW1hZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBpbWcgKSB7XG4gICAgbmV3IExhenlMb2FkZXIoIGltZywgdGhpcyApO1xuICB9LCB0aGlzICk7XG59O1xuXG5mdW5jdGlvbiBnZXRDZWxsTGF6eUltYWdlcyggY2VsbEVsZW0gKSB7XG4gIC8vIGNoZWNrIGlmIGNlbGwgZWxlbWVudCBpcyBsYXp5IGltYWdlXG4gIGlmICggY2VsbEVsZW0ubm9kZU5hbWUgPT0gJ0lNRycgKSB7XG4gICAgdmFyIGxhenlsb2FkQXR0ciA9IGNlbGxFbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZCcpO1xuICAgIHZhciBzcmNBdHRyID0gY2VsbEVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWZsaWNraXR5LWxhenlsb2FkLXNyYycpO1xuICAgIHZhciBzcmNzZXRBdHRyID0gY2VsbEVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWZsaWNraXR5LWxhenlsb2FkLXNyY3NldCcpO1xuICAgIGlmICggbGF6eWxvYWRBdHRyIHx8IHNyY0F0dHIgfHwgc3Jjc2V0QXR0ciApIHtcbiAgICAgIHJldHVybiBbIGNlbGxFbGVtIF07XG4gICAgfVxuICB9XG4gIC8vIHNlbGVjdCBsYXp5IGltYWdlcyBpbiBjZWxsXG4gIHZhciBsYXp5U2VsZWN0b3IgPSAnaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWRdLCAnICtcbiAgICAnaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3JjXSwgaW1nW2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3Jjc2V0XSc7XG4gIHZhciBpbWdzID0gY2VsbEVsZW0ucXVlcnlTZWxlY3RvckFsbCggbGF6eVNlbGVjdG9yICk7XG4gIHJldHVybiB1dGlscy5tYWtlQXJyYXkoIGltZ3MgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTGF6eUxvYWRlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGNsYXNzIHRvIGhhbmRsZSBsb2FkaW5nIGltYWdlc1xuICovXG5mdW5jdGlvbiBMYXp5TG9hZGVyKCBpbWcsIGZsaWNraXR5ICkge1xuICB0aGlzLmltZyA9IGltZztcbiAgdGhpcy5mbGlja2l0eSA9IGZsaWNraXR5O1xuICB0aGlzLmxvYWQoKTtcbn1cblxuTGF6eUxvYWRlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSB1dGlscy5oYW5kbGVFdmVudDtcblxuTGF6eUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIHRoaXMgKTtcbiAgdGhpcy5pbWcuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgdGhpcyApO1xuICAvLyBnZXQgc3JjICYgc3Jjc2V0XG4gIHZhciBzcmMgPSB0aGlzLmltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmxpY2tpdHktbGF6eWxvYWQnKSB8fFxuICAgIHRoaXMuaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmMnKTtcbiAgdmFyIHNyY3NldCA9IHRoaXMuaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmNzZXQnKTtcbiAgLy8gc2V0IHNyYyAmIHNlcnNldFxuICB0aGlzLmltZy5zcmMgPSBzcmM7XG4gIGlmICggc3Jjc2V0ICkge1xuICAgIHRoaXMuaW1nLnNldEF0dHJpYnV0ZSggJ3NyY3NldCcsIHNyY3NldCApO1xuICB9XG4gIC8vIHJlbW92ZSBhdHRyXG4gIHRoaXMuaW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZCcpO1xuICB0aGlzLmltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZmxpY2tpdHktbGF6eWxvYWQtc3JjJyk7XG4gIHRoaXMuaW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1mbGlja2l0eS1sYXp5bG9hZC1zcmNzZXQnKTtcbn07XG5cbkxhenlMb2FkZXIucHJvdG90eXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5jb21wbGV0ZSggZXZlbnQsICdmbGlja2l0eS1sYXp5bG9hZGVkJyApO1xufTtcblxuTGF6eUxvYWRlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5jb21wbGV0ZSggZXZlbnQsICdmbGlja2l0eS1sYXp5ZXJyb3InICk7XG59O1xuXG5MYXp5TG9hZGVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBldmVudCwgY2xhc3NOYW1lICkge1xuICAvLyB1bmJpbmQgZXZlbnRzXG4gIHRoaXMuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkJywgdGhpcyApO1xuICB0aGlzLmltZy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZXJyb3InLCB0aGlzICk7XG5cbiAgdmFyIGNlbGwgPSB0aGlzLmZsaWNraXR5LmdldFBhcmVudENlbGwoIHRoaXMuaW1nICk7XG4gIHZhciBjZWxsRWxlbSA9IGNlbGwgJiYgY2VsbC5lbGVtZW50O1xuICB0aGlzLmZsaWNraXR5LmNlbGxTaXplQ2hhbmdlKCBjZWxsRWxlbSApO1xuXG4gIHRoaXMuaW1nLmNsYXNzTGlzdC5hZGQoIGNsYXNzTmFtZSApO1xuICB0aGlzLmZsaWNraXR5LmRpc3BhdGNoRXZlbnQoICdsYXp5TG9hZCcsIGV2ZW50LCBjZWxsRWxlbSApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbkZsaWNraXR5LkxhenlMb2FkZXIgPSBMYXp5TG9hZGVyO1xuXG5yZXR1cm4gRmxpY2tpdHk7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/lazyload.js\n")},"./node_modules/flickity/js/page-dots.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// page dots\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"),\n      __webpack_require__(/*! tap-listener/tap-listener */ \"./node_modules/tap-listener/tap-listener.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Flickity, TapListener, utils ) {\n      return factory( window, Flickity, TapListener, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Flickity, TapListener, utils ) {\n\n// -------------------------- PageDots -------------------------- //\n\n'use strict';\n\nfunction PageDots( parent ) {\n  this.parent = parent;\n  this._create();\n}\n\nPageDots.prototype = new TapListener();\n\nPageDots.prototype._create = function() {\n  // create holder element\n  this.holder = document.createElement('ol');\n  this.holder.className = 'flickity-page-dots';\n  // create dots, array of elements\n  this.dots = [];\n  // events\n  this.on( 'tap', this.onTap );\n  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );\n};\n\nPageDots.prototype.activate = function() {\n  this.setDots();\n  this.bindTap( this.holder );\n  // add to DOM\n  this.parent.element.appendChild( this.holder );\n};\n\nPageDots.prototype.deactivate = function() {\n  // remove from DOM\n  this.parent.element.removeChild( this.holder );\n  TapListener.prototype.destroy.call( this );\n};\n\nPageDots.prototype.setDots = function() {\n  // get difference between number of slides and number of dots\n  var delta = this.parent.slides.length - this.dots.length;\n  if ( delta > 0 ) {\n    this.addDots( delta );\n  } else if ( delta < 0 ) {\n    this.removeDots( -delta );\n  }\n};\n\nPageDots.prototype.addDots = function( count ) {\n  var fragment = document.createDocumentFragment();\n  var newDots = [];\n  var length = this.dots.length;\n  var max = length + count;\n\n  for ( var i = length; i < max; i++ ) {\n    var dot = document.createElement('li');\n    dot.className = 'dot';\n    dot.setAttribute( 'aria-label', 'Page dot ' + ( i + 1 ) );\n    fragment.appendChild( dot );\n    newDots.push( dot );\n  }\n\n  this.holder.appendChild( fragment );\n  this.dots = this.dots.concat( newDots );\n};\n\nPageDots.prototype.removeDots = function( count ) {\n  // remove from this.dots collection\n  var removeDots = this.dots.splice( this.dots.length - count, count );\n  // remove from DOM\n  removeDots.forEach( function( dot ) {\n    this.holder.removeChild( dot );\n  }, this );\n};\n\nPageDots.prototype.updateSelected = function() {\n  // remove selected class on previous\n  if ( this.selectedDot ) {\n    this.selectedDot.className = 'dot';\n    this.selectedDot.removeAttribute('aria-current');\n  }\n  // don't proceed if no dots\n  if ( !this.dots.length ) {\n    return;\n  }\n  this.selectedDot = this.dots[ this.parent.selectedIndex ];\n  this.selectedDot.className = 'dot is-selected';\n  this.selectedDot.setAttribute( 'aria-current', 'step' );\n};\n\nPageDots.prototype.onTap = function( event ) {\n  var target = event.target;\n  // only care about dot clicks\n  if ( target.nodeName != 'LI' ) {\n    return;\n  }\n\n  this.parent.uiChange();\n  var index = this.dots.indexOf( target );\n  this.parent.select( index );\n};\n\nPageDots.prototype.destroy = function() {\n  this.deactivate();\n};\n\nFlickity.PageDots = PageDots;\n\n// -------------------------- Flickity -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  pageDots: true\n});\n\nFlickity.createMethods.push('_createPageDots');\n\nvar proto = Flickity.prototype;\n\nproto._createPageDots = function() {\n  if ( !this.options.pageDots ) {\n    return;\n  }\n  this.pageDots = new PageDots( this );\n  // events\n  this.on( 'activate', this.activatePageDots );\n  this.on( 'select', this.updateSelectedPageDots );\n  this.on( 'cellChange', this.updatePageDots );\n  this.on( 'resize', this.updatePageDots );\n  this.on( 'deactivate', this.deactivatePageDots );\n};\n\nproto.activatePageDots = function() {\n  this.pageDots.activate();\n};\n\nproto.updateSelectedPageDots = function() {\n  this.pageDots.updateSelected();\n};\n\nproto.updatePageDots = function() {\n  this.pageDots.setDots();\n};\n\nproto.deactivatePageDots = function() {\n  this.pageDots.deactivate();\n};\n\n// -----  ----- //\n\nFlickity.PageDots = PageDots;\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvcGFnZS1kb3RzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL3BhZ2UtZG90cy5qcz8wNjI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2UgZG90c1xuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICcuL2ZsaWNraXR5JyxcbiAgICAgICd0YXAtbGlzdGVuZXIvdGFwLWxpc3RlbmVyJyxcbiAgICAgICdmaXp6eS11aS11dGlscy91dGlscydcbiAgICBdLCBmdW5jdGlvbiggRmxpY2tpdHksIFRhcExpc3RlbmVyLCB1dGlscyApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCBUYXBMaXN0ZW5lciwgdXRpbHMgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJy4vZmxpY2tpdHknKSxcbiAgICAgIHJlcXVpcmUoJ3RhcC1saXN0ZW5lcicpLFxuICAgICAgcmVxdWlyZSgnZml6enktdWktdXRpbHMnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkZsaWNraXR5LFxuICAgICAgd2luZG93LlRhcExpc3RlbmVyLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlsc1xuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIEZsaWNraXR5LCBUYXBMaXN0ZW5lciwgdXRpbHMgKSB7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBhZ2VEb3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUGFnZURvdHMoIHBhcmVudCApIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG5QYWdlRG90cy5wcm90b3R5cGUgPSBuZXcgVGFwTGlzdGVuZXIoKTtcblxuUGFnZURvdHMucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gY3JlYXRlIGhvbGRlciBlbGVtZW50XG4gIHRoaXMuaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2wnKTtcbiAgdGhpcy5ob2xkZXIuY2xhc3NOYW1lID0gJ2ZsaWNraXR5LXBhZ2UtZG90cyc7XG4gIC8vIGNyZWF0ZSBkb3RzLCBhcnJheSBvZiBlbGVtZW50c1xuICB0aGlzLmRvdHMgPSBbXTtcbiAgLy8gZXZlbnRzXG4gIHRoaXMub24oICd0YXAnLCB0aGlzLm9uVGFwICk7XG4gIHRoaXMub24oICdwb2ludGVyRG93bicsIHRoaXMucGFyZW50LmNoaWxkVUlQb2ludGVyRG93bi5iaW5kKCB0aGlzLnBhcmVudCApICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXREb3RzKCk7XG4gIHRoaXMuYmluZFRhcCggdGhpcy5ob2xkZXIgKTtcbiAgLy8gYWRkIHRvIERPTVxuICB0aGlzLnBhcmVudC5lbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLmhvbGRlciApO1xufTtcblxuUGFnZURvdHMucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIHRoaXMucGFyZW50LmVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRoaXMuaG9sZGVyICk7XG4gIFRhcExpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwoIHRoaXMgKTtcbn07XG5cblBhZ2VEb3RzLnByb3RvdHlwZS5zZXREb3RzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGdldCBkaWZmZXJlbmNlIGJldHdlZW4gbnVtYmVyIG9mIHNsaWRlcyBhbmQgbnVtYmVyIG9mIGRvdHNcbiAgdmFyIGRlbHRhID0gdGhpcy5wYXJlbnQuc2xpZGVzLmxlbmd0aCAtIHRoaXMuZG90cy5sZW5ndGg7XG4gIGlmICggZGVsdGEgPiAwICkge1xuICAgIHRoaXMuYWRkRG90cyggZGVsdGEgKTtcbiAgfSBlbHNlIGlmICggZGVsdGEgPCAwICkge1xuICAgIHRoaXMucmVtb3ZlRG90cyggLWRlbHRhICk7XG4gIH1cbn07XG5cblBhZ2VEb3RzLnByb3RvdHlwZS5hZGREb3RzID0gZnVuY3Rpb24oIGNvdW50ICkge1xuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBuZXdEb3RzID0gW107XG4gIHZhciBsZW5ndGggPSB0aGlzLmRvdHMubGVuZ3RoO1xuICB2YXIgbWF4ID0gbGVuZ3RoICsgY291bnQ7XG5cbiAgZm9yICggdmFyIGkgPSBsZW5ndGg7IGkgPCBtYXg7IGkrKyApIHtcbiAgICB2YXIgZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBkb3QuY2xhc3NOYW1lID0gJ2RvdCc7XG4gICAgZG90LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWwnLCAnUGFnZSBkb3QgJyArICggaSArIDEgKSApO1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb3QgKTtcbiAgICBuZXdEb3RzLnB1c2goIGRvdCApO1xuICB9XG5cbiAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQoIGZyYWdtZW50ICk7XG4gIHRoaXMuZG90cyA9IHRoaXMuZG90cy5jb25jYXQoIG5ld0RvdHMgKTtcbn07XG5cblBhZ2VEb3RzLnByb3RvdHlwZS5yZW1vdmVEb3RzID0gZnVuY3Rpb24oIGNvdW50ICkge1xuICAvLyByZW1vdmUgZnJvbSB0aGlzLmRvdHMgY29sbGVjdGlvblxuICB2YXIgcmVtb3ZlRG90cyA9IHRoaXMuZG90cy5zcGxpY2UoIHRoaXMuZG90cy5sZW5ndGggLSBjb3VudCwgY291bnQgKTtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIHJlbW92ZURvdHMuZm9yRWFjaCggZnVuY3Rpb24oIGRvdCApIHtcbiAgICB0aGlzLmhvbGRlci5yZW1vdmVDaGlsZCggZG90ICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cblBhZ2VEb3RzLnByb3RvdHlwZS51cGRhdGVTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgc2VsZWN0ZWQgY2xhc3Mgb24gcHJldmlvdXNcbiAgaWYgKCB0aGlzLnNlbGVjdGVkRG90ICkge1xuICAgIHRoaXMuc2VsZWN0ZWREb3QuY2xhc3NOYW1lID0gJ2RvdCc7XG4gICAgdGhpcy5zZWxlY3RlZERvdC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICB9XG4gIC8vIGRvbid0IHByb2NlZWQgaWYgbm8gZG90c1xuICBpZiAoICF0aGlzLmRvdHMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNlbGVjdGVkRG90ID0gdGhpcy5kb3RzWyB0aGlzLnBhcmVudC5zZWxlY3RlZEluZGV4IF07XG4gIHRoaXMuc2VsZWN0ZWREb3QuY2xhc3NOYW1lID0gJ2RvdCBpcy1zZWxlY3RlZCc7XG4gIHRoaXMuc2VsZWN0ZWREb3Quc2V0QXR0cmlidXRlKCAnYXJpYS1jdXJyZW50JywgJ3N0ZXAnICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUub25UYXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIC8vIG9ubHkgY2FyZSBhYm91dCBkb3QgY2xpY2tzXG4gIGlmICggdGFyZ2V0Lm5vZGVOYW1lICE9ICdMSScgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wYXJlbnQudWlDaGFuZ2UoKTtcbiAgdmFyIGluZGV4ID0gdGhpcy5kb3RzLmluZGV4T2YoIHRhcmdldCApO1xuICB0aGlzLnBhcmVudC5zZWxlY3QoIGluZGV4ICk7XG59O1xuXG5QYWdlRG90cy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbn07XG5cbkZsaWNraXR5LlBhZ2VEb3RzID0gUGFnZURvdHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZsaWNraXR5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnV0aWxzLmV4dGVuZCggRmxpY2tpdHkuZGVmYXVsdHMsIHtcbiAgcGFnZURvdHM6IHRydWVcbn0pO1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVQYWdlRG90cycpO1xuXG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG5cbnByb3RvLl9jcmVhdGVQYWdlRG90cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLm9wdGlvbnMucGFnZURvdHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucGFnZURvdHMgPSBuZXcgUGFnZURvdHMoIHRoaXMgKTtcbiAgLy8gZXZlbnRzXG4gIHRoaXMub24oICdhY3RpdmF0ZScsIHRoaXMuYWN0aXZhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAnc2VsZWN0JywgdGhpcy51cGRhdGVTZWxlY3RlZFBhZ2VEb3RzICk7XG4gIHRoaXMub24oICdjZWxsQ2hhbmdlJywgdGhpcy51cGRhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAncmVzaXplJywgdGhpcy51cGRhdGVQYWdlRG90cyApO1xuICB0aGlzLm9uKCAnZGVhY3RpdmF0ZScsIHRoaXMuZGVhY3RpdmF0ZVBhZ2VEb3RzICk7XG59O1xuXG5wcm90by5hY3RpdmF0ZVBhZ2VEb3RzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGFnZURvdHMuYWN0aXZhdGUoKTtcbn07XG5cbnByb3RvLnVwZGF0ZVNlbGVjdGVkUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy51cGRhdGVTZWxlY3RlZCgpO1xufTtcblxucHJvdG8udXBkYXRlUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy5zZXREb3RzKCk7XG59O1xuXG5wcm90by5kZWFjdGl2YXRlUGFnZURvdHMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYWdlRG90cy5kZWFjdGl2YXRlKCk7XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxuRmxpY2tpdHkuUGFnZURvdHMgPSBQYWdlRG90cztcblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/page-dots.js\n")},"./node_modules/flickity/js/player.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// player & autoPlay\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\"),\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter, utils, Flickity ) {\n      return factory( EvEmitter, utils, Flickity );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( EvEmitter, utils, Flickity ) {\n\n'use strict';\n\n// -------------------------- Player -------------------------- //\n\nfunction Player( parent ) {\n  this.parent = parent;\n  this.state = 'stopped';\n  // visibility change event handler\n  this.onVisibilityChange = this.visibilityChange.bind( this );\n  this.onVisibilityPlay = this.visibilityPlay.bind( this );\n}\n\nPlayer.prototype = Object.create( EvEmitter.prototype );\n\n// start play\nPlayer.prototype.play = function() {\n  if ( this.state == 'playing' ) {\n    return;\n  }\n  // do not play if page is hidden, start playing when page is visible\n  var isPageHidden = document.hidden;\n  if ( isPageHidden ) {\n    document.addEventListener( 'visibilitychange', this.onVisibilityPlay );\n    return;\n  }\n\n  this.state = 'playing';\n  // listen to visibility change\n  document.addEventListener( 'visibilitychange', this.onVisibilityChange );\n  // start ticking\n  this.tick();\n};\n\nPlayer.prototype.tick = function() {\n  // do not tick if not playing\n  if ( this.state != 'playing' ) {\n    return;\n  }\n\n  var time = this.parent.options.autoPlay;\n  // default to 3 seconds\n  time = typeof time == 'number' ? time : 3000;\n  var _this = this;\n  // HACK: reset ticks if stopped and started within interval\n  this.clear();\n  this.timeout = setTimeout( function() {\n    _this.parent.next( true );\n    _this.tick();\n  }, time );\n};\n\nPlayer.prototype.stop = function() {\n  this.state = 'stopped';\n  this.clear();\n  // remove visibility change event\n  document.removeEventListener( 'visibilitychange', this.onVisibilityChange );\n};\n\nPlayer.prototype.clear = function() {\n  clearTimeout( this.timeout );\n};\n\nPlayer.prototype.pause = function() {\n  if ( this.state == 'playing' ) {\n    this.state = 'paused';\n    this.clear();\n  }\n};\n\nPlayer.prototype.unpause = function() {\n  // re-start play if paused\n  if ( this.state == 'paused' ) {\n    this.play();\n  }\n};\n\n// pause if page visibility is hidden, unpause if visible\nPlayer.prototype.visibilityChange = function() {\n  var isPageHidden = document.hidden;\n  this[ isPageHidden ? 'pause' : 'unpause' ]();\n};\n\nPlayer.prototype.visibilityPlay = function() {\n  this.play();\n  document.removeEventListener( 'visibilitychange', this.onVisibilityPlay );\n};\n\n// -------------------------- Flickity -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  pauseAutoPlayOnHover: true\n});\n\nFlickity.createMethods.push('_createPlayer');\nvar proto = Flickity.prototype;\n\nproto._createPlayer = function() {\n  this.player = new Player( this );\n\n  this.on( 'activate', this.activatePlayer );\n  this.on( 'uiChange', this.stopPlayer );\n  this.on( 'pointerDown', this.stopPlayer );\n  this.on( 'deactivate', this.deactivatePlayer );\n};\n\nproto.activatePlayer = function() {\n  if ( !this.options.autoPlay ) {\n    return;\n  }\n  this.player.play();\n  this.element.addEventListener( 'mouseenter', this );\n};\n\n// Player API, don't hate the ... thanks I know where the door is\n\nproto.playPlayer = function() {\n  this.player.play();\n};\n\nproto.stopPlayer = function() {\n  this.player.stop();\n};\n\nproto.pausePlayer = function() {\n  this.player.pause();\n};\n\nproto.unpausePlayer = function() {\n  this.player.unpause();\n};\n\nproto.deactivatePlayer = function() {\n  this.player.stop();\n  this.element.removeEventListener( 'mouseenter', this );\n};\n\n// ----- mouseenter/leave ----- //\n\n// pause auto-play on hover\nproto.onmouseenter = function() {\n  if ( !this.options.pauseAutoPlayOnHover ) {\n    return;\n  }\n  this.player.pause();\n  this.element.addEventListener( 'mouseleave', this );\n};\n\n// resume auto-play on hover off\nproto.onmouseleave = function() {\n  this.player.unpause();\n  this.element.removeEventListener( 'mouseleave', this );\n};\n\n// -----  ----- //\n\nFlickity.Player = Player;\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvcGxheWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZsaWNraXR5L2pzL3BsYXllci5qcz9iMThhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBsYXllciAmIGF1dG9QbGF5XG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnLFxuICAgICAgJy4vZmxpY2tpdHknXG4gICAgXSwgZnVuY3Rpb24oIEV2RW1pdHRlciwgdXRpbHMsIEZsaWNraXR5ICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIEV2RW1pdHRlciwgdXRpbHMsIEZsaWNraXR5ICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICByZXF1aXJlKCdldi1lbWl0dGVyJyksXG4gICAgICByZXF1aXJlKCdmaXp6eS11aS11dGlscycpLFxuICAgICAgcmVxdWlyZSgnLi9mbGlja2l0eScpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIGZhY3RvcnkoXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlscyxcbiAgICAgIHdpbmRvdy5GbGlja2l0eVxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCBFdkVtaXR0ZXIsIHV0aWxzLCBGbGlja2l0eSApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQbGF5ZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gUGxheWVyKCBwYXJlbnQgKSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLnN0YXRlID0gJ3N0b3BwZWQnO1xuICAvLyB2aXNpYmlsaXR5IGNoYW5nZSBldmVudCBoYW5kbGVyXG4gIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlLmJpbmQoIHRoaXMgKTtcbiAgdGhpcy5vblZpc2liaWxpdHlQbGF5ID0gdGhpcy52aXNpYmlsaXR5UGxheS5iaW5kKCB0aGlzICk7XG59XG5cblBsYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbi8vIHN0YXJ0IHBsYXlcblBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMuc3RhdGUgPT0gJ3BsYXlpbmcnICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBkbyBub3QgcGxheSBpZiBwYWdlIGlzIGhpZGRlbiwgc3RhcnQgcGxheWluZyB3aGVuIHBhZ2UgaXMgdmlzaWJsZVxuICB2YXIgaXNQYWdlSGlkZGVuID0gZG9jdW1lbnQuaGlkZGVuO1xuICBpZiAoIGlzUGFnZUhpZGRlbiApIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMub25WaXNpYmlsaXR5UGxheSApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhdGUgPSAncGxheWluZyc7XG4gIC8vIGxpc3RlbiB0byB2aXNpYmlsaXR5IGNoYW5nZVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlICk7XG4gIC8vIHN0YXJ0IHRpY2tpbmdcbiAgdGhpcy50aWNrKCk7XG59O1xuXG5QbGF5ZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gbm90IHRpY2sgaWYgbm90IHBsYXlpbmdcbiAgaWYgKCB0aGlzLnN0YXRlICE9ICdwbGF5aW5nJyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGltZSA9IHRoaXMucGFyZW50Lm9wdGlvbnMuYXV0b1BsYXk7XG4gIC8vIGRlZmF1bHQgdG8gMyBzZWNvbmRzXG4gIHRpbWUgPSB0eXBlb2YgdGltZSA9PSAnbnVtYmVyJyA/IHRpbWUgOiAzMDAwO1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICAvLyBIQUNLOiByZXNldCB0aWNrcyBpZiBzdG9wcGVkIGFuZCBzdGFydGVkIHdpdGhpbiBpbnRlcnZhbFxuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLnBhcmVudC5uZXh0KCB0cnVlICk7XG4gICAgX3RoaXMudGljaygpO1xuICB9LCB0aW1lICk7XG59O1xuXG5QbGF5ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdGF0ZSA9ICdzdG9wcGVkJztcbiAgdGhpcy5jbGVhcigpO1xuICAvLyByZW1vdmUgdmlzaWJpbGl0eSBjaGFuZ2UgZXZlbnRcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZSApO1xufTtcblxuUGxheWVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQoIHRoaXMudGltZW91dCApO1xufTtcblxuUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMuc3RhdGUgPT0gJ3BsYXlpbmcnICkge1xuICAgIHRoaXMuc3RhdGUgPSAncGF1c2VkJztcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbn07XG5cblBsYXllci5wcm90b3R5cGUudW5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZS1zdGFydCBwbGF5IGlmIHBhdXNlZFxuICBpZiAoIHRoaXMuc3RhdGUgPT0gJ3BhdXNlZCcgKSB7XG4gICAgdGhpcy5wbGF5KCk7XG4gIH1cbn07XG5cbi8vIHBhdXNlIGlmIHBhZ2UgdmlzaWJpbGl0eSBpcyBoaWRkZW4sIHVucGF1c2UgaWYgdmlzaWJsZVxuUGxheWVyLnByb3RvdHlwZS52aXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1BhZ2VIaWRkZW4gPSBkb2N1bWVudC5oaWRkZW47XG4gIHRoaXNbIGlzUGFnZUhpZGRlbiA/ICdwYXVzZScgOiAndW5wYXVzZScgXSgpO1xufTtcblxuUGxheWVyLnByb3RvdHlwZS52aXNpYmlsaXR5UGxheSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBsYXkoKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLm9uVmlzaWJpbGl0eVBsYXkgKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZsaWNraXR5IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnV0aWxzLmV4dGVuZCggRmxpY2tpdHkuZGVmYXVsdHMsIHtcbiAgcGF1c2VBdXRvUGxheU9uSG92ZXI6IHRydWVcbn0pO1xuXG5GbGlja2l0eS5jcmVhdGVNZXRob2RzLnB1c2goJ19jcmVhdGVQbGF5ZXInKTtcbnZhciBwcm90byA9IEZsaWNraXR5LnByb3RvdHlwZTtcblxucHJvdG8uX2NyZWF0ZVBsYXllciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIoIHRoaXMgKTtcblxuICB0aGlzLm9uKCAnYWN0aXZhdGUnLCB0aGlzLmFjdGl2YXRlUGxheWVyICk7XG4gIHRoaXMub24oICd1aUNoYW5nZScsIHRoaXMuc3RvcFBsYXllciApO1xuICB0aGlzLm9uKCAncG9pbnRlckRvd24nLCB0aGlzLnN0b3BQbGF5ZXIgKTtcbiAgdGhpcy5vbiggJ2RlYWN0aXZhdGUnLCB0aGlzLmRlYWN0aXZhdGVQbGF5ZXIgKTtcbn07XG5cbnByb3RvLmFjdGl2YXRlUGxheWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMub3B0aW9ucy5hdXRvUGxheSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wbGF5ZXIucGxheSgpO1xuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZW50ZXInLCB0aGlzICk7XG59O1xuXG4vLyBQbGF5ZXIgQVBJLCBkb24ndCBoYXRlIHRoZSAuLi4gdGhhbmtzIEkga25vdyB3aGVyZSB0aGUgZG9vciBpc1xuXG5wcm90by5wbGF5UGxheWVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGxheWVyLnBsYXkoKTtcbn07XG5cbnByb3RvLnN0b3BQbGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5ZXIuc3RvcCgpO1xufTtcblxucHJvdG8ucGF1c2VQbGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5ZXIucGF1c2UoKTtcbn07XG5cbnByb3RvLnVucGF1c2VQbGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wbGF5ZXIudW5wYXVzZSgpO1xufTtcblxucHJvdG8uZGVhY3RpdmF0ZVBsYXllciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBsYXllci5zdG9wKCk7XG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2VlbnRlcicsIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tIG1vdXNlZW50ZXIvbGVhdmUgLS0tLS0gLy9cblxuLy8gcGF1c2UgYXV0by1wbGF5IG9uIGhvdmVyXG5wcm90by5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLnBhdXNlQXV0b1BsYXlPbkhvdmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnBsYXllci5wYXVzZSgpO1xuICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbGVhdmUnLCB0aGlzICk7XG59O1xuXG4vLyByZXN1bWUgYXV0by1wbGF5IG9uIGhvdmVyIG9mZlxucHJvdG8ub25tb3VzZWxlYXZlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGxheWVyLnVucGF1c2UoKTtcbiAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZWxlYXZlJywgdGhpcyApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbkZsaWNraXR5LlBsYXllciA9IFBsYXllcjtcblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/player.js\n")},"./node_modules/flickity/js/prev-next-button.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// prev/next buttons\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"),\n      __webpack_require__(/*! tap-listener/tap-listener */ \"./node_modules/tap-listener/tap-listener.js\"),\n      __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Flickity, TapListener, utils ) {\n      return factory( window, Flickity, TapListener, utils );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Flickity, TapListener, utils ) {\n'use strict';\n\nvar svgURI = 'http://www.w3.org/2000/svg';\n\n// -------------------------- PrevNextButton -------------------------- //\n\nfunction PrevNextButton( direction, parent ) {\n  this.direction = direction;\n  this.parent = parent;\n  this._create();\n}\n\nPrevNextButton.prototype = Object.create( TapListener.prototype );\n\nPrevNextButton.prototype._create = function() {\n  // properties\n  this.isEnabled = true;\n  this.isPrevious = this.direction == -1;\n  var leftDirection = this.parent.options.rightToLeft ? 1 : -1;\n  this.isLeft = this.direction == leftDirection;\n\n  var element = this.element = document.createElement('button');\n  element.className = 'flickity-button flickity-prev-next-button';\n  element.className += this.isPrevious ? ' previous' : ' next';\n  // prevent button from submitting form http://stackoverflow.com/a/10836076/182183\n  element.setAttribute( 'type', 'button' );\n  // init as disabled\n  this.disable();\n\n  element.setAttribute( 'aria-label', this.isPrevious ? 'Previous' : 'Next' );\n\n  // create arrow\n  var svg = this.createSVG();\n  element.appendChild( svg );\n  // events\n  this.on( 'tap', this.onTap );\n  this.parent.on( 'select', this.update.bind( this ) );\n  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );\n};\n\nPrevNextButton.prototype.activate = function() {\n  this.bindTap( this.element );\n  // click events from keyboard\n  this.element.addEventListener( 'click', this );\n  // add to DOM\n  this.parent.element.appendChild( this.element );\n};\n\nPrevNextButton.prototype.deactivate = function() {\n  // remove from DOM\n  this.parent.element.removeChild( this.element );\n  // do regular TapListener destroy\n  TapListener.prototype.destroy.call( this );\n  // click events from keyboard\n  this.element.removeEventListener( 'click', this );\n};\n\nPrevNextButton.prototype.createSVG = function() {\n  var svg = document.createElementNS( svgURI, 'svg');\n  svg.setAttribute( 'class', 'flickity-button-icon' );\n  svg.setAttribute( 'viewBox', '0 0 100 100' );\n  var path = document.createElementNS( svgURI, 'path');\n  var pathMovements = getArrowMovements( this.parent.options.arrowShape );\n  path.setAttribute( 'd', pathMovements );\n  path.setAttribute( 'class', 'arrow' );\n  // rotate arrow\n  if ( !this.isLeft ) {\n    path.setAttribute( 'transform', 'translate(100, 100) rotate(180) ' );\n  }\n  svg.appendChild( path );\n  return svg;\n};\n\n// get SVG path movmement\nfunction getArrowMovements( shape ) {\n  // use shape as movement if string\n  if ( typeof shape == 'string' ) {\n    return shape;\n  }\n  // create movement string\n  return 'M ' + shape.x0 + ',50' +\n    ' L ' + shape.x1 + ',' + ( shape.y1 + 50 ) +\n    ' L ' + shape.x2 + ',' + ( shape.y2 + 50 ) +\n    ' L ' + shape.x3 + ',50 ' +\n    ' L ' + shape.x2 + ',' + ( 50 - shape.y2 ) +\n    ' L ' + shape.x1 + ',' + ( 50 - shape.y1 ) +\n    ' Z';\n}\n\nPrevNextButton.prototype.onTap = function() {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this.parent.uiChange();\n  var method = this.isPrevious ? 'previous' : 'next';\n  this.parent[ method ]();\n};\n\nPrevNextButton.prototype.handleEvent = utils.handleEvent;\n\nPrevNextButton.prototype.onclick = function( event ) {\n  // only allow clicks from keyboard\n  var focused = document.activeElement;\n  if ( focused && focused == this.element ) {\n    this.onTap( event, event );\n  }\n};\n\n// -----  ----- //\n\nPrevNextButton.prototype.enable = function() {\n  if ( this.isEnabled ) {\n    return;\n  }\n  this.element.disabled = false;\n  this.isEnabled = true;\n};\n\nPrevNextButton.prototype.disable = function() {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this.element.disabled = true;\n  this.isEnabled = false;\n};\n\nPrevNextButton.prototype.update = function() {\n  // index of first or last slide, if previous or next\n  var slides = this.parent.slides;\n  // enable is wrapAround and at least 2 slides\n  if ( this.parent.options.wrapAround && slides.length > 1 ) {\n    this.enable();\n    return;\n  }\n  var lastIndex = slides.length ? slides.length - 1 : 0;\n  var boundIndex = this.isPrevious ? 0 : lastIndex;\n  var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';\n  this[ method ]();\n};\n\nPrevNextButton.prototype.destroy = function() {\n  this.deactivate();\n};\n\n// -------------------------- Flickity prototype -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  prevNextButtons: true,\n  arrowShape: {\n    x0: 10,\n    x1: 60, y1: 50,\n    x2: 70, y2: 40,\n    x3: 30\n  }\n});\n\nFlickity.createMethods.push('_createPrevNextButtons');\nvar proto = Flickity.prototype;\n\nproto._createPrevNextButtons = function() {\n  if ( !this.options.prevNextButtons ) {\n    return;\n  }\n\n  this.prevButton = new PrevNextButton( -1, this );\n  this.nextButton = new PrevNextButton( 1, this );\n\n  this.on( 'activate', this.activatePrevNextButtons );\n};\n\nproto.activatePrevNextButtons = function() {\n  this.prevButton.activate();\n  this.nextButton.activate();\n  this.on( 'deactivate', this.deactivatePrevNextButtons );\n};\n\nproto.deactivatePrevNextButtons = function() {\n  this.prevButton.deactivate();\n  this.nextButton.deactivate();\n  this.off( 'deactivate', this.deactivatePrevNextButtons );\n};\n\n// --------------------------  -------------------------- //\n\nFlickity.PrevNextButton = PrevNextButton;\n\nreturn Flickity;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvcHJldi1uZXh0LWJ1dHRvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGlja2l0eS9qcy9wcmV2LW5leHQtYnV0dG9uLmpzP2NmYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcHJldi9uZXh0IGJ1dHRvbnNcbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnLi9mbGlja2l0eScsXG4gICAgICAndGFwLWxpc3RlbmVyL3RhcC1saXN0ZW5lcicsXG4gICAgICAnZml6enktdWktdXRpbHMvdXRpbHMnXG4gICAgXSwgZnVuY3Rpb24oIEZsaWNraXR5LCBUYXBMaXN0ZW5lciwgdXRpbHMgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgVGFwTGlzdGVuZXIsIHV0aWxzICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCcuL2ZsaWNraXR5JyksXG4gICAgICByZXF1aXJlKCd0YXAtbGlzdGVuZXInKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5GbGlja2l0eSxcbiAgICAgIHdpbmRvdy5UYXBMaXN0ZW5lcixcbiAgICAgIHdpbmRvdy5maXp6eVVJVXRpbHNcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBGbGlja2l0eSwgVGFwTGlzdGVuZXIsIHV0aWxzICkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3ZnVVJJID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUHJldk5leHRCdXR0b24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gUHJldk5leHRCdXR0b24oIGRpcmVjdGlvbiwgcGFyZW50ICkge1xuICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUYXBMaXN0ZW5lci5wcm90b3R5cGUgKTtcblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcHJvcGVydGllc1xuICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gIHRoaXMuaXNQcmV2aW91cyA9IHRoaXMuZGlyZWN0aW9uID09IC0xO1xuICB2YXIgbGVmdERpcmVjdGlvbiA9IHRoaXMucGFyZW50Lm9wdGlvbnMucmlnaHRUb0xlZnQgPyAxIDogLTE7XG4gIHRoaXMuaXNMZWZ0ID0gdGhpcy5kaXJlY3Rpb24gPT0gbGVmdERpcmVjdGlvbjtcblxuICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBlbGVtZW50LmNsYXNzTmFtZSA9ICdmbGlja2l0eS1idXR0b24gZmxpY2tpdHktcHJldi1uZXh0LWJ1dHRvbic7XG4gIGVsZW1lbnQuY2xhc3NOYW1lICs9IHRoaXMuaXNQcmV2aW91cyA/ICcgcHJldmlvdXMnIDogJyBuZXh0JztcbiAgLy8gcHJldmVudCBidXR0b24gZnJvbSBzdWJtaXR0aW5nIGZvcm0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA4MzYwNzYvMTgyMTgzXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCAndHlwZScsICdidXR0b24nICk7XG4gIC8vIGluaXQgYXMgZGlzYWJsZWRcbiAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsJywgdGhpcy5pc1ByZXZpb3VzID8gJ1ByZXZpb3VzJyA6ICdOZXh0JyApO1xuXG4gIC8vIGNyZWF0ZSBhcnJvd1xuICB2YXIgc3ZnID0gdGhpcy5jcmVhdGVTVkcoKTtcbiAgZWxlbWVudC5hcHBlbmRDaGlsZCggc3ZnICk7XG4gIC8vIGV2ZW50c1xuICB0aGlzLm9uKCAndGFwJywgdGhpcy5vblRhcCApO1xuICB0aGlzLnBhcmVudC5vbiggJ3NlbGVjdCcsIHRoaXMudXBkYXRlLmJpbmQoIHRoaXMgKSApO1xuICB0aGlzLm9uKCAncG9pbnRlckRvd24nLCB0aGlzLnBhcmVudC5jaGlsZFVJUG9pbnRlckRvd24uYmluZCggdGhpcy5wYXJlbnQgKSApO1xufTtcblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYmluZFRhcCggdGhpcy5lbGVtZW50ICk7XG4gIC8vIGNsaWNrIGV2ZW50cyBmcm9tIGtleWJvYXJkXG4gIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCB0aGlzICk7XG4gIC8vIGFkZCB0byBET01cbiAgdGhpcy5wYXJlbnQuZWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy5lbGVtZW50ICk7XG59O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgZnJvbSBET01cbiAgdGhpcy5wYXJlbnQuZWxlbWVudC5yZW1vdmVDaGlsZCggdGhpcy5lbGVtZW50ICk7XG4gIC8vIGRvIHJlZ3VsYXIgVGFwTGlzdGVuZXIgZGVzdHJveVxuICBUYXBMaXN0ZW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKCB0aGlzICk7XG4gIC8vIGNsaWNrIGV2ZW50cyBmcm9tIGtleWJvYXJkXG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCB0aGlzICk7XG59O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlU1ZHID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoIHN2Z1VSSSwgJ3N2ZycpO1xuICBzdmcuc2V0QXR0cmlidXRlKCAnY2xhc3MnLCAnZmxpY2tpdHktYnV0dG9uLWljb24nICk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoICd2aWV3Qm94JywgJzAgMCAxMDAgMTAwJyApO1xuICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggc3ZnVVJJLCAncGF0aCcpO1xuICB2YXIgcGF0aE1vdmVtZW50cyA9IGdldEFycm93TW92ZW1lbnRzKCB0aGlzLnBhcmVudC5vcHRpb25zLmFycm93U2hhcGUgKTtcbiAgcGF0aC5zZXRBdHRyaWJ1dGUoICdkJywgcGF0aE1vdmVtZW50cyApO1xuICBwYXRoLnNldEF0dHJpYnV0ZSggJ2NsYXNzJywgJ2Fycm93JyApO1xuICAvLyByb3RhdGUgYXJyb3dcbiAgaWYgKCAhdGhpcy5pc0xlZnQgKSB7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDEwMCwgMTAwKSByb3RhdGUoMTgwKSAnICk7XG4gIH1cbiAgc3ZnLmFwcGVuZENoaWxkKCBwYXRoICk7XG4gIHJldHVybiBzdmc7XG59O1xuXG4vLyBnZXQgU1ZHIHBhdGggbW92bWVtZW50XG5mdW5jdGlvbiBnZXRBcnJvd01vdmVtZW50cyggc2hhcGUgKSB7XG4gIC8vIHVzZSBzaGFwZSBhcyBtb3ZlbWVudCBpZiBzdHJpbmdcbiAgaWYgKCB0eXBlb2Ygc2hhcGUgPT0gJ3N0cmluZycgKSB7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG4gIC8vIGNyZWF0ZSBtb3ZlbWVudCBzdHJpbmdcbiAgcmV0dXJuICdNICcgKyBzaGFwZS54MCArICcsNTAnICtcbiAgICAnIEwgJyArIHNoYXBlLngxICsgJywnICsgKCBzaGFwZS55MSArIDUwICkgK1xuICAgICcgTCAnICsgc2hhcGUueDIgKyAnLCcgKyAoIHNoYXBlLnkyICsgNTAgKSArXG4gICAgJyBMICcgKyBzaGFwZS54MyArICcsNTAgJyArXG4gICAgJyBMICcgKyBzaGFwZS54MiArICcsJyArICggNTAgLSBzaGFwZS55MiApICtcbiAgICAnIEwgJyArIHNoYXBlLngxICsgJywnICsgKCA1MCAtIHNoYXBlLnkxICkgK1xuICAgICcgWic7XG59XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5vblRhcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wYXJlbnQudWlDaGFuZ2UoKTtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuaXNQcmV2aW91cyA/ICdwcmV2aW91cycgOiAnbmV4dCc7XG4gIHRoaXMucGFyZW50WyBtZXRob2QgXSgpO1xufTtcblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gdXRpbHMuaGFuZGxlRXZlbnQ7XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5vbmNsaWNrID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAvLyBvbmx5IGFsbG93IGNsaWNrcyBmcm9tIGtleWJvYXJkXG4gIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCBmb2N1c2VkICYmIGZvY3VzZWQgPT0gdGhpcy5lbGVtZW50ICkge1xuICAgIHRoaXMub25UYXAoIGV2ZW50LCBldmVudCApO1xuICB9XG59O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMuaXNFbmFibGVkICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmVsZW1lbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xufTtcblxuUHJldk5leHRCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZWxlbWVudC5kaXNhYmxlZCA9IHRydWU7XG4gIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG59O1xuXG5QcmV2TmV4dEJ1dHRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGluZGV4IG9mIGZpcnN0IG9yIGxhc3Qgc2xpZGUsIGlmIHByZXZpb3VzIG9yIG5leHRcbiAgdmFyIHNsaWRlcyA9IHRoaXMucGFyZW50LnNsaWRlcztcbiAgLy8gZW5hYmxlIGlzIHdyYXBBcm91bmQgYW5kIGF0IGxlYXN0IDIgc2xpZGVzXG4gIGlmICggdGhpcy5wYXJlbnQub3B0aW9ucy53cmFwQXJvdW5kICYmIHNsaWRlcy5sZW5ndGggPiAxICkge1xuICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBzbGlkZXMubGVuZ3RoID8gc2xpZGVzLmxlbmd0aCAtIDEgOiAwO1xuICB2YXIgYm91bmRJbmRleCA9IHRoaXMuaXNQcmV2aW91cyA/IDAgOiBsYXN0SW5kZXg7XG4gIHZhciBtZXRob2QgPSB0aGlzLnBhcmVudC5zZWxlY3RlZEluZGV4ID09IGJvdW5kSW5kZXggPyAnZGlzYWJsZScgOiAnZW5hYmxlJztcbiAgdGhpc1sgbWV0aG9kIF0oKTtcbn07XG5cblByZXZOZXh0QnV0dG9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRmxpY2tpdHkgcHJvdG90eXBlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnV0aWxzLmV4dGVuZCggRmxpY2tpdHkuZGVmYXVsdHMsIHtcbiAgcHJldk5leHRCdXR0b25zOiB0cnVlLFxuICBhcnJvd1NoYXBlOiB7XG4gICAgeDA6IDEwLFxuICAgIHgxOiA2MCwgeTE6IDUwLFxuICAgIHgyOiA3MCwgeTI6IDQwLFxuICAgIHgzOiAzMFxuICB9XG59KTtcblxuRmxpY2tpdHkuY3JlYXRlTWV0aG9kcy5wdXNoKCdfY3JlYXRlUHJldk5leHRCdXR0b25zJyk7XG52YXIgcHJvdG8gPSBGbGlja2l0eS5wcm90b3R5cGU7XG5cbnByb3RvLl9jcmVhdGVQcmV2TmV4dEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLnByZXZOZXh0QnV0dG9ucyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnByZXZCdXR0b24gPSBuZXcgUHJldk5leHRCdXR0b24oIC0xLCB0aGlzICk7XG4gIHRoaXMubmV4dEJ1dHRvbiA9IG5ldyBQcmV2TmV4dEJ1dHRvbiggMSwgdGhpcyApO1xuXG4gIHRoaXMub24oICdhY3RpdmF0ZScsIHRoaXMuYWN0aXZhdGVQcmV2TmV4dEJ1dHRvbnMgKTtcbn07XG5cbnByb3RvLmFjdGl2YXRlUHJldk5leHRCdXR0b25zID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldkJ1dHRvbi5hY3RpdmF0ZSgpO1xuICB0aGlzLm5leHRCdXR0b24uYWN0aXZhdGUoKTtcbiAgdGhpcy5vbiggJ2RlYWN0aXZhdGUnLCB0aGlzLmRlYWN0aXZhdGVQcmV2TmV4dEJ1dHRvbnMgKTtcbn07XG5cbnByb3RvLmRlYWN0aXZhdGVQcmV2TmV4dEJ1dHRvbnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2QnV0dG9uLmRlYWN0aXZhdGUoKTtcbiAgdGhpcy5uZXh0QnV0dG9uLmRlYWN0aXZhdGUoKTtcbiAgdGhpcy5vZmYoICdkZWFjdGl2YXRlJywgdGhpcy5kZWFjdGl2YXRlUHJldk5leHRCdXR0b25zICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuRmxpY2tpdHkuUHJldk5leHRCdXR0b24gPSBQcmV2TmV4dEJ1dHRvbjtcblxucmV0dXJuIEZsaWNraXR5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/prev-next-button.js\n")},"./node_modules/flickity/js/slide.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// slide\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory() {\n'use strict';\n\nfunction Slide( parent ) {\n  this.parent = parent;\n  this.isOriginLeft = parent.originSide == 'left';\n  this.cells = [];\n  this.outerWidth = 0;\n  this.height = 0;\n}\n\nvar proto = Slide.prototype;\n\nproto.addCell = function( cell ) {\n  this.cells.push( cell );\n  this.outerWidth += cell.size.outerWidth;\n  this.height = Math.max( cell.size.outerHeight, this.height );\n  // first cell stuff\n  if ( this.cells.length == 1 ) {\n    this.x = cell.x; // x comes from first cell\n    var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';\n    this.firstMargin = cell.size[ beginMargin ];\n  }\n};\n\nproto.updateTarget = function() {\n  var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';\n  var lastCell = this.getLastCell();\n  var lastMargin = lastCell ? lastCell.size[ endMargin ] : 0;\n  var slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );\n  this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;\n};\n\nproto.getLastCell = function() {\n  return this.cells[ this.cells.length - 1 ];\n};\n\nproto.select = function() {\n  this.changeSelected( true );\n};\n\nproto.unselect = function() {\n  this.changeSelected( false );\n};\n\nproto.changeSelected = function( isSelected ) {\n  var classMethod = isSelected ? 'add' : 'remove';\n  this.cells.forEach( function( cell ) {\n    cell.element.classList[ classMethod ]('is-selected');\n    cell.element.setAttribute( 'aria-selected', isSelected.toString() );\n  });\n};\n\nproto.getCellElements = function() {\n  return this.cells.map( function( cell ) {\n    return cell.element;\n  });\n};\n\nreturn Slide;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvc2xpZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxpY2tpdHkvanMvc2xpZGUuanM/NzY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzbGlkZVxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LkZsaWNraXR5ID0gd2luZG93LkZsaWNraXR5IHx8IHt9O1xuICAgIHdpbmRvdy5GbGlja2l0eS5TbGlkZSA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFNsaWRlKCBwYXJlbnQgKSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmlzT3JpZ2luTGVmdCA9IHBhcmVudC5vcmlnaW5TaWRlID09ICdsZWZ0JztcbiAgdGhpcy5jZWxscyA9IFtdO1xuICB0aGlzLm91dGVyV2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG59XG5cbnZhciBwcm90byA9IFNsaWRlLnByb3RvdHlwZTtcblxucHJvdG8uYWRkQ2VsbCA9IGZ1bmN0aW9uKCBjZWxsICkge1xuICB0aGlzLmNlbGxzLnB1c2goIGNlbGwgKTtcbiAgdGhpcy5vdXRlcldpZHRoICs9IGNlbGwuc2l6ZS5vdXRlcldpZHRoO1xuICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KCBjZWxsLnNpemUub3V0ZXJIZWlnaHQsIHRoaXMuaGVpZ2h0ICk7XG4gIC8vIGZpcnN0IGNlbGwgc3R1ZmZcbiAgaWYgKCB0aGlzLmNlbGxzLmxlbmd0aCA9PSAxICkge1xuICAgIHRoaXMueCA9IGNlbGwueDsgLy8geCBjb21lcyBmcm9tIGZpcnN0IGNlbGxcbiAgICB2YXIgYmVnaW5NYXJnaW4gPSB0aGlzLmlzT3JpZ2luTGVmdCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCc7XG4gICAgdGhpcy5maXJzdE1hcmdpbiA9IGNlbGwuc2l6ZVsgYmVnaW5NYXJnaW4gXTtcbiAgfVxufTtcblxucHJvdG8udXBkYXRlVGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRNYXJnaW4gPSB0aGlzLmlzT3JpZ2luTGVmdCA/ICdtYXJnaW5SaWdodCcgOiAnbWFyZ2luTGVmdCc7XG4gIHZhciBsYXN0Q2VsbCA9IHRoaXMuZ2V0TGFzdENlbGwoKTtcbiAgdmFyIGxhc3RNYXJnaW4gPSBsYXN0Q2VsbCA/IGxhc3RDZWxsLnNpemVbIGVuZE1hcmdpbiBdIDogMDtcbiAgdmFyIHNsaWRlV2lkdGggPSB0aGlzLm91dGVyV2lkdGggLSAoIHRoaXMuZmlyc3RNYXJnaW4gKyBsYXN0TWFyZ2luICk7XG4gIHRoaXMudGFyZ2V0ID0gdGhpcy54ICsgdGhpcy5maXJzdE1hcmdpbiArIHNsaWRlV2lkdGggKiB0aGlzLnBhcmVudC5jZWxsQWxpZ247XG59O1xuXG5wcm90by5nZXRMYXN0Q2VsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jZWxsc1sgdGhpcy5jZWxscy5sZW5ndGggLSAxIF07XG59O1xuXG5wcm90by5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jaGFuZ2VTZWxlY3RlZCggdHJ1ZSApO1xufTtcblxucHJvdG8udW5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jaGFuZ2VTZWxlY3RlZCggZmFsc2UgKTtcbn07XG5cbnByb3RvLmNoYW5nZVNlbGVjdGVkID0gZnVuY3Rpb24oIGlzU2VsZWN0ZWQgKSB7XG4gIHZhciBjbGFzc01ldGhvZCA9IGlzU2VsZWN0ZWQgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICB0aGlzLmNlbGxzLmZvckVhY2goIGZ1bmN0aW9uKCBjZWxsICkge1xuICAgIGNlbGwuZWxlbWVudC5jbGFzc0xpc3RbIGNsYXNzTWV0aG9kIF0oJ2lzLXNlbGVjdGVkJyk7XG4gICAgY2VsbC5lbGVtZW50LnNldEF0dHJpYnV0ZSggJ2FyaWEtc2VsZWN0ZWQnLCBpc1NlbGVjdGVkLnRvU3RyaW5nKCkgKTtcbiAgfSk7XG59O1xuXG5wcm90by5nZXRDZWxsRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2VsbHMubWFwKCBmdW5jdGlvbiggY2VsbCApIHtcbiAgICByZXR1cm4gY2VsbC5lbGVtZW50O1xuICB9KTtcbn07XG5cbnJldHVybiBTbGlkZTtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsV0FPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flickity/js/slide.js\n")},"./node_modules/get-size/get-size.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n( function( window, factory ) {\n  /* jshint strict: false */ /* globals define, module */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See https://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * Chrome & Safari measure the outer-width on style.width on border-box elems\n   * IE11 & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n  // round value for browser zoom. desandro/masonry#928\n  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;\n  getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n  body.removeChild( div );\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanM/NDBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGdldFNpemUgdjIuMC4zXG4gKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoganNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuLyogZ2xvYmFscyBjb25zb2xlOiBmYWxzZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmdldFNpemUgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkoIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgYSBudW1iZXIgZnJvbSBhIHN0cmluZywgbm90IGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gIC8vIG5vdCBhIHBlcmNlbnQgbGlrZSAnMTAwJScsIGFuZCBhIG51bWJlclxuICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PSAtMSAmJiAhaXNOYU4oIG51bSApO1xuICByZXR1cm4gaXNWYWxpZCAmJiBudW07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG5vb3AgOlxuICBmdW5jdGlvbiggbWVzc2FnZSApIHtcbiAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XG4gIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgbWVhc3VyZW1lbnRzID0gW1xuICAncGFkZGluZ0xlZnQnLFxuICAncGFkZGluZ1JpZ2h0JyxcbiAgJ3BhZGRpbmdUb3AnLFxuICAncGFkZGluZ0JvdHRvbScsXG4gICdtYXJnaW5MZWZ0JyxcbiAgJ21hcmdpblJpZ2h0JyxcbiAgJ21hcmdpblRvcCcsXG4gICdtYXJnaW5Cb3R0b20nLFxuICAnYm9yZGVyTGVmdFdpZHRoJyxcbiAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAnYm9yZGVyVG9wV2lkdGgnLFxuICAnYm9yZGVyQm90dG9tV2lkdGgnXG5dO1xuXG52YXIgbWVhc3VyZW1lbnRzTGVuZ3RoID0gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuZnVuY3Rpb24gZ2V0WmVyb1NpemUoKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBpbm5lcldpZHRoOiAwLFxuICAgIGlubmVySGVpZ2h0OiAwLFxuICAgIG91dGVyV2lkdGg6IDAsXG4gICAgb3V0ZXJIZWlnaHQ6IDBcbiAgfTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U3R5bGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXRTdHlsZSwgZ2V0IHN0eWxlIG9mIGVsZW1lbnQsIGNoZWNrIGZvciBGaXJlZm94IGJ1Z1xuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKCBlbGVtICkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gIGlmICggIXN0eWxlICkge1xuICAgIGxvZ0Vycm9yKCAnU3R5bGUgcmV0dXJuZWQgJyArIHN0eWxlICtcbiAgICAgICcuIEFyZSB5b3UgcnVubmluZyB0aGlzIGNvZGUgaW4gYSBoaWRkZW4gaWZyYW1lIG9uIEZpcmVmb3g/ICcgK1xuICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBpc1NldHVwID0gZmFsc2U7XG5cbnZhciBpc0JveFNpemVPdXRlcjtcblxuLyoqXG4gKiBzZXR1cFxuICogY2hlY2sgaXNCb3hTaXplck91dGVyXG4gKiBkbyBvbiBmaXJzdCBnZXRTaXplKCkgcmF0aGVyIHRoYW4gb24gcGFnZSBsb2FkIGZvciBGaXJlZm94IGJ1Z1xuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgLy8gc2V0dXAgb25jZVxuICBpZiAoIGlzU2V0dXAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlzU2V0dXAgPSB0cnVlO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGJveCBzaXppbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogQ2hyb21lICYgU2FmYXJpIG1lYXN1cmUgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcbiAgICogSUUxMSAmIEZpcmVmb3g8MjkgbWVhc3VyZXMgdGhlIGlubmVyLXdpZHRoXG4gICAqL1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzFweCAycHggM3B4IDRweCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuXG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZGl2ICk7XG4gIC8vIHJvdW5kIHZhbHVlIGZvciBicm93c2VyIHpvb20uIGRlc2FuZHJvL21hc29ucnkjOTI4XG4gIGlzQm94U2l6ZU91dGVyID0gTWF0aC5yb3VuZCggZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApICkgPT0gMjAwO1xuICBnZXRTaXplLmlzQm94U2l6ZU91dGVyID0gaXNCb3hTaXplT3V0ZXI7XG5cbiAgYm9keS5yZW1vdmVDaGlsZCggZGl2ICk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcbiAgc2V0dXAoKTtcblxuICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW0gPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGRvIG5vdCBwcm9jZWVkIG9uIG5vbi1vYmplY3RzXG4gIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT0gJ29iamVjdCcgfHwgIWVsZW0ubm9kZVR5cGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGVsZW0gKTtcblxuICAvLyBpZiBoaWRkZW4sIGV2ZXJ5dGhpbmcgaXMgMFxuICBpZiAoIHN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICkge1xuICAgIHJldHVybiBnZXRaZXJvU2l6ZSgpO1xuICB9XG5cbiAgdmFyIHNpemUgPSB7fTtcbiAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cbiAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PSAnYm9yZGVyLWJveCc7XG5cbiAgLy8gZ2V0IGFsbCBtZWFzdXJlbWVudHNcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVsgbWVhc3VyZW1lbnQgXTtcbiAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAvLyBhbnkgJ2F1dG8nLCAnbWVkaXVtJyB2YWx1ZSB3aWxsIGJlIDBcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XG4gIH1cblxuICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xuICB2YXIgcGFkZGluZ0hlaWdodCA9IHNpemUucGFkZGluZ1RvcCArIHNpemUucGFkZGluZ0JvdHRvbTtcbiAgdmFyIG1hcmdpbldpZHRoID0gc2l6ZS5tYXJnaW5MZWZ0ICsgc2l6ZS5tYXJnaW5SaWdodDtcbiAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XG4gIHZhciBib3JkZXJXaWR0aCA9IHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICB2YXIgYm9yZGVySGVpZ2h0ID0gc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIGlzQm9yZGVyQm94U2l6ZU91dGVyID0gaXNCb3JkZXJCb3ggJiYgaXNCb3hTaXplT3V0ZXI7XG5cbiAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXG4gIHZhciBzdHlsZVdpZHRoID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApO1xuICBpZiAoIHN0eWxlV2lkdGggIT09IGZhbHNlICkge1xuICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgfVxuXG4gIHZhciBzdHlsZUhlaWdodCA9IGdldFN0eWxlU2l6ZSggc3R5bGUuaGVpZ2h0ICk7XG4gIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xuICAgIHNpemUuaGVpZ2h0ID0gc3R5bGVIZWlnaHQgK1xuICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxuICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG4gIH1cblxuICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICBzaXplLmlubmVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSAoIHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcblxuICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XG4gIHNpemUub3V0ZXJIZWlnaHQgPSBzaXplLmhlaWdodCArIG1hcmdpbkhlaWdodDtcblxuICByZXR1cm4gc2l6ZTtcbn1cblxucmV0dXJuIGdldFNpemU7XG5cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxXQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/get-size/get-size.js\n")},"./node_modules/lazysizes/lazysizes.js":function(module,exports){eval("(function(window, factory) {\n\tvar lazySizes = factory(window, window.document);\n\twindow.lazySizes = lazySizes;\n\tif(typeof module == 'object' && module.exports){\n\t\tmodule.exports = lazySizes;\n\t}\n}(window, function l(window, document) {\n\t'use strict';\n\t/*jshint eqnull:true */\n\tif(!document.getElementsByClassName){return;}\n\n\tvar lazysizes, lazySizesConfig;\n\n\tvar docElem = document.documentElement;\n\n\tvar Date = window.Date;\n\n\tvar supportPicture = window.HTMLPictureElement;\n\n\tvar _addEventListener = 'addEventListener';\n\n\tvar _getAttribute = 'getAttribute';\n\n\tvar addEventListener = window[_addEventListener];\n\n\tvar setTimeout = window.setTimeout;\n\n\tvar requestAnimationFrame = window.requestAnimationFrame || setTimeout;\n\n\tvar requestIdleCallback = window.requestIdleCallback;\n\n\tvar regPicture = /^picture$/i;\n\n\tvar loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];\n\n\tvar regClassCache = {};\n\n\tvar forEach = Array.prototype.forEach;\n\n\tvar hasClass = function(ele, cls) {\n\t\tif(!regClassCache[cls]){\n\t\t\tregClassCache[cls] = new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)');\n\t\t}\n\t\treturn regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];\n\t};\n\n\tvar addClass = function(ele, cls) {\n\t\tif (!hasClass(ele, cls)){\n\t\t\tele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);\n\t\t}\n\t};\n\n\tvar removeClass = function(ele, cls) {\n\t\tvar reg;\n\t\tif ((reg = hasClass(ele,cls))) {\n\t\t\tele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));\n\t\t}\n\t};\n\n\tvar addRemoveLoadEvents = function(dom, fn, add){\n\t\tvar action = add ? _addEventListener : 'removeEventListener';\n\t\tif(add){\n\t\t\taddRemoveLoadEvents(dom, fn);\n\t\t}\n\t\tloadEvents.forEach(function(evt){\n\t\t\tdom[action](evt, fn);\n\t\t});\n\t};\n\n\tvar triggerEvent = function(elem, name, detail, noBubbles, noCancelable){\n\t\tvar event = document.createEvent('CustomEvent');\n\n\t\tif(!detail){\n\t\t\tdetail = {};\n\t\t}\n\n\t\tdetail.instance = lazysizes;\n\n\t\tevent.initCustomEvent(name, !noBubbles, !noCancelable, detail);\n\n\t\telem.dispatchEvent(event);\n\t\treturn event;\n\t};\n\n\tvar updatePolyfill = function (el, full){\n\t\tvar polyfill;\n\t\tif( !supportPicture && ( polyfill = (window.picturefill || lazySizesConfig.pf) ) ){\n\t\t\tpolyfill({reevaluate: true, elements: [el]});\n\t\t} else if(full && full.src){\n\t\t\tel.src = full.src;\n\t\t}\n\t};\n\n\tvar getCSS = function (elem, style){\n\t\treturn (getComputedStyle(elem, null) || {})[style];\n\t};\n\n\tvar getWidth = function(elem, parent, width){\n\t\twidth = width || elem.offsetWidth;\n\n\t\twhile(width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth){\n\t\t\twidth =  parent.offsetWidth;\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn width;\n\t};\n\n\tvar rAF = (function(){\n\t\tvar running, waiting;\n\t\tvar firstFns = [];\n\t\tvar secondFns = [];\n\t\tvar fns = firstFns;\n\n\t\tvar run = function(){\n\t\t\tvar runFns = fns;\n\n\t\t\tfns = firstFns.length ? secondFns : firstFns;\n\n\t\t\trunning = true;\n\t\t\twaiting = false;\n\n\t\t\twhile(runFns.length){\n\t\t\t\trunFns.shift()();\n\t\t\t}\n\n\t\t\trunning = false;\n\t\t};\n\n\t\tvar rafBatch = function(fn, queue){\n\t\t\tif(running && !queue){\n\t\t\t\tfn.apply(this, arguments);\n\t\t\t} else {\n\t\t\t\tfns.push(fn);\n\n\t\t\t\tif(!waiting){\n\t\t\t\t\twaiting = true;\n\t\t\t\t\t(document.hidden ? setTimeout : requestAnimationFrame)(run);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trafBatch._lsFlush = run;\n\n\t\treturn rafBatch;\n\t})();\n\n\tvar rAFIt = function(fn, simple){\n\t\treturn simple ?\n\t\t\tfunction() {\n\t\t\t\trAF(fn);\n\t\t\t} :\n\t\t\tfunction(){\n\t\t\t\tvar that = this;\n\t\t\t\tvar args = arguments;\n\t\t\t\trAF(function(){\n\t\t\t\t\tfn.apply(that, args);\n\t\t\t\t});\n\t\t\t}\n\t\t;\n\t};\n\n\tvar throttle = function(fn){\n\t\tvar running;\n\t\tvar lastTime = 0;\n\t\tvar gDelay = lazySizesConfig.throttleDelay;\n\t\tvar rICTimeout = lazySizesConfig.ricTimeout;\n\t\tvar run = function(){\n\t\t\trunning = false;\n\t\t\tlastTime = Date.now();\n\t\t\tfn();\n\t\t};\n\t\tvar idleCallback = requestIdleCallback && rICTimeout > 49 ?\n\t\t\tfunction(){\n\t\t\t\trequestIdleCallback(run, {timeout: rICTimeout});\n\n\t\t\t\tif(rICTimeout !== lazySizesConfig.ricTimeout){\n\t\t\t\t\trICTimeout = lazySizesConfig.ricTimeout;\n\t\t\t\t}\n\t\t\t} :\n\t\t\trAFIt(function(){\n\t\t\t\tsetTimeout(run);\n\t\t\t}, true)\n\t\t;\n\n\t\treturn function(isPriority){\n\t\t\tvar delay;\n\n\t\t\tif((isPriority = isPriority === true)){\n\t\t\t\trICTimeout = 33;\n\t\t\t}\n\n\t\t\tif(running){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trunning =  true;\n\n\t\t\tdelay = gDelay - (Date.now() - lastTime);\n\n\t\t\tif(delay < 0){\n\t\t\t\tdelay = 0;\n\t\t\t}\n\n\t\t\tif(isPriority || delay < 9){\n\t\t\t\tidleCallback();\n\t\t\t} else {\n\t\t\t\tsetTimeout(idleCallback, delay);\n\t\t\t}\n\t\t};\n\t};\n\n\t//based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html\n\tvar debounce = function(func) {\n\t\tvar timeout, timestamp;\n\t\tvar wait = 99;\n\t\tvar run = function(){\n\t\t\ttimeout = null;\n\t\t\tfunc();\n\t\t};\n\t\tvar later = function() {\n\t\t\tvar last = Date.now() - timestamp;\n\n\t\t\tif (last < wait) {\n\t\t\t\tsetTimeout(later, wait - last);\n\t\t\t} else {\n\t\t\t\t(requestIdleCallback || run)(run);\n\t\t\t}\n\t\t};\n\n\t\treturn function() {\n\t\t\ttimestamp = Date.now();\n\n\t\t\tif (!timeout) {\n\t\t\t\ttimeout = setTimeout(later, wait);\n\t\t\t}\n\t\t};\n\t};\n\n\t(function(){\n\t\tvar prop;\n\n\t\tvar lazySizesDefaults = {\n\t\t\tlazyClass: 'lazyload',\n\t\t\tloadedClass: 'lazyloaded',\n\t\t\tloadingClass: 'lazyloading',\n\t\t\tpreloadClass: 'lazypreload',\n\t\t\terrorClass: 'lazyerror',\n\t\t\t//strictClass: 'lazystrict',\n\t\t\tautosizesClass: 'lazyautosizes',\n\t\t\tsrcAttr: 'data-src',\n\t\t\tsrcsetAttr: 'data-srcset',\n\t\t\tsizesAttr: 'data-sizes',\n\t\t\t//preloadAfterLoad: false,\n\t\t\tminSize: 40,\n\t\t\tcustomMedia: {},\n\t\t\tinit: true,\n\t\t\texpFactor: 1.5,\n\t\t\thFac: 0.8,\n\t\t\tloadMode: 2,\n\t\t\tloadHidden: true,\n\t\t\tricTimeout: 0,\n\t\t\tthrottleDelay: 125,\n\t\t};\n\n\t\tlazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};\n\n\t\tfor(prop in lazySizesDefaults){\n\t\t\tif(!(prop in lazySizesConfig)){\n\t\t\t\tlazySizesConfig[prop] = lazySizesDefaults[prop];\n\t\t\t}\n\t\t}\n\n\t\twindow.lazySizesConfig = lazySizesConfig;\n\n\t\tsetTimeout(function(){\n\t\t\tif(lazySizesConfig.init){\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t})();\n\n\tvar loader = (function(){\n\t\tvar preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;\n\n\t\tvar eLvW, elvH, eLtop, eLleft, eLright, eLbottom;\n\n\t\tvar defaultExpand, preloadExpand, hFac;\n\n\t\tvar regImg = /^img$/i;\n\t\tvar regIframe = /^iframe$/i;\n\n\t\tvar supportScroll = ('onscroll' in window) && !(/glebot/.test(navigator.userAgent));\n\n\t\tvar shrinkExpand = 0;\n\t\tvar currentExpand = 0;\n\n\t\tvar isLoading = 0;\n\t\tvar lowRuns = -1;\n\n\t\tvar resetPreloading = function(e){\n\t\t\tisLoading--;\n\t\t\tif(e && e.target){\n\t\t\t\taddRemoveLoadEvents(e.target, resetPreloading);\n\t\t\t}\n\n\t\t\tif(!e || isLoading < 0 || !e.target){\n\t\t\t\tisLoading = 0;\n\t\t\t}\n\t\t};\n\n\t\tvar isNestedVisible = function(elem, elemExpand){\n\t\t\tvar outerRect;\n\t\t\tvar parent = elem;\n\t\t\tvar visible = getCSS(document.body, 'visibility') == 'hidden' || getCSS(elem, 'visibility') != 'hidden';\n\n\t\t\teLtop -= elemExpand;\n\t\t\teLbottom += elemExpand;\n\t\t\teLleft -= elemExpand;\n\t\t\teLright += elemExpand;\n\n\t\t\twhile(visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem){\n\t\t\t\tvisible = ((getCSS(parent, 'opacity') || 1) > 0);\n\n\t\t\t\tif(visible && getCSS(parent, 'overflow') != 'visible'){\n\t\t\t\t\touterRect = parent.getBoundingClientRect();\n\t\t\t\t\tvisible = eLright > outerRect.left &&\n\t\t\t\t\t\teLleft < outerRect.right &&\n\t\t\t\t\t\teLbottom > outerRect.top - 1 &&\n\t\t\t\t\t\teLtop < outerRect.bottom + 1\n\t\t\t\t\t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn visible;\n\t\t};\n\n\t\tvar checkElements = function() {\n\t\t\tvar eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal;\n\n\t\t\tvar lazyloadElems = lazysizes.elements;\n\n\t\t\tif((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)){\n\n\t\t\t\ti = 0;\n\n\t\t\t\tlowRuns++;\n\n\t\t\t\tif(preloadExpand == null){\n\t\t\t\t\tif(!('expand' in lazySizesConfig)){\n\t\t\t\t\t\tlazySizesConfig.expand = docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefaultExpand = lazySizesConfig.expand;\n\t\t\t\t\tpreloadExpand = defaultExpand * lazySizesConfig.expFactor;\n\t\t\t\t}\n\n\t\t\t\tif(currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden){\n\t\t\t\t\tcurrentExpand = preloadExpand;\n\t\t\t\t\tlowRuns = 0;\n\t\t\t\t} else if(loadMode > 1 && lowRuns > 1 && isLoading < 6){\n\t\t\t\t\tcurrentExpand = defaultExpand;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentExpand = shrinkExpand;\n\t\t\t\t}\n\n\t\t\t\tfor(; i < eLlen; i++){\n\n\t\t\t\t\tif(!lazyloadElems[i] || lazyloadElems[i]._lazyRace){continue;}\n\n\t\t\t\t\tif(!supportScroll){unveilElement(lazyloadElems[i]);continue;}\n\n\t\t\t\t\tif(!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)){\n\t\t\t\t\t\telemExpand = currentExpand;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(beforeExpandVal !== elemExpand){\n\t\t\t\t\t\teLvW = innerWidth + (elemExpand * hFac);\n\t\t\t\t\t\telvH = innerHeight + elemExpand;\n\t\t\t\t\t\telemNegativeExpand = elemExpand * -1;\n\t\t\t\t\t\tbeforeExpandVal = elemExpand;\n\t\t\t\t\t}\n\n\t\t\t\t\trect = lazyloadElems[i].getBoundingClientRect();\n\n\t\t\t\t\tif ((eLbottom = rect.bottom) >= elemNegativeExpand &&\n\t\t\t\t\t\t(eLtop = rect.top) <= elvH &&\n\t\t\t\t\t\t(eLright = rect.right) >= elemNegativeExpand * hFac &&\n\t\t\t\t\t\t(eLleft = rect.left) <= eLvW &&\n\t\t\t\t\t\t(eLbottom || eLright || eLleft || eLtop) &&\n\t\t\t\t\t\t(lazySizesConfig.loadHidden || getCSS(lazyloadElems[i], 'visibility') != 'hidden') &&\n\t\t\t\t\t\t((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) || isNestedVisible(lazyloadElems[i], elemExpand))){\n\t\t\t\t\t\tunveilElement(lazyloadElems[i]);\n\t\t\t\t\t\tloadedSomething = true;\n\t\t\t\t\t\tif(isLoading > 9){break;}\n\t\t\t\t\t} else if(!loadedSomething && isCompleted && !autoLoadElem &&\n\t\t\t\t\t\tisLoading < 4 && lowRuns < 4 && loadMode > 2 &&\n\t\t\t\t\t\t(preloadElems[0] || lazySizesConfig.preloadAfterLoad) &&\n\t\t\t\t\t\t(preloadElems[0] || (!elemExpandVal && ((eLbottom || eLright || eLleft || eLtop) || lazyloadElems[i][_getAttribute](lazySizesConfig.sizesAttr) != 'auto')))){\n\t\t\t\t\t\tautoLoadElem = preloadElems[0] || lazyloadElems[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(autoLoadElem && !loadedSomething){\n\t\t\t\t\tunveilElement(autoLoadElem);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar throttledCheckElements = throttle(checkElements);\n\n\t\tvar switchLoadingClass = function(e){\n\t\t\taddClass(e.target, lazySizesConfig.loadedClass);\n\t\t\tremoveClass(e.target, lazySizesConfig.loadingClass);\n\t\t\taddRemoveLoadEvents(e.target, rafSwitchLoadingClass);\n\t\t\ttriggerEvent(e.target, 'lazyloaded');\n\t\t};\n\t\tvar rafedSwitchLoadingClass = rAFIt(switchLoadingClass);\n\t\tvar rafSwitchLoadingClass = function(e){\n\t\t\trafedSwitchLoadingClass({target: e.target});\n\t\t};\n\n\t\tvar changeIframeSrc = function(elem, src){\n\t\t\ttry {\n\t\t\t\telem.contentWindow.location.replace(src);\n\t\t\t} catch(e){\n\t\t\t\telem.src = src;\n\t\t\t}\n\t\t};\n\n\t\tvar handleSources = function(source){\n\t\t\tvar customMedia;\n\n\t\t\tvar sourceSrcset = source[_getAttribute](lazySizesConfig.srcsetAttr);\n\n\t\t\tif( (customMedia = lazySizesConfig.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) ){\n\t\t\t\tsource.setAttribute('media', customMedia);\n\t\t\t}\n\n\t\t\tif(sourceSrcset){\n\t\t\t\tsource.setAttribute('srcset', sourceSrcset);\n\t\t\t}\n\t\t};\n\n\t\tvar lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg){\n\t\t\tvar src, srcset, parent, isPicture, event, firesLoad;\n\n\t\t\tif(!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented){\n\n\t\t\t\tif(sizes){\n\t\t\t\t\tif(isAuto){\n\t\t\t\t\t\taddClass(elem, lazySizesConfig.autosizesClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem.setAttribute('sizes', sizes);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsrcset = elem[_getAttribute](lazySizesConfig.srcsetAttr);\n\t\t\t\tsrc = elem[_getAttribute](lazySizesConfig.srcAttr);\n\n\t\t\t\tif(isImg) {\n\t\t\t\t\tparent = elem.parentNode;\n\t\t\t\t\tisPicture = parent && regPicture.test(parent.nodeName || '');\n\t\t\t\t}\n\n\t\t\t\tfiresLoad = detail.firesLoad || (('src' in elem) && (srcset || src || isPicture));\n\n\t\t\t\tevent = {target: elem};\n\n\t\t\t\tif(firesLoad){\n\t\t\t\t\taddRemoveLoadEvents(elem, resetPreloading, true);\n\t\t\t\t\tclearTimeout(resetPreloadingTimer);\n\t\t\t\t\tresetPreloadingTimer = setTimeout(resetPreloading, 2500);\n\n\t\t\t\t\taddClass(elem, lazySizesConfig.loadingClass);\n\t\t\t\t\taddRemoveLoadEvents(elem, rafSwitchLoadingClass, true);\n\t\t\t\t}\n\n\t\t\t\tif(isPicture){\n\t\t\t\t\tforEach.call(parent.getElementsByTagName('source'), handleSources);\n\t\t\t\t}\n\n\t\t\t\tif(srcset){\n\t\t\t\t\telem.setAttribute('srcset', srcset);\n\t\t\t\t} else if(src && !isPicture){\n\t\t\t\t\tif(regIframe.test(elem.nodeName)){\n\t\t\t\t\t\tchangeIframeSrc(elem, src);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem.src = src;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(isImg && (srcset || isPicture)){\n\t\t\t\t\tupdatePolyfill(elem, {src: src});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(elem._lazyRace){\n\t\t\t\tdelete elem._lazyRace;\n\t\t\t}\n\t\t\tremoveClass(elem, lazySizesConfig.lazyClass);\n\n\t\t\trAF(function(){\n\t\t\t\tif( !firesLoad || (elem.complete && elem.naturalWidth > 1)){\n\t\t\t\t\tif(firesLoad){\n\t\t\t\t\t\tresetPreloading(event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisLoading--;\n\t\t\t\t\t}\n\t\t\t\t\tswitchLoadingClass(event);\n\t\t\t\t}\n\t\t\t}, true);\n\t\t});\n\n\t\tvar unveilElement = function (elem){\n\t\t\tvar detail;\n\n\t\t\tvar isImg = regImg.test(elem.nodeName);\n\n\t\t\t//allow using sizes=\"auto\", but don't use. it's invalid. Use data-sizes=\"auto\" or a valid value for sizes instead (i.e.: sizes=\"80vw\")\n\t\t\tvar sizes = isImg && (elem[_getAttribute](lazySizesConfig.sizesAttr) || elem[_getAttribute]('sizes'));\n\t\t\tvar isAuto = sizes == 'auto';\n\n\t\t\tif( (isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesConfig.errorClass) && hasClass(elem, lazySizesConfig.lazyClass)){return;}\n\n\t\t\tdetail = triggerEvent(elem, 'lazyunveilread').detail;\n\n\t\t\tif(isAuto){\n\t\t\t\t autoSizer.updateElem(elem, true, elem.offsetWidth);\n\t\t\t}\n\n\t\t\telem._lazyRace = true;\n\t\t\tisLoading++;\n\n\t\t\tlazyUnveil(elem, detail, isAuto, sizes, isImg);\n\t\t};\n\n\t\tvar onload = function(){\n\t\t\tif(isCompleted){return;}\n\t\t\tif(Date.now() - started < 999){\n\t\t\t\tsetTimeout(onload, 999);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar afterScroll = debounce(function(){\n\t\t\t\tlazySizesConfig.loadMode = 3;\n\t\t\t\tthrottledCheckElements();\n\t\t\t});\n\n\t\t\tisCompleted = true;\n\n\t\t\tlazySizesConfig.loadMode = 3;\n\n\t\t\tthrottledCheckElements();\n\n\t\t\taddEventListener('scroll', function(){\n\t\t\t\tif(lazySizesConfig.loadMode == 3){\n\t\t\t\t\tlazySizesConfig.loadMode = 2;\n\t\t\t\t}\n\t\t\t\tafterScroll();\n\t\t\t}, true);\n\t\t};\n\n\t\treturn {\n\t\t\t_: function(){\n\t\t\t\tstarted = Date.now();\n\n\t\t\t\tlazysizes.elements = document.getElementsByClassName(lazySizesConfig.lazyClass);\n\t\t\t\tpreloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + ' ' + lazySizesConfig.preloadClass);\n\t\t\t\thFac = lazySizesConfig.hFac;\n\n\t\t\t\taddEventListener('scroll', throttledCheckElements, true);\n\n\t\t\t\taddEventListener('resize', throttledCheckElements, true);\n\n\t\t\t\tif(window.MutationObserver){\n\t\t\t\t\tnew MutationObserver( throttledCheckElements ).observe( docElem, {childList: true, subtree: true, attributes: true} );\n\t\t\t\t} else {\n\t\t\t\t\tdocElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);\n\t\t\t\t\tdocElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);\n\t\t\t\t\tsetInterval(throttledCheckElements, 999);\n\t\t\t\t}\n\n\t\t\t\taddEventListener('hashchange', throttledCheckElements, true);\n\n\t\t\t\t//, 'fullscreenchange'\n\t\t\t\t['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend', 'webkitAnimationEnd'].forEach(function(name){\n\t\t\t\t\tdocument[_addEventListener](name, throttledCheckElements, true);\n\t\t\t\t});\n\n\t\t\t\tif((/d$|^c/.test(document.readyState))){\n\t\t\t\t\tonload();\n\t\t\t\t} else {\n\t\t\t\t\taddEventListener('load', onload);\n\t\t\t\t\tdocument[_addEventListener]('DOMContentLoaded', throttledCheckElements);\n\t\t\t\t\tsetTimeout(onload, 20000);\n\t\t\t\t}\n\n\t\t\t\tif(lazysizes.elements.length){\n\t\t\t\t\tcheckElements();\n\t\t\t\t\trAF._lsFlush();\n\t\t\t\t} else {\n\t\t\t\t\tthrottledCheckElements();\n\t\t\t\t}\n\t\t\t},\n\t\t\tcheckElems: throttledCheckElements,\n\t\t\tunveil: unveilElement\n\t\t};\n\t})();\n\n\n\tvar autoSizer = (function(){\n\t\tvar autosizesElems;\n\n\t\tvar sizeElement = rAFIt(function(elem, parent, event, width){\n\t\t\tvar sources, i, len;\n\t\t\telem._lazysizesWidth = width;\n\t\t\twidth += 'px';\n\n\t\t\telem.setAttribute('sizes', width);\n\n\t\t\tif(regPicture.test(parent.nodeName || '')){\n\t\t\t\tsources = parent.getElementsByTagName('source');\n\t\t\t\tfor(i = 0, len = sources.length; i < len; i++){\n\t\t\t\t\tsources[i].setAttribute('sizes', width);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!event.detail.dataAttr){\n\t\t\t\tupdatePolyfill(elem, event.detail);\n\t\t\t}\n\t\t});\n\t\tvar getSizeElement = function (elem, dataAttr, width){\n\t\t\tvar event;\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif(parent){\n\t\t\t\twidth = getWidth(elem, parent, width);\n\t\t\t\tevent = triggerEvent(elem, 'lazybeforesizes', {width: width, dataAttr: !!dataAttr});\n\n\t\t\t\tif(!event.defaultPrevented){\n\t\t\t\t\twidth = event.detail.width;\n\n\t\t\t\t\tif(width && width !== elem._lazysizesWidth){\n\t\t\t\t\t\tsizeElement(elem, parent, event, width);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar updateElementsSizes = function(){\n\t\t\tvar i;\n\t\t\tvar len = autosizesElems.length;\n\t\t\tif(len){\n\t\t\t\ti = 0;\n\n\t\t\t\tfor(; i < len; i++){\n\t\t\t\t\tgetSizeElement(autosizesElems[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar debouncedUpdateElementsSizes = debounce(updateElementsSizes);\n\n\t\treturn {\n\t\t\t_: function(){\n\t\t\t\tautosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass);\n\t\t\t\taddEventListener('resize', debouncedUpdateElementsSizes);\n\t\t\t},\n\t\t\tcheckElems: debouncedUpdateElementsSizes,\n\t\t\tupdateElem: getSizeElement\n\t\t};\n\t})();\n\n\tvar init = function(){\n\t\tif(!init.i){\n\t\t\tinit.i = true;\n\t\t\tautoSizer._();\n\t\t\tloader._();\n\t\t}\n\t};\n\n\tlazysizes = {\n\t\tcfg: lazySizesConfig,\n\t\tautoSizer: autoSizer,\n\t\tloader: loader,\n\t\tinit: init,\n\t\tuP: updatePolyfill,\n\t\taC: addClass,\n\t\trC: removeClass,\n\t\thC: hasClass,\n\t\tfire: triggerEvent,\n\t\tgW: getWidth,\n\t\trAF: rAF,\n\t};\n\n\treturn lazysizes;\n}\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGF6eXNpemVzL2xhenlzaXplcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXp5c2l6ZXMvbGF6eXNpemVzLmpzP2IzZTkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHdpbmRvdywgZmFjdG9yeSkge1xuXHR2YXIgbGF6eVNpemVzID0gZmFjdG9yeSh3aW5kb3csIHdpbmRvdy5kb2N1bWVudCk7XG5cdHdpbmRvdy5sYXp5U2l6ZXMgPSBsYXp5U2l6ZXM7XG5cdGlmKHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuXHRcdG1vZHVsZS5leHBvcnRzID0gbGF6eVNpemVzO1xuXHR9XG59KHdpbmRvdywgZnVuY3Rpb24gbCh3aW5kb3csIGRvY3VtZW50KSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0Lypqc2hpbnQgZXFudWxsOnRydWUgKi9cblx0aWYoIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpe3JldHVybjt9XG5cblx0dmFyIGxhenlzaXplcywgbGF6eVNpemVzQ29uZmlnO1xuXG5cdHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdHZhciBEYXRlID0gd2luZG93LkRhdGU7XG5cblx0dmFyIHN1cHBvcnRQaWN0dXJlID0gd2luZG93LkhUTUxQaWN0dXJlRWxlbWVudDtcblxuXHR2YXIgX2FkZEV2ZW50TGlzdGVuZXIgPSAnYWRkRXZlbnRMaXN0ZW5lcic7XG5cblx0dmFyIF9nZXRBdHRyaWJ1dGUgPSAnZ2V0QXR0cmlidXRlJztcblxuXHR2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvd1tfYWRkRXZlbnRMaXN0ZW5lcl07XG5cblx0dmFyIHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblxuXHR2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuXG5cdHZhciByZXF1ZXN0SWRsZUNhbGxiYWNrID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2s7XG5cblx0dmFyIHJlZ1BpY3R1cmUgPSAvXnBpY3R1cmUkL2k7XG5cblx0dmFyIGxvYWRFdmVudHMgPSBbJ2xvYWQnLCAnZXJyb3InLCAnbGF6eWluY2x1ZGVkJywgJ19sYXp5bG9hZGVkJ107XG5cblx0dmFyIHJlZ0NsYXNzQ2FjaGUgPSB7fTtcblxuXHR2YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuXG5cdHZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uKGVsZSwgY2xzKSB7XG5cdFx0aWYoIXJlZ0NsYXNzQ2FjaGVbY2xzXSl7XG5cdFx0XHRyZWdDbGFzc0NhY2hlW2Nsc10gPSBuZXcgUmVnRXhwKCcoXFxcXHN8XiknK2NscysnKFxcXFxzfCQpJyk7XG5cdFx0fVxuXHRcdHJldHVybiByZWdDbGFzc0NhY2hlW2Nsc10udGVzdChlbGVbX2dldEF0dHJpYnV0ZV0oJ2NsYXNzJykgfHwgJycpICYmIHJlZ0NsYXNzQ2FjaGVbY2xzXTtcblx0fTtcblxuXHR2YXIgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbGUsIGNscykge1xuXHRcdGlmICghaGFzQ2xhc3MoZWxlLCBjbHMpKXtcblx0XHRcdGVsZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGVsZVtfZ2V0QXR0cmlidXRlXSgnY2xhc3MnKSB8fCAnJykudHJpbSgpICsgJyAnICsgY2xzKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWxlLCBjbHMpIHtcblx0XHR2YXIgcmVnO1xuXHRcdGlmICgocmVnID0gaGFzQ2xhc3MoZWxlLGNscykpKSB7XG5cdFx0XHRlbGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVbX2dldEF0dHJpYnV0ZV0oJ2NsYXNzJykgfHwgJycpLnJlcGxhY2UocmVnLCAnICcpKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGFkZFJlbW92ZUxvYWRFdmVudHMgPSBmdW5jdGlvbihkb20sIGZuLCBhZGQpe1xuXHRcdHZhciBhY3Rpb24gPSBhZGQgPyBfYWRkRXZlbnRMaXN0ZW5lciA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblx0XHRpZihhZGQpe1xuXHRcdFx0YWRkUmVtb3ZlTG9hZEV2ZW50cyhkb20sIGZuKTtcblx0XHR9XG5cdFx0bG9hZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2dCl7XG5cdFx0XHRkb21bYWN0aW9uXShldnQsIGZuKTtcblx0XHR9KTtcblx0fTtcblxuXHR2YXIgdHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24oZWxlbSwgbmFtZSwgZGV0YWlsLCBub0J1YmJsZXMsIG5vQ2FuY2VsYWJsZSl7XG5cdFx0dmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cblx0XHRpZighZGV0YWlsKXtcblx0XHRcdGRldGFpbCA9IHt9O1xuXHRcdH1cblxuXHRcdGRldGFpbC5pbnN0YW5jZSA9IGxhenlzaXplcztcblxuXHRcdGV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLCAhbm9CdWJibGVzLCAhbm9DYW5jZWxhYmxlLCBkZXRhaWwpO1xuXG5cdFx0ZWxlbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRyZXR1cm4gZXZlbnQ7XG5cdH07XG5cblx0dmFyIHVwZGF0ZVBvbHlmaWxsID0gZnVuY3Rpb24gKGVsLCBmdWxsKXtcblx0XHR2YXIgcG9seWZpbGw7XG5cdFx0aWYoICFzdXBwb3J0UGljdHVyZSAmJiAoIHBvbHlmaWxsID0gKHdpbmRvdy5waWN0dXJlZmlsbCB8fCBsYXp5U2l6ZXNDb25maWcucGYpICkgKXtcblx0XHRcdHBvbHlmaWxsKHtyZWV2YWx1YXRlOiB0cnVlLCBlbGVtZW50czogW2VsXX0pO1xuXHRcdH0gZWxzZSBpZihmdWxsICYmIGZ1bGwuc3JjKXtcblx0XHRcdGVsLnNyYyA9IGZ1bGwuc3JjO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgZ2V0Q1NTID0gZnVuY3Rpb24gKGVsZW0sIHN0eWxlKXtcblx0XHRyZXR1cm4gKGdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCkgfHwge30pW3N0eWxlXTtcblx0fTtcblxuXHR2YXIgZ2V0V2lkdGggPSBmdW5jdGlvbihlbGVtLCBwYXJlbnQsIHdpZHRoKXtcblx0XHR3aWR0aCA9IHdpZHRoIHx8IGVsZW0ub2Zmc2V0V2lkdGg7XG5cblx0XHR3aGlsZSh3aWR0aCA8IGxhenlTaXplc0NvbmZpZy5taW5TaXplICYmIHBhcmVudCAmJiAhZWxlbS5fbGF6eXNpemVzV2lkdGgpe1xuXHRcdFx0d2lkdGggPSAgcGFyZW50Lm9mZnNldFdpZHRoO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpZHRoO1xuXHR9O1xuXG5cdHZhciByQUYgPSAoZnVuY3Rpb24oKXtcblx0XHR2YXIgcnVubmluZywgd2FpdGluZztcblx0XHR2YXIgZmlyc3RGbnMgPSBbXTtcblx0XHR2YXIgc2Vjb25kRm5zID0gW107XG5cdFx0dmFyIGZucyA9IGZpcnN0Rm5zO1xuXG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcnVuRm5zID0gZm5zO1xuXG5cdFx0XHRmbnMgPSBmaXJzdEZucy5sZW5ndGggPyBzZWNvbmRGbnMgOiBmaXJzdEZucztcblxuXHRcdFx0cnVubmluZyA9IHRydWU7XG5cdFx0XHR3YWl0aW5nID0gZmFsc2U7XG5cblx0XHRcdHdoaWxlKHJ1bkZucy5sZW5ndGgpe1xuXHRcdFx0XHRydW5GbnMuc2hpZnQoKSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHZhciByYWZCYXRjaCA9IGZ1bmN0aW9uKGZuLCBxdWV1ZSl7XG5cdFx0XHRpZihydW5uaW5nICYmICFxdWV1ZSl7XG5cdFx0XHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmbnMucHVzaChmbik7XG5cblx0XHRcdFx0aWYoIXdhaXRpbmcpe1xuXHRcdFx0XHRcdHdhaXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdChkb2N1bWVudC5oaWRkZW4gPyBzZXRUaW1lb3V0IDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKShydW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJhZkJhdGNoLl9sc0ZsdXNoID0gcnVuO1xuXG5cdFx0cmV0dXJuIHJhZkJhdGNoO1xuXHR9KSgpO1xuXG5cdHZhciByQUZJdCA9IGZ1bmN0aW9uKGZuLCBzaW1wbGUpe1xuXHRcdHJldHVybiBzaW1wbGUgP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJBRihmbik7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdHJBRihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHQ7XG5cdH07XG5cblx0dmFyIHRocm90dGxlID0gZnVuY3Rpb24oZm4pe1xuXHRcdHZhciBydW5uaW5nO1xuXHRcdHZhciBsYXN0VGltZSA9IDA7XG5cdFx0dmFyIGdEZWxheSA9IGxhenlTaXplc0NvbmZpZy50aHJvdHRsZURlbGF5O1xuXHRcdHZhciBySUNUaW1lb3V0ID0gbGF6eVNpemVzQ29uZmlnLnJpY1RpbWVvdXQ7XG5cdFx0dmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRsYXN0VGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRmbigpO1xuXHRcdH07XG5cdFx0dmFyIGlkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgcklDVGltZW91dCA+IDQ5ID9cblx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlcXVlc3RJZGxlQ2FsbGJhY2socnVuLCB7dGltZW91dDogcklDVGltZW91dH0pO1xuXG5cdFx0XHRcdGlmKHJJQ1RpbWVvdXQgIT09IGxhenlTaXplc0NvbmZpZy5yaWNUaW1lb3V0KXtcblx0XHRcdFx0XHRySUNUaW1lb3V0ID0gbGF6eVNpemVzQ29uZmlnLnJpY1RpbWVvdXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gOlxuXHRcdFx0ckFGSXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0c2V0VGltZW91dChydW4pO1xuXHRcdFx0fSwgdHJ1ZSlcblx0XHQ7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oaXNQcmlvcml0eSl7XG5cdFx0XHR2YXIgZGVsYXk7XG5cblx0XHRcdGlmKChpc1ByaW9yaXR5ID0gaXNQcmlvcml0eSA9PT0gdHJ1ZSkpe1xuXHRcdFx0XHRySUNUaW1lb3V0ID0gMzM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHJ1bm5pbmcpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJ1bm5pbmcgPSAgdHJ1ZTtcblxuXHRcdFx0ZGVsYXkgPSBnRGVsYXkgLSAoRGF0ZS5ub3coKSAtIGxhc3RUaW1lKTtcblxuXHRcdFx0aWYoZGVsYXkgPCAwKXtcblx0XHRcdFx0ZGVsYXkgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihpc1ByaW9yaXR5IHx8IGRlbGF5IDwgOSl7XG5cdFx0XHRcdGlkbGVDYWxsYmFjaygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0VGltZW91dChpZGxlQ2FsbGJhY2ssIGRlbGF5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdC8vYmFzZWQgb24gaHR0cDovL21vZGVybmphdmFzY3JpcHQuYmxvZ3Nwb3QuZGUvMjAxMy8wOC9idWlsZGluZy1iZXR0ZXItZGVib3VuY2UuaHRtbFxuXHR2YXIgZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0dmFyIHRpbWVvdXQsIHRpbWVzdGFtcDtcblx0XHR2YXIgd2FpdCA9IDk5O1xuXHRcdHZhciBydW4gPSBmdW5jdGlvbigpe1xuXHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRmdW5jKCk7XG5cdFx0fTtcblx0XHR2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuXHRcdFx0aWYgKGxhc3QgPCB3YWl0KSB7XG5cdFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdChyZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IHJ1bikocnVuKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0aWYgKCF0aW1lb3V0KSB7XG5cdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdChmdW5jdGlvbigpe1xuXHRcdHZhciBwcm9wO1xuXG5cdFx0dmFyIGxhenlTaXplc0RlZmF1bHRzID0ge1xuXHRcdFx0bGF6eUNsYXNzOiAnbGF6eWxvYWQnLFxuXHRcdFx0bG9hZGVkQ2xhc3M6ICdsYXp5bG9hZGVkJyxcblx0XHRcdGxvYWRpbmdDbGFzczogJ2xhenlsb2FkaW5nJyxcblx0XHRcdHByZWxvYWRDbGFzczogJ2xhenlwcmVsb2FkJyxcblx0XHRcdGVycm9yQ2xhc3M6ICdsYXp5ZXJyb3InLFxuXHRcdFx0Ly9zdHJpY3RDbGFzczogJ2xhenlzdHJpY3QnLFxuXHRcdFx0YXV0b3NpemVzQ2xhc3M6ICdsYXp5YXV0b3NpemVzJyxcblx0XHRcdHNyY0F0dHI6ICdkYXRhLXNyYycsXG5cdFx0XHRzcmNzZXRBdHRyOiAnZGF0YS1zcmNzZXQnLFxuXHRcdFx0c2l6ZXNBdHRyOiAnZGF0YS1zaXplcycsXG5cdFx0XHQvL3ByZWxvYWRBZnRlckxvYWQ6IGZhbHNlLFxuXHRcdFx0bWluU2l6ZTogNDAsXG5cdFx0XHRjdXN0b21NZWRpYToge30sXG5cdFx0XHRpbml0OiB0cnVlLFxuXHRcdFx0ZXhwRmFjdG9yOiAxLjUsXG5cdFx0XHRoRmFjOiAwLjgsXG5cdFx0XHRsb2FkTW9kZTogMixcblx0XHRcdGxvYWRIaWRkZW46IHRydWUsXG5cdFx0XHRyaWNUaW1lb3V0OiAwLFxuXHRcdFx0dGhyb3R0bGVEZWxheTogMTI1LFxuXHRcdH07XG5cblx0XHRsYXp5U2l6ZXNDb25maWcgPSB3aW5kb3cubGF6eVNpemVzQ29uZmlnIHx8IHdpbmRvdy5sYXp5c2l6ZXNDb25maWcgfHwge307XG5cblx0XHRmb3IocHJvcCBpbiBsYXp5U2l6ZXNEZWZhdWx0cyl7XG5cdFx0XHRpZighKHByb3AgaW4gbGF6eVNpemVzQ29uZmlnKSl7XG5cdFx0XHRcdGxhenlTaXplc0NvbmZpZ1twcm9wXSA9IGxhenlTaXplc0RlZmF1bHRzW3Byb3BdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdpbmRvdy5sYXp5U2l6ZXNDb25maWcgPSBsYXp5U2l6ZXNDb25maWc7XG5cblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRpZihsYXp5U2l6ZXNDb25maWcuaW5pdCl7XG5cdFx0XHRcdGluaXQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSkoKTtcblxuXHR2YXIgbG9hZGVyID0gKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHByZWxvYWRFbGVtcywgaXNDb21wbGV0ZWQsIHJlc2V0UHJlbG9hZGluZ1RpbWVyLCBsb2FkTW9kZSwgc3RhcnRlZDtcblxuXHRcdHZhciBlTHZXLCBlbHZILCBlTHRvcCwgZUxsZWZ0LCBlTHJpZ2h0LCBlTGJvdHRvbTtcblxuXHRcdHZhciBkZWZhdWx0RXhwYW5kLCBwcmVsb2FkRXhwYW5kLCBoRmFjO1xuXG5cdFx0dmFyIHJlZ0ltZyA9IC9eaW1nJC9pO1xuXHRcdHZhciByZWdJZnJhbWUgPSAvXmlmcmFtZSQvaTtcblxuXHRcdHZhciBzdXBwb3J0U2Nyb2xsID0gKCdvbnNjcm9sbCcgaW4gd2luZG93KSAmJiAhKC9nbGVib3QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xuXG5cdFx0dmFyIHNocmlua0V4cGFuZCA9IDA7XG5cdFx0dmFyIGN1cnJlbnRFeHBhbmQgPSAwO1xuXG5cdFx0dmFyIGlzTG9hZGluZyA9IDA7XG5cdFx0dmFyIGxvd1J1bnMgPSAtMTtcblxuXHRcdHZhciByZXNldFByZWxvYWRpbmcgPSBmdW5jdGlvbihlKXtcblx0XHRcdGlzTG9hZGluZy0tO1xuXHRcdFx0aWYoZSAmJiBlLnRhcmdldCl7XG5cdFx0XHRcdGFkZFJlbW92ZUxvYWRFdmVudHMoZS50YXJnZXQsIHJlc2V0UHJlbG9hZGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFlIHx8IGlzTG9hZGluZyA8IDAgfHwgIWUudGFyZ2V0KXtcblx0XHRcdFx0aXNMb2FkaW5nID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGlzTmVzdGVkVmlzaWJsZSA9IGZ1bmN0aW9uKGVsZW0sIGVsZW1FeHBhbmQpe1xuXHRcdFx0dmFyIG91dGVyUmVjdDtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtO1xuXHRcdFx0dmFyIHZpc2libGUgPSBnZXRDU1MoZG9jdW1lbnQuYm9keSwgJ3Zpc2liaWxpdHknKSA9PSAnaGlkZGVuJyB8fCBnZXRDU1MoZWxlbSwgJ3Zpc2liaWxpdHknKSAhPSAnaGlkZGVuJztcblxuXHRcdFx0ZUx0b3AgLT0gZWxlbUV4cGFuZDtcblx0XHRcdGVMYm90dG9tICs9IGVsZW1FeHBhbmQ7XG5cdFx0XHRlTGxlZnQgLT0gZWxlbUV4cGFuZDtcblx0XHRcdGVMcmlnaHQgKz0gZWxlbUV4cGFuZDtcblxuXHRcdFx0d2hpbGUodmlzaWJsZSAmJiAocGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudCkgJiYgcGFyZW50ICE9IGRvY3VtZW50LmJvZHkgJiYgcGFyZW50ICE9IGRvY0VsZW0pe1xuXHRcdFx0XHR2aXNpYmxlID0gKChnZXRDU1MocGFyZW50LCAnb3BhY2l0eScpIHx8IDEpID4gMCk7XG5cblx0XHRcdFx0aWYodmlzaWJsZSAmJiBnZXRDU1MocGFyZW50LCAnb3ZlcmZsb3cnKSAhPSAndmlzaWJsZScpe1xuXHRcdFx0XHRcdG91dGVyUmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHR2aXNpYmxlID0gZUxyaWdodCA+IG91dGVyUmVjdC5sZWZ0ICYmXG5cdFx0XHRcdFx0XHRlTGxlZnQgPCBvdXRlclJlY3QucmlnaHQgJiZcblx0XHRcdFx0XHRcdGVMYm90dG9tID4gb3V0ZXJSZWN0LnRvcCAtIDEgJiZcblx0XHRcdFx0XHRcdGVMdG9wIDwgb3V0ZXJSZWN0LmJvdHRvbSArIDFcblx0XHRcdFx0XHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZpc2libGU7XG5cdFx0fTtcblxuXHRcdHZhciBjaGVja0VsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZUxsZW4sIGksIHJlY3QsIGF1dG9Mb2FkRWxlbSwgbG9hZGVkU29tZXRoaW5nLCBlbGVtRXhwYW5kLCBlbGVtTmVnYXRpdmVFeHBhbmQsIGVsZW1FeHBhbmRWYWwsIGJlZm9yZUV4cGFuZFZhbDtcblxuXHRcdFx0dmFyIGxhenlsb2FkRWxlbXMgPSBsYXp5c2l6ZXMuZWxlbWVudHM7XG5cblx0XHRcdGlmKChsb2FkTW9kZSA9IGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSkgJiYgaXNMb2FkaW5nIDwgOCAmJiAoZUxsZW4gPSBsYXp5bG9hZEVsZW1zLmxlbmd0aCkpe1xuXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdGxvd1J1bnMrKztcblxuXHRcdFx0XHRpZihwcmVsb2FkRXhwYW5kID09IG51bGwpe1xuXHRcdFx0XHRcdGlmKCEoJ2V4cGFuZCcgaW4gbGF6eVNpemVzQ29uZmlnKSl7XG5cdFx0XHRcdFx0XHRsYXp5U2l6ZXNDb25maWcuZXhwYW5kID0gZG9jRWxlbS5jbGllbnRIZWlnaHQgPiA1MDAgJiYgZG9jRWxlbS5jbGllbnRXaWR0aCA+IDUwMCA/IDUwMCA6IDM3MDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWZhdWx0RXhwYW5kID0gbGF6eVNpemVzQ29uZmlnLmV4cGFuZDtcblx0XHRcdFx0XHRwcmVsb2FkRXhwYW5kID0gZGVmYXVsdEV4cGFuZCAqIGxhenlTaXplc0NvbmZpZy5leHBGYWN0b3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihjdXJyZW50RXhwYW5kIDwgcHJlbG9hZEV4cGFuZCAmJiBpc0xvYWRpbmcgPCAxICYmIGxvd1J1bnMgPiAyICYmIGxvYWRNb2RlID4gMiAmJiAhZG9jdW1lbnQuaGlkZGVuKXtcblx0XHRcdFx0XHRjdXJyZW50RXhwYW5kID0gcHJlbG9hZEV4cGFuZDtcblx0XHRcdFx0XHRsb3dSdW5zID0gMDtcblx0XHRcdFx0fSBlbHNlIGlmKGxvYWRNb2RlID4gMSAmJiBsb3dSdW5zID4gMSAmJiBpc0xvYWRpbmcgPCA2KXtcblx0XHRcdFx0XHRjdXJyZW50RXhwYW5kID0gZGVmYXVsdEV4cGFuZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJyZW50RXhwYW5kID0gc2hyaW5rRXhwYW5kO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yKDsgaSA8IGVMbGVuOyBpKyspe1xuXG5cdFx0XHRcdFx0aWYoIWxhenlsb2FkRWxlbXNbaV0gfHwgbGF6eWxvYWRFbGVtc1tpXS5fbGF6eVJhY2Upe2NvbnRpbnVlO31cblxuXHRcdFx0XHRcdGlmKCFzdXBwb3J0U2Nyb2xsKXt1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO2NvbnRpbnVlO31cblxuXHRcdFx0XHRcdGlmKCEoZWxlbUV4cGFuZFZhbCA9IGxhenlsb2FkRWxlbXNbaV1bX2dldEF0dHJpYnV0ZV0oJ2RhdGEtZXhwYW5kJykpIHx8ICEoZWxlbUV4cGFuZCA9IGVsZW1FeHBhbmRWYWwgKiAxKSl7XG5cdFx0XHRcdFx0XHRlbGVtRXhwYW5kID0gY3VycmVudEV4cGFuZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihiZWZvcmVFeHBhbmRWYWwgIT09IGVsZW1FeHBhbmQpe1xuXHRcdFx0XHRcdFx0ZUx2VyA9IGlubmVyV2lkdGggKyAoZWxlbUV4cGFuZCAqIGhGYWMpO1xuXHRcdFx0XHRcdFx0ZWx2SCA9IGlubmVySGVpZ2h0ICsgZWxlbUV4cGFuZDtcblx0XHRcdFx0XHRcdGVsZW1OZWdhdGl2ZUV4cGFuZCA9IGVsZW1FeHBhbmQgKiAtMTtcblx0XHRcdFx0XHRcdGJlZm9yZUV4cGFuZFZhbCA9IGVsZW1FeHBhbmQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVjdCA9IGxhenlsb2FkRWxlbXNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRpZiAoKGVMYm90dG9tID0gcmVjdC5ib3R0b20pID49IGVsZW1OZWdhdGl2ZUV4cGFuZCAmJlxuXHRcdFx0XHRcdFx0KGVMdG9wID0gcmVjdC50b3ApIDw9IGVsdkggJiZcblx0XHRcdFx0XHRcdChlTHJpZ2h0ID0gcmVjdC5yaWdodCkgPj0gZWxlbU5lZ2F0aXZlRXhwYW5kICogaEZhYyAmJlxuXHRcdFx0XHRcdFx0KGVMbGVmdCA9IHJlY3QubGVmdCkgPD0gZUx2VyAmJlxuXHRcdFx0XHRcdFx0KGVMYm90dG9tIHx8IGVMcmlnaHQgfHwgZUxsZWZ0IHx8IGVMdG9wKSAmJlxuXHRcdFx0XHRcdFx0KGxhenlTaXplc0NvbmZpZy5sb2FkSGlkZGVuIHx8IGdldENTUyhsYXp5bG9hZEVsZW1zW2ldLCAndmlzaWJpbGl0eScpICE9ICdoaWRkZW4nKSAmJlxuXHRcdFx0XHRcdFx0KChpc0NvbXBsZXRlZCAmJiBpc0xvYWRpbmcgPCAzICYmICFlbGVtRXhwYW5kVmFsICYmIChsb2FkTW9kZSA8IDMgfHwgbG93UnVucyA8IDQpKSB8fCBpc05lc3RlZFZpc2libGUobGF6eWxvYWRFbGVtc1tpXSwgZWxlbUV4cGFuZCkpKXtcblx0XHRcdFx0XHRcdHVudmVpbEVsZW1lbnQobGF6eWxvYWRFbGVtc1tpXSk7XG5cdFx0XHRcdFx0XHRsb2FkZWRTb21ldGhpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYoaXNMb2FkaW5nID4gOSl7YnJlYWs7fVxuXHRcdFx0XHRcdH0gZWxzZSBpZighbG9hZGVkU29tZXRoaW5nICYmIGlzQ29tcGxldGVkICYmICFhdXRvTG9hZEVsZW0gJiZcblx0XHRcdFx0XHRcdGlzTG9hZGluZyA8IDQgJiYgbG93UnVucyA8IDQgJiYgbG9hZE1vZGUgPiAyICYmXG5cdFx0XHRcdFx0XHQocHJlbG9hZEVsZW1zWzBdIHx8IGxhenlTaXplc0NvbmZpZy5wcmVsb2FkQWZ0ZXJMb2FkKSAmJlxuXHRcdFx0XHRcdFx0KHByZWxvYWRFbGVtc1swXSB8fCAoIWVsZW1FeHBhbmRWYWwgJiYgKChlTGJvdHRvbSB8fCBlTHJpZ2h0IHx8IGVMbGVmdCB8fCBlTHRvcCkgfHwgbGF6eWxvYWRFbGVtc1tpXVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyKSAhPSAnYXV0bycpKSkpe1xuXHRcdFx0XHRcdFx0YXV0b0xvYWRFbGVtID0gcHJlbG9hZEVsZW1zWzBdIHx8IGxhenlsb2FkRWxlbXNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoYXV0b0xvYWRFbGVtICYmICFsb2FkZWRTb21ldGhpbmcpe1xuXHRcdFx0XHRcdHVudmVpbEVsZW1lbnQoYXV0b0xvYWRFbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cyA9IHRocm90dGxlKGNoZWNrRWxlbWVudHMpO1xuXG5cdFx0dmFyIHN3aXRjaExvYWRpbmdDbGFzcyA9IGZ1bmN0aW9uKGUpe1xuXHRcdFx0YWRkQ2xhc3MoZS50YXJnZXQsIGxhenlTaXplc0NvbmZpZy5sb2FkZWRDbGFzcyk7XG5cdFx0XHRyZW1vdmVDbGFzcyhlLnRhcmdldCwgbGF6eVNpemVzQ29uZmlnLmxvYWRpbmdDbGFzcyk7XG5cdFx0XHRhZGRSZW1vdmVMb2FkRXZlbnRzKGUudGFyZ2V0LCByYWZTd2l0Y2hMb2FkaW5nQ2xhc3MpO1xuXHRcdFx0dHJpZ2dlckV2ZW50KGUudGFyZ2V0LCAnbGF6eWxvYWRlZCcpO1xuXHRcdH07XG5cdFx0dmFyIHJhZmVkU3dpdGNoTG9hZGluZ0NsYXNzID0gckFGSXQoc3dpdGNoTG9hZGluZ0NsYXNzKTtcblx0XHR2YXIgcmFmU3dpdGNoTG9hZGluZ0NsYXNzID0gZnVuY3Rpb24oZSl7XG5cdFx0XHRyYWZlZFN3aXRjaExvYWRpbmdDbGFzcyh7dGFyZ2V0OiBlLnRhcmdldH0pO1xuXHRcdH07XG5cblx0XHR2YXIgY2hhbmdlSWZyYW1lU3JjID0gZnVuY3Rpb24oZWxlbSwgc3JjKXtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGVsZW0uY29udGVudFdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHNyYyk7XG5cdFx0XHR9IGNhdGNoKGUpe1xuXHRcdFx0XHRlbGVtLnNyYyA9IHNyYztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGhhbmRsZVNvdXJjZXMgPSBmdW5jdGlvbihzb3VyY2Upe1xuXHRcdFx0dmFyIGN1c3RvbU1lZGlhO1xuXG5cdFx0XHR2YXIgc291cmNlU3Jjc2V0ID0gc291cmNlW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zcmNzZXRBdHRyKTtcblxuXHRcdFx0aWYoIChjdXN0b21NZWRpYSA9IGxhenlTaXplc0NvbmZpZy5jdXN0b21NZWRpYVtzb3VyY2VbX2dldEF0dHJpYnV0ZV0oJ2RhdGEtbWVkaWEnKSB8fCBzb3VyY2VbX2dldEF0dHJpYnV0ZV0oJ21lZGlhJyldKSApe1xuXHRcdFx0XHRzb3VyY2Uuc2V0QXR0cmlidXRlKCdtZWRpYScsIGN1c3RvbU1lZGlhKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoc291cmNlU3Jjc2V0KXtcblx0XHRcdFx0c291cmNlLnNldEF0dHJpYnV0ZSgnc3Jjc2V0Jywgc291cmNlU3Jjc2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGxhenlVbnZlaWwgPSByQUZJdChmdW5jdGlvbiAoZWxlbSwgZGV0YWlsLCBpc0F1dG8sIHNpemVzLCBpc0ltZyl7XG5cdFx0XHR2YXIgc3JjLCBzcmNzZXQsIHBhcmVudCwgaXNQaWN0dXJlLCBldmVudCwgZmlyZXNMb2FkO1xuXG5cdFx0XHRpZighKGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5YmVmb3JldW52ZWlsJywgZGV0YWlsKSkuZGVmYXVsdFByZXZlbnRlZCl7XG5cblx0XHRcdFx0aWYoc2l6ZXMpe1xuXHRcdFx0XHRcdGlmKGlzQXV0byl7XG5cdFx0XHRcdFx0XHRhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcuYXV0b3NpemVzQ2xhc3MpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSgnc2l6ZXMnLCBzaXplcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3Jjc2V0ID0gZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc3Jjc2V0QXR0cik7XG5cdFx0XHRcdHNyYyA9IGVsZW1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNyY0F0dHIpO1xuXG5cdFx0XHRcdGlmKGlzSW1nKSB7XG5cdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlzUGljdHVyZSA9IHBhcmVudCAmJiByZWdQaWN0dXJlLnRlc3QocGFyZW50Lm5vZGVOYW1lIHx8ICcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpcmVzTG9hZCA9IGRldGFpbC5maXJlc0xvYWQgfHwgKCgnc3JjJyBpbiBlbGVtKSAmJiAoc3Jjc2V0IHx8IHNyYyB8fCBpc1BpY3R1cmUpKTtcblxuXHRcdFx0XHRldmVudCA9IHt0YXJnZXQ6IGVsZW19O1xuXG5cdFx0XHRcdGlmKGZpcmVzTG9hZCl7XG5cdFx0XHRcdFx0YWRkUmVtb3ZlTG9hZEV2ZW50cyhlbGVtLCByZXNldFByZWxvYWRpbmcsIHRydWUpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChyZXNldFByZWxvYWRpbmdUaW1lcik7XG5cdFx0XHRcdFx0cmVzZXRQcmVsb2FkaW5nVGltZXIgPSBzZXRUaW1lb3V0KHJlc2V0UHJlbG9hZGluZywgMjUwMCk7XG5cblx0XHRcdFx0XHRhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubG9hZGluZ0NsYXNzKTtcblx0XHRcdFx0XHRhZGRSZW1vdmVMb2FkRXZlbnRzKGVsZW0sIHJhZlN3aXRjaExvYWRpbmdDbGFzcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihpc1BpY3R1cmUpe1xuXHRcdFx0XHRcdGZvckVhY2guY2FsbChwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpLCBoYW5kbGVTb3VyY2VzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHNyY3NldCl7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoJ3NyY3NldCcsIHNyY3NldCk7XG5cdFx0XHRcdH0gZWxzZSBpZihzcmMgJiYgIWlzUGljdHVyZSl7XG5cdFx0XHRcdFx0aWYocmVnSWZyYW1lLnRlc3QoZWxlbS5ub2RlTmFtZSkpe1xuXHRcdFx0XHRcdFx0Y2hhbmdlSWZyYW1lU3JjKGVsZW0sIHNyYyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW0uc3JjID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGlzSW1nICYmIChzcmNzZXQgfHwgaXNQaWN0dXJlKSl7XG5cdFx0XHRcdFx0dXBkYXRlUG9seWZpbGwoZWxlbSwge3NyYzogc3JjfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoZWxlbS5fbGF6eVJhY2Upe1xuXHRcdFx0XHRkZWxldGUgZWxlbS5fbGF6eVJhY2U7XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmVDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKTtcblxuXHRcdFx0ckFGKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKCAhZmlyZXNMb2FkIHx8IChlbGVtLmNvbXBsZXRlICYmIGVsZW0ubmF0dXJhbFdpZHRoID4gMSkpe1xuXHRcdFx0XHRcdGlmKGZpcmVzTG9hZCl7XG5cdFx0XHRcdFx0XHRyZXNldFByZWxvYWRpbmcoZXZlbnQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpc0xvYWRpbmctLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3dpdGNoTG9hZGluZ0NsYXNzKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0fSk7XG5cblx0XHR2YXIgdW52ZWlsRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtKXtcblx0XHRcdHZhciBkZXRhaWw7XG5cblx0XHRcdHZhciBpc0ltZyA9IHJlZ0ltZy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuXG5cdFx0XHQvL2FsbG93IHVzaW5nIHNpemVzPVwiYXV0b1wiLCBidXQgZG9uJ3QgdXNlLiBpdCdzIGludmFsaWQuIFVzZSBkYXRhLXNpemVzPVwiYXV0b1wiIG9yIGEgdmFsaWQgdmFsdWUgZm9yIHNpemVzIGluc3RlYWQgKGkuZS46IHNpemVzPVwiODB2d1wiKVxuXHRcdFx0dmFyIHNpemVzID0gaXNJbWcgJiYgKGVsZW1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNpemVzQXR0cikgfHwgZWxlbVtfZ2V0QXR0cmlidXRlXSgnc2l6ZXMnKSk7XG5cdFx0XHR2YXIgaXNBdXRvID0gc2l6ZXMgPT0gJ2F1dG8nO1xuXG5cdFx0XHRpZiggKGlzQXV0byB8fCAhaXNDb21wbGV0ZWQpICYmIGlzSW1nICYmIChlbGVtW19nZXRBdHRyaWJ1dGVdKCdzcmMnKSB8fCBlbGVtLnNyY3NldCkgJiYgIWVsZW0uY29tcGxldGUgJiYgIWhhc0NsYXNzKGVsZW0sIGxhenlTaXplc0NvbmZpZy5lcnJvckNsYXNzKSAmJiBoYXNDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKSl7cmV0dXJuO31cblxuXHRcdFx0ZGV0YWlsID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5dW52ZWlscmVhZCcpLmRldGFpbDtcblxuXHRcdFx0aWYoaXNBdXRvKXtcblx0XHRcdFx0IGF1dG9TaXplci51cGRhdGVFbGVtKGVsZW0sIHRydWUsIGVsZW0ub2Zmc2V0V2lkdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLl9sYXp5UmFjZSA9IHRydWU7XG5cdFx0XHRpc0xvYWRpbmcrKztcblxuXHRcdFx0bGF6eVVudmVpbChlbGVtLCBkZXRhaWwsIGlzQXV0bywgc2l6ZXMsIGlzSW1nKTtcblx0XHR9O1xuXG5cdFx0dmFyIG9ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZihpc0NvbXBsZXRlZCl7cmV0dXJuO31cblx0XHRcdGlmKERhdGUubm93KCkgLSBzdGFydGVkIDwgOTk5KXtcblx0XHRcdFx0c2V0VGltZW91dChvbmxvYWQsIDk5OSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBhZnRlclNjcm9sbCA9IGRlYm91bmNlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDM7XG5cdFx0XHRcdHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpc0NvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDM7XG5cblx0XHRcdHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcblxuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYobGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID09IDMpe1xuXHRcdFx0XHRcdGxhenlTaXplc0NvbmZpZy5sb2FkTW9kZSA9IDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YWZ0ZXJTY3JvbGwoKTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0XzogZnVuY3Rpb24oKXtcblx0XHRcdFx0c3RhcnRlZCA9IERhdGUubm93KCk7XG5cblx0XHRcdFx0bGF6eXNpemVzLmVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKTtcblx0XHRcdFx0cHJlbG9hZEVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzICsgJyAnICsgbGF6eVNpemVzQ29uZmlnLnByZWxvYWRDbGFzcyk7XG5cdFx0XHRcdGhGYWMgPSBsYXp5U2l6ZXNDb25maWcuaEZhYztcblxuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuXHRcdFx0XHRpZih3aW5kb3cuTXV0YXRpb25PYnNlcnZlcil7XG5cdFx0XHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIHRocm90dGxlZENoZWNrRWxlbWVudHMgKS5vYnNlcnZlKCBkb2NFbGVtLCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBhdHRyaWJ1dGVzOiB0cnVlfSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY0VsZW1bX2FkZEV2ZW50TGlzdGVuZXJdKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblx0XHRcdFx0XHRkb2NFbGVtW19hZGRFdmVudExpc3RlbmVyXSgnRE9NQXR0ck1vZGlmaWVkJywgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG5cdFx0XHRcdFx0c2V0SW50ZXJ2YWwodGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgOTk5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuXHRcdFx0XHQvLywgJ2Z1bGxzY3JlZW5jaGFuZ2UnXG5cdFx0XHRcdFsnZm9jdXMnLCAnbW91c2VvdmVyJywgJ2NsaWNrJywgJ2xvYWQnLCAndHJhbnNpdGlvbmVuZCcsICdhbmltYXRpb25lbmQnLCAnd2Via2l0QW5pbWF0aW9uRW5kJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcblx0XHRcdFx0XHRkb2N1bWVudFtfYWRkRXZlbnRMaXN0ZW5lcl0obmFtZSwgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmKCgvZCR8XmMvLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkpKXtcblx0XHRcdFx0XHRvbmxvYWQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25sb2FkKTtcblx0XHRcdFx0XHRkb2N1bWVudFtfYWRkRXZlbnRMaXN0ZW5lcl0oJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KG9ubG9hZCwgMjAwMDApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYobGF6eXNpemVzLmVsZW1lbnRzLmxlbmd0aCl7XG5cdFx0XHRcdFx0Y2hlY2tFbGVtZW50cygpO1xuXHRcdFx0XHRcdHJBRi5fbHNGbHVzaCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNoZWNrRWxlbXM6IHRocm90dGxlZENoZWNrRWxlbWVudHMsXG5cdFx0XHR1bnZlaWw6IHVudmVpbEVsZW1lbnRcblx0XHR9O1xuXHR9KSgpO1xuXG5cblx0dmFyIGF1dG9TaXplciA9IChmdW5jdGlvbigpe1xuXHRcdHZhciBhdXRvc2l6ZXNFbGVtcztcblxuXHRcdHZhciBzaXplRWxlbWVudCA9IHJBRkl0KGZ1bmN0aW9uKGVsZW0sIHBhcmVudCwgZXZlbnQsIHdpZHRoKXtcblx0XHRcdHZhciBzb3VyY2VzLCBpLCBsZW47XG5cdFx0XHRlbGVtLl9sYXp5c2l6ZXNXaWR0aCA9IHdpZHRoO1xuXHRcdFx0d2lkdGggKz0gJ3B4JztcblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgd2lkdGgpO1xuXG5cdFx0XHRpZihyZWdQaWN0dXJlLnRlc3QocGFyZW50Lm5vZGVOYW1lIHx8ICcnKSl7XG5cdFx0XHRcdHNvdXJjZXMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xuXHRcdFx0XHRmb3IoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuXHRcdFx0XHRcdHNvdXJjZXNbaV0uc2V0QXR0cmlidXRlKCdzaXplcycsIHdpZHRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighZXZlbnQuZGV0YWlsLmRhdGFBdHRyKXtcblx0XHRcdFx0dXBkYXRlUG9seWZpbGwoZWxlbSwgZXZlbnQuZGV0YWlsKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIgZ2V0U2l6ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YUF0dHIsIHdpZHRoKXtcblx0XHRcdHZhciBldmVudDtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmKHBhcmVudCl7XG5cdFx0XHRcdHdpZHRoID0gZ2V0V2lkdGgoZWxlbSwgcGFyZW50LCB3aWR0aCk7XG5cdFx0XHRcdGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sICdsYXp5YmVmb3Jlc2l6ZXMnLCB7d2lkdGg6IHdpZHRoLCBkYXRhQXR0cjogISFkYXRhQXR0cn0pO1xuXG5cdFx0XHRcdGlmKCFldmVudC5kZWZhdWx0UHJldmVudGVkKXtcblx0XHRcdFx0XHR3aWR0aCA9IGV2ZW50LmRldGFpbC53aWR0aDtcblxuXHRcdFx0XHRcdGlmKHdpZHRoICYmIHdpZHRoICE9PSBlbGVtLl9sYXp5c2l6ZXNXaWR0aCl7XG5cdFx0XHRcdFx0XHRzaXplRWxlbWVudChlbGVtLCBwYXJlbnQsIGV2ZW50LCB3aWR0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciB1cGRhdGVFbGVtZW50c1NpemVzID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBpO1xuXHRcdFx0dmFyIGxlbiA9IGF1dG9zaXplc0VsZW1zLmxlbmd0aDtcblx0XHRcdGlmKGxlbil7XG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdGZvcig7IGkgPCBsZW47IGkrKyl7XG5cdFx0XHRcdFx0Z2V0U2l6ZUVsZW1lbnQoYXV0b3NpemVzRWxlbXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzID0gZGVib3VuY2UodXBkYXRlRWxlbWVudHNTaXplcyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0XzogZnVuY3Rpb24oKXtcblx0XHRcdFx0YXV0b3NpemVzRWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGxhenlTaXplc0NvbmZpZy5hdXRvc2l6ZXNDbGFzcyk7XG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMpO1xuXHRcdFx0fSxcblx0XHRcdGNoZWNrRWxlbXM6IGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMsXG5cdFx0XHR1cGRhdGVFbGVtOiBnZXRTaXplRWxlbWVudFxuXHRcdH07XG5cdH0pKCk7XG5cblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xuXHRcdGlmKCFpbml0Lmkpe1xuXHRcdFx0aW5pdC5pID0gdHJ1ZTtcblx0XHRcdGF1dG9TaXplci5fKCk7XG5cdFx0XHRsb2FkZXIuXygpO1xuXHRcdH1cblx0fTtcblxuXHRsYXp5c2l6ZXMgPSB7XG5cdFx0Y2ZnOiBsYXp5U2l6ZXNDb25maWcsXG5cdFx0YXV0b1NpemVyOiBhdXRvU2l6ZXIsXG5cdFx0bG9hZGVyOiBsb2FkZXIsXG5cdFx0aW5pdDogaW5pdCxcblx0XHR1UDogdXBkYXRlUG9seWZpbGwsXG5cdFx0YUM6IGFkZENsYXNzLFxuXHRcdHJDOiByZW1vdmVDbGFzcyxcblx0XHRoQzogaGFzQ2xhc3MsXG5cdFx0ZmlyZTogdHJpZ2dlckV2ZW50LFxuXHRcdGdXOiBnZXRXaWR0aCxcblx0XHRyQUY6IHJBRixcblx0fTtcblxuXHRyZXR1cm4gbGF6eXNpemVzO1xufVxuKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lazysizes/lazysizes.js\n")},"./node_modules/lazysizes/plugins/object-fit/ls.object-fit.js":function(module,exports,__webpack_require__){eval("(function(window, factory) {\n\tvar globalInstall = function(initialEvent){\n\t\tfactory(window.lazySizes, initialEvent);\n\t\twindow.removeEventListener('lazyunveilread', globalInstall, true);\n\t};\n\n\tfactory = factory.bind(null, window, window.document);\n\n\tif(typeof module == 'object' && module.exports){\n\t\tfactory(__webpack_require__(/*! lazysizes */ \"./node_modules/lazysizes/lazysizes.js\"));\n\t} else if(window.lazySizes) {\n\t\tglobalInstall();\n\t} else {\n\t\twindow.addEventListener('lazyunveilread', globalInstall, true);\n\t}\n}(window, function(window, document, lazySizes, initialEvent) {\n\t'use strict';\n\tvar style = document.createElement('a').style;\n\tvar fitSupport = 'objectFit' in style;\n\tvar positionSupport = fitSupport && 'objectPosition' in style;\n\tvar regCssFit = /object-fit[\"']*\\s*:\\s*[\"']*(contain|cover)/;\n\tvar regCssPosition = /object-position[\"']*\\s*:\\s*[\"']*(.+?)(?=($|,|'|\"|;))/;\n\tvar blankSrc = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n\tvar regBgUrlEscape = /\\(|\\)|'/;\n\tvar positionDefaults = {\n\t\tcenter: 'center',\n\t\t'50% 50%': 'center',\n\t};\n\n\tfunction getObject(element){\n\t\tvar css = (getComputedStyle(element, null) || {});\n\t\tvar content = css.fontFamily || '';\n\t\tvar objectFit = content.match(regCssFit) || '';\n\t\tvar objectPosition = objectFit && content.match(regCssPosition) || '';\n\n\t\tif(objectPosition){\n\t\t\tobjectPosition = objectPosition[1];\n\t\t}\n\n\t\treturn {\n\t\t\tfit: objectFit && objectFit[1] || '',\n\t\t\tposition: positionDefaults[objectPosition] || objectPosition || 'center',\n\t\t};\n\t}\n\n\tfunction initFix(element, config){\n\t\tvar switchClassesAdded, addedSrc;\n\t\tvar lazysizesCfg = lazySizes.cfg;\n\t\tvar styleElement = element.cloneNode(false);\n\t\tvar styleElementStyle = styleElement.style;\n\n\t\tvar onChange = function(){\n\t\t\tvar src = element.currentSrc || element.src;\n\n\t\t\tif(src && addedSrc !== src){\n\t\t\t\taddedSrc = src;\n\t\t\t\tstyleElementStyle.backgroundImage = 'url(' + (regBgUrlEscape.test(src) ? JSON.stringify(src) : src ) + ')';\n\n\t\t\t\tif(!switchClassesAdded){\n\t\t\t\t\tswitchClassesAdded = true;\n\t\t\t\t\tlazySizes.rC(styleElement, lazysizesCfg.loadingClass);\n\t\t\t\t\tlazySizes.aC(styleElement, lazysizesCfg.loadedClass);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar rafedOnChange = function(){\n\t\t\tlazySizes.rAF(onChange);\n\t\t};\n\n\t\telement._lazysizesParentFit = config.fit;\n\n\t\telement.addEventListener('lazyloaded', rafedOnChange, true);\n\t\telement.addEventListener('load', rafedOnChange, true);\n\n\t\tstyleElement.addEventListener('load', function(){\n\t\t\tvar curSrc = styleElement.currentSrc || styleElement.src;\n\n\t\t\tif(curSrc && curSrc != blankSrc){\n\t\t\t\tstyleElement.src = blankSrc;\n\t\t\t\tstyleElement.srcset = '';\n\t\t\t}\n\t\t});\n\n\t\tlazySizes.rAF(function(){\n\n\t\t\tvar hideElement = element;\n\t\t\tvar container = element.parentNode;\n\n\t\t\tif(container.nodeName.toUpperCase() == 'PICTURE'){\n\t\t\t\thideElement = container;\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tlazySizes.rC(styleElement, lazysizesCfg.loadedClass);\n\t\t\tlazySizes.rC(styleElement, lazysizesCfg.lazyClass);\n\t\t\tlazySizes.aC(styleElement, lazysizesCfg.loadingClass);\n\t\t\tlazySizes.aC(styleElement, lazysizesCfg.objectFitClass || 'lazysizes-display-clone');\n\n\t\t\tif(styleElement.getAttribute(lazysizesCfg.srcsetAttr)){\n\t\t\t\tstyleElement.setAttribute(lazysizesCfg.srcsetAttr, '');\n\t\t\t}\n\n\t\t\tif(styleElement.getAttribute(lazysizesCfg.srcAttr)){\n\t\t\t\tstyleElement.setAttribute(lazysizesCfg.srcAttr, '');\n\t\t\t}\n\n\t\t\tstyleElement.src = blankSrc;\n\t\t\tstyleElement.srcset = '';\n\n\t\t\tstyleElementStyle.backgroundRepeat = 'no-repeat';\n\t\t\tstyleElementStyle.backgroundPosition = config.position;\n\t\t\tstyleElementStyle.backgroundSize = config.fit;\n\n\t\t\thideElement.style.display = 'none';\n\n\t\t\telement.setAttribute('data-parent-fit', config.fit);\n\t\t\telement.setAttribute('data-parent-container', 'prev');\n\n\t\t\tcontainer.insertBefore(styleElement, hideElement);\n\n\t\t\tif(element._lazysizesParentFit){\n\t\t\t\tdelete element._lazysizesParentFit;\n\t\t\t}\n\n\t\t\tif(element.complete){\n\t\t\t\tonChange();\n\t\t\t}\n\t\t});\n\t}\n\n\tif(!fitSupport || !positionSupport){\n\t\tvar onRead = function(e){\n\t\t\tif(e.detail.instance != lazySizes){return;}\n\n\t\t\tvar element = e.target;\n\t\t\tvar obj = getObject(element);\n\n\t\t\tif(obj.fit && (!fitSupport || (obj.position != 'center'))){\n\t\t\t\tinitFix(element, obj);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener('lazyunveilread', onRead, true);\n\n\t\tif(initialEvent && initialEvent.detail){\n\t\t\tonRead(initialEvent);\n\t\t}\n\t}\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGF6eXNpemVzL3BsdWdpbnMvb2JqZWN0LWZpdC9scy5vYmplY3QtZml0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xhenlzaXplcy9wbHVnaW5zL29iamVjdC1maXQvbHMub2JqZWN0LWZpdC5qcz83YmFmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbih3aW5kb3csIGZhY3RvcnkpIHtcblx0dmFyIGdsb2JhbEluc3RhbGwgPSBmdW5jdGlvbihpbml0aWFsRXZlbnQpe1xuXHRcdGZhY3Rvcnkod2luZG93LmxhenlTaXplcywgaW5pdGlhbEV2ZW50KTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGF6eXVudmVpbHJlYWQnLCBnbG9iYWxJbnN0YWxsLCB0cnVlKTtcblx0fTtcblxuXHRmYWN0b3J5ID0gZmFjdG9yeS5iaW5kKG51bGwsIHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcblxuXHRpZih0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKXtcblx0XHRmYWN0b3J5KHJlcXVpcmUoJ2xhenlzaXplcycpKTtcblx0fSBlbHNlIGlmKHdpbmRvdy5sYXp5U2l6ZXMpIHtcblx0XHRnbG9iYWxJbnN0YWxsKCk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xhenl1bnZlaWxyZWFkJywgZ2xvYmFsSW5zdGFsbCwgdHJ1ZSk7XG5cdH1cbn0od2luZG93LCBmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBsYXp5U2l6ZXMsIGluaXRpYWxFdmVudCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcblx0dmFyIGZpdFN1cHBvcnQgPSAnb2JqZWN0Rml0JyBpbiBzdHlsZTtcblx0dmFyIHBvc2l0aW9uU3VwcG9ydCA9IGZpdFN1cHBvcnQgJiYgJ29iamVjdFBvc2l0aW9uJyBpbiBzdHlsZTtcblx0dmFyIHJlZ0Nzc0ZpdCA9IC9vYmplY3QtZml0W1wiJ10qXFxzKjpcXHMqW1wiJ10qKGNvbnRhaW58Y292ZXIpLztcblx0dmFyIHJlZ0Nzc1Bvc2l0aW9uID0gL29iamVjdC1wb3NpdGlvbltcIiddKlxccyo6XFxzKltcIiddKiguKz8pKD89KCR8LHwnfFwifDspKS87XG5cdHZhciBibGFua1NyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG5cdHZhciByZWdCZ1VybEVzY2FwZSA9IC9cXCh8XFwpfCcvO1xuXHR2YXIgcG9zaXRpb25EZWZhdWx0cyA9IHtcblx0XHRjZW50ZXI6ICdjZW50ZXInLFxuXHRcdCc1MCUgNTAlJzogJ2NlbnRlcicsXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0T2JqZWN0KGVsZW1lbnQpe1xuXHRcdHZhciBjc3MgPSAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKSB8fCB7fSk7XG5cdFx0dmFyIGNvbnRlbnQgPSBjc3MuZm9udEZhbWlseSB8fCAnJztcblx0XHR2YXIgb2JqZWN0Rml0ID0gY29udGVudC5tYXRjaChyZWdDc3NGaXQpIHx8ICcnO1xuXHRcdHZhciBvYmplY3RQb3NpdGlvbiA9IG9iamVjdEZpdCAmJiBjb250ZW50Lm1hdGNoKHJlZ0Nzc1Bvc2l0aW9uKSB8fCAnJztcblxuXHRcdGlmKG9iamVjdFBvc2l0aW9uKXtcblx0XHRcdG9iamVjdFBvc2l0aW9uID0gb2JqZWN0UG9zaXRpb25bMV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGZpdDogb2JqZWN0Rml0ICYmIG9iamVjdEZpdFsxXSB8fCAnJyxcblx0XHRcdHBvc2l0aW9uOiBwb3NpdGlvbkRlZmF1bHRzW29iamVjdFBvc2l0aW9uXSB8fCBvYmplY3RQb3NpdGlvbiB8fCAnY2VudGVyJyxcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdEZpeChlbGVtZW50LCBjb25maWcpe1xuXHRcdHZhciBzd2l0Y2hDbGFzc2VzQWRkZWQsIGFkZGVkU3JjO1xuXHRcdHZhciBsYXp5c2l6ZXNDZmcgPSBsYXp5U2l6ZXMuY2ZnO1xuXHRcdHZhciBzdHlsZUVsZW1lbnQgPSBlbGVtZW50LmNsb25lTm9kZShmYWxzZSk7XG5cdFx0dmFyIHN0eWxlRWxlbWVudFN0eWxlID0gc3R5bGVFbGVtZW50LnN0eWxlO1xuXG5cdFx0dmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24oKXtcblx0XHRcdHZhciBzcmMgPSBlbGVtZW50LmN1cnJlbnRTcmMgfHwgZWxlbWVudC5zcmM7XG5cblx0XHRcdGlmKHNyYyAmJiBhZGRlZFNyYyAhPT0gc3JjKXtcblx0XHRcdFx0YWRkZWRTcmMgPSBzcmM7XG5cdFx0XHRcdHN0eWxlRWxlbWVudFN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIChyZWdCZ1VybEVzY2FwZS50ZXN0KHNyYykgPyBKU09OLnN0cmluZ2lmeShzcmMpIDogc3JjICkgKyAnKSc7XG5cblx0XHRcdFx0aWYoIXN3aXRjaENsYXNzZXNBZGRlZCl7XG5cdFx0XHRcdFx0c3dpdGNoQ2xhc3Nlc0FkZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRsYXp5U2l6ZXMuckMoc3R5bGVFbGVtZW50LCBsYXp5c2l6ZXNDZmcubG9hZGluZ0NsYXNzKTtcblx0XHRcdFx0XHRsYXp5U2l6ZXMuYUMoc3R5bGVFbGVtZW50LCBsYXp5c2l6ZXNDZmcubG9hZGVkQ2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR2YXIgcmFmZWRPbkNoYW5nZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRsYXp5U2l6ZXMuckFGKG9uQ2hhbmdlKTtcblx0XHR9O1xuXG5cdFx0ZWxlbWVudC5fbGF6eXNpemVzUGFyZW50Rml0ID0gY29uZmlnLmZpdDtcblxuXHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGF6eWxvYWRlZCcsIHJhZmVkT25DaGFuZ2UsIHRydWUpO1xuXHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJhZmVkT25DaGFuZ2UsIHRydWUpO1xuXG5cdFx0c3R5bGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGN1clNyYyA9IHN0eWxlRWxlbWVudC5jdXJyZW50U3JjIHx8IHN0eWxlRWxlbWVudC5zcmM7XG5cblx0XHRcdGlmKGN1clNyYyAmJiBjdXJTcmMgIT0gYmxhbmtTcmMpe1xuXHRcdFx0XHRzdHlsZUVsZW1lbnQuc3JjID0gYmxhbmtTcmM7XG5cdFx0XHRcdHN0eWxlRWxlbWVudC5zcmNzZXQgPSAnJztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGxhenlTaXplcy5yQUYoZnVuY3Rpb24oKXtcblxuXHRcdFx0dmFyIGhpZGVFbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHZhciBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cblx0XHRcdGlmKGNvbnRhaW5lci5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdQSUNUVVJFJyl7XG5cdFx0XHRcdGhpZGVFbGVtZW50ID0gY29udGFpbmVyO1xuXHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0bGF6eVNpemVzLnJDKHN0eWxlRWxlbWVudCwgbGF6eXNpemVzQ2ZnLmxvYWRlZENsYXNzKTtcblx0XHRcdGxhenlTaXplcy5yQyhzdHlsZUVsZW1lbnQsIGxhenlzaXplc0NmZy5sYXp5Q2xhc3MpO1xuXHRcdFx0bGF6eVNpemVzLmFDKHN0eWxlRWxlbWVudCwgbGF6eXNpemVzQ2ZnLmxvYWRpbmdDbGFzcyk7XG5cdFx0XHRsYXp5U2l6ZXMuYUMoc3R5bGVFbGVtZW50LCBsYXp5c2l6ZXNDZmcub2JqZWN0Rml0Q2xhc3MgfHwgJ2xhenlzaXplcy1kaXNwbGF5LWNsb25lJyk7XG5cblx0XHRcdGlmKHN0eWxlRWxlbWVudC5nZXRBdHRyaWJ1dGUobGF6eXNpemVzQ2ZnLnNyY3NldEF0dHIpKXtcblx0XHRcdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShsYXp5c2l6ZXNDZmcuc3Jjc2V0QXR0ciwgJycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKGxhenlzaXplc0NmZy5zcmNBdHRyKSl7XG5cdFx0XHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUobGF6eXNpemVzQ2ZnLnNyY0F0dHIsICcnKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVFbGVtZW50LnNyYyA9IGJsYW5rU3JjO1xuXHRcdFx0c3R5bGVFbGVtZW50LnNyY3NldCA9ICcnO1xuXG5cdFx0XHRzdHlsZUVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kUmVwZWF0ID0gJ25vLXJlcGVhdCc7XG5cdFx0XHRzdHlsZUVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG5cdFx0XHRzdHlsZUVsZW1lbnRTdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNvbmZpZy5maXQ7XG5cblx0XHRcdGhpZGVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudC1maXQnLCBjb25maWcuZml0KTtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudC1jb250YWluZXInLCAncHJldicpO1xuXG5cdFx0XHRjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGlkZUVsZW1lbnQpO1xuXG5cdFx0XHRpZihlbGVtZW50Ll9sYXp5c2l6ZXNQYXJlbnRGaXQpe1xuXHRcdFx0XHRkZWxldGUgZWxlbWVudC5fbGF6eXNpemVzUGFyZW50Rml0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZihlbGVtZW50LmNvbXBsZXRlKXtcblx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGlmKCFmaXRTdXBwb3J0IHx8ICFwb3NpdGlvblN1cHBvcnQpe1xuXHRcdHZhciBvblJlYWQgPSBmdW5jdGlvbihlKXtcblx0XHRcdGlmKGUuZGV0YWlsLmluc3RhbmNlICE9IGxhenlTaXplcyl7cmV0dXJuO31cblxuXHRcdFx0dmFyIGVsZW1lbnQgPSBlLnRhcmdldDtcblx0XHRcdHZhciBvYmogPSBnZXRPYmplY3QoZWxlbWVudCk7XG5cblx0XHRcdGlmKG9iai5maXQgJiYgKCFmaXRTdXBwb3J0IHx8IChvYmoucG9zaXRpb24gIT0gJ2NlbnRlcicpKSl7XG5cdFx0XHRcdGluaXRGaXgoZWxlbWVudCwgb2JqKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xhenl1bnZlaWxyZWFkJywgb25SZWFkLCB0cnVlKTtcblxuXHRcdGlmKGluaXRpYWxFdmVudCAmJiBpbml0aWFsRXZlbnQuZGV0YWlsKXtcblx0XHRcdG9uUmVhZChpbml0aWFsRXZlbnQpO1xuXHRcdH1cblx0fVxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lazysizes/plugins/object-fit/ls.object-fit.js\n")},"./node_modules/lodash.debounce/index.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9mN2ZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash.debounce/index.js\n")},"./node_modules/lodash.throttle/index.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLnRocm90dGxlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcz84NGEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.throttle/index.js\n")},"./node_modules/tap-listener/tap-listener.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Tap listener v2.0.0\n * listens to taps\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false*/ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Unipointer ) {\n      return factory( window, Unipointer );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// --------------------------  TapListener -------------------------- //\n\nfunction TapListener( elem ) {\n  this.bindTap( elem );\n}\n\n// inherit Unipointer & EventEmitter\nvar proto = TapListener.prototype = Object.create( Unipointer.prototype );\n\n/**\n * bind tap event to element\n * @param {Element} elem\n */\nproto.bindTap = function( elem ) {\n  if ( !elem ) {\n    return;\n  }\n  this.unbindTap();\n  this.tapElement = elem;\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindTap = function() {\n  if ( !this.tapElement ) {\n    return;\n  }\n  this._bindStartEvent( this.tapElement, true );\n  delete this.tapElement;\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  var pointerPoint = Unipointer.getPointerPoint( pointer );\n  var boundingRect = this.tapElement.getBoundingClientRect();\n  var scrollX = window.pageXOffset;\n  var scrollY = window.pageYOffset;\n  // calculate if pointer is inside tapElement\n  var isInside = pointerPoint.x >= boundingRect.left + scrollX &&\n    pointerPoint.x <= boundingRect.right + scrollX &&\n    pointerPoint.y >= boundingRect.top + scrollY &&\n    pointerPoint.y <= boundingRect.bottom + scrollY;\n  // trigger callback if pointer is inside element\n  if ( isInside ) {\n    this.emitEvent( 'tap', [ event, pointer ] );\n  }\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    var _this = this;\n    setTimeout( function() {\n      delete _this.isIgnoringMouseUp;\n    }, 400 );\n  }\n};\n\nproto.destroy = function() {\n  this.pointerDone();\n  this.unbindTap();\n};\n\n// -----  ----- //\n\nreturn TapListener;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFwLWxpc3RlbmVyL3RhcC1saXN0ZW5lci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXAtbGlzdGVuZXIvdGFwLWxpc3RlbmVyLmpzPzMyNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUYXAgbGlzdGVuZXIgdjIuMC4wXG4gKiBsaXN0ZW5zIHRvIHRhcHNcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qanNoaW50IHN0cmljdDogZmFsc2UqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggW1xuICAgICAgJ3VuaXBvaW50ZXIvdW5pcG9pbnRlcidcbiAgICBdLCBmdW5jdGlvbiggVW5pcG9pbnRlciApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIFVuaXBvaW50ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ3VuaXBvaW50ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuVGFwTGlzdGVuZXIgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LlVuaXBvaW50ZXJcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBVbmlwb2ludGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBUYXBMaXN0ZW5lciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBUYXBMaXN0ZW5lciggZWxlbSApIHtcbiAgdGhpcy5iaW5kVGFwKCBlbGVtICk7XG59XG5cbi8vIGluaGVyaXQgVW5pcG9pbnRlciAmIEV2ZW50RW1pdHRlclxudmFyIHByb3RvID0gVGFwTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pcG9pbnRlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBiaW5kIHRhcCBldmVudCB0byBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqL1xucHJvdG8uYmluZFRhcCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICBpZiAoICFlbGVtICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnVuYmluZFRhcCgpO1xuICB0aGlzLnRhcEVsZW1lbnQgPSBlbGVtO1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kVGFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMudGFwRWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIHRoaXMudGFwRWxlbWVudCwgdHJ1ZSApO1xuICBkZWxldGUgdGhpcy50YXBFbGVtZW50O1xufTtcblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIGlnbm9yZSBlbXVsYXRlZCBtb3VzZSB1cCBjbGlja3NcbiAgaWYgKCB0aGlzLmlzSWdub3JpbmdNb3VzZVVwICYmIGV2ZW50LnR5cGUgPT0gJ21vdXNldXAnICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb2ludGVyUG9pbnQgPSBVbmlwb2ludGVyLmdldFBvaW50ZXJQb2ludCggcG9pbnRlciApO1xuICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy50YXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gIC8vIGNhbGN1bGF0ZSBpZiBwb2ludGVyIGlzIGluc2lkZSB0YXBFbGVtZW50XG4gIHZhciBpc0luc2lkZSA9IHBvaW50ZXJQb2ludC54ID49IGJvdW5kaW5nUmVjdC5sZWZ0ICsgc2Nyb2xsWCAmJlxuICAgIHBvaW50ZXJQb2ludC54IDw9IGJvdW5kaW5nUmVjdC5yaWdodCArIHNjcm9sbFggJiZcbiAgICBwb2ludGVyUG9pbnQueSA+PSBib3VuZGluZ1JlY3QudG9wICsgc2Nyb2xsWSAmJlxuICAgIHBvaW50ZXJQb2ludC55IDw9IGJvdW5kaW5nUmVjdC5ib3R0b20gKyBzY3JvbGxZO1xuICAvLyB0cmlnZ2VyIGNhbGxiYWNrIGlmIHBvaW50ZXIgaXMgaW5zaWRlIGVsZW1lbnRcbiAgaWYgKCBpc0luc2lkZSApIHtcbiAgICB0aGlzLmVtaXRFdmVudCggJ3RhcCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xuICB9XG5cbiAgLy8gc2V0IGZsYWcgZm9yIGVtdWxhdGVkIGNsaWNrcyAzMDBtcyBhZnRlciB0b3VjaGVuZFxuICBpZiAoIGV2ZW50LnR5cGUgIT0gJ21vdXNldXAnICkge1xuICAgIHRoaXMuaXNJZ25vcmluZ01vdXNlVXAgPSB0cnVlO1xuICAgIC8vIHJlc2V0IGZsYWcgYWZ0ZXIgMzAwbXNcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgZGVsZXRlIF90aGlzLmlzSWdub3JpbmdNb3VzZVVwO1xuICAgIH0sIDQwMCApO1xuICB9XG59O1xuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucG9pbnRlckRvbmUoKTtcbiAgdGhpcy51bmJpbmRUYXAoKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVGFwTGlzdGVuZXI7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tap-listener/tap-listener.js\n")},"./node_modules/unidragger/unidragger.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Unipointer ) {\n      return factory( window, Unipointer );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// -------------------------- Unidragger -------------------------- //\n\nfunction Unidragger() {}\n\n// inherit Unipointer & EvEmitter\nvar proto = Unidragger.prototype = Object.create( Unipointer.prototype );\n\n// ----- bind start ----- //\n\nproto.bindHandles = function() {\n  this._bindHandles( true );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd\n */\nproto._bindHandles = function( isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  // bind each handle\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n  var touchAction = isAdd ? this._touchActionValue : '';\n  for ( var i=0; i < this.handles.length; i++ ) {\n    var handle = this.handles[i];\n    this._bindStartEvent( handle, isAdd );\n    handle[ bindMethod ]( 'click', this );\n    // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n    if ( window.PointerEvent ) {\n      handle.style.touchAction = touchAction;\n    }\n  }\n};\n\n// prototype so it can be overwriteable by Flickity\nproto._touchActionValue = 'none';\n\n// ----- start event ----- //\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n  // track start event position\n  this.pointerDownPointer = pointer;\n\n  event.preventDefault();\n  this.pointerDownBlur();\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// nodes that have text fields\nvar cursorNodes = {\n  TEXTAREA: true,\n  INPUT: true,\n  SELECT: true,\n  OPTION: true,\n};\n\n// input types that do not have text fields\nvar clickTypes = {\n  radio: true,\n  checkbox: true,\n  button: true,\n  submit: true,\n  image: true,\n  file: true,\n};\n\n// dismiss inputs with text fields. flickity#403, flickity#404\nproto.okayPointerDown = function( event ) {\n  var isCursorNode = cursorNodes[ event.target.nodeName ];\n  var isClickType = clickTypes[ event.target.type ];\n  var isOkay = !isCursorNode || isClickType;\n  if ( !isOkay ) {\n    this._pointerReset();\n  }\n  return isOkay;\n};\n\n// kludge to blur previously focused input\nproto.pointerDownBlur = function() {\n  var focused = document.activeElement;\n  // do not blur body for IE10, metafizzy/flickity#117\n  var canBlur = focused && focused.blur && focused != document.body;\n  if ( canBlur ) {\n    focused.blur();\n  }\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\n// base pointer move logic\nproto._dragPointerMove = function( event, pointer ) {\n  var moveVector = {\n    x: pointer.pageX - this.pointerDownPointer.pageX,\n    y: pointer.pageY - this.pointerDownPointer.pageY\n  };\n  // start drag if pointer has moved far enough to start drag\n  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {\n    this._dragStart( event, pointer );\n  }\n  return moveVector;\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto._dragPointerUp = function( event, pointer ) {\n  if ( this.isDragging ) {\n    this._dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this._staticClick( event, pointer );\n  }\n};\n\n// -------------------------- drag -------------------------- //\n\n// dragStart\nproto._dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  // prevent clicks\n  this.isPreventingClicks = true;\n  this.dragStart( event, pointer );\n};\n\nproto.dragStart = function( event, pointer ) {\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\n// dragMove\nproto._dragMove = function( event, pointer, moveVector ) {\n  // do not drag if not dragging yet\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// dragEnd\nproto._dragEnd = function( event, pointer ) {\n  // set flags\n  this.isDragging = false;\n  // re-enable clicking async\n  setTimeout( function() {\n    delete this.isPreventingClicks;\n  }.bind( this ) );\n\n  this.dragEnd( event, pointer );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// ----- onclick ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) {\n    event.preventDefault();\n  }\n};\n\n// ----- staticClick ----- //\n\n// triggered after pointer down & up with no/tiny movement\nproto._staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  this.staticClick( event, pointer );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    setTimeout( function() {\n      delete this.isIgnoringMouseUp;\n    }.bind( this ), 400 );\n  }\n};\n\nproto.staticClick = function( event, pointer ) {\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n};\n\n// ----- utils ----- //\n\nUnidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n// -----  ----- //\n\nreturn Unidragger;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pZHJhZ2dlci91bmlkcmFnZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaWRyYWdnZXIvdW5pZHJhZ2dlci5qcz9lZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pZHJhZ2dlciB2Mi4zLjBcbiAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAndW5pcG9pbnRlci91bmlwb2ludGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBVbmlwb2ludGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgndW5pcG9pbnRlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5VbmlkcmFnZ2VyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5Vbmlwb2ludGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVbmlkcmFnZ2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIFVuaWRyYWdnZXIoKSB7fVxuXG4vLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaWRyYWdnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pcG9pbnRlci5wcm90b3R5cGUgKTtcblxuLy8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xuXG5wcm90by5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZFxuICovXG5wcm90by5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNBZGQgKSB7XG4gIC8vIG11bmdlIGlzQWRkLCBkZWZhdWx0IHRvIHRydWVcbiAgaXNBZGQgPSBpc0FkZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzQWRkO1xuICAvLyBiaW5kIGVhY2ggaGFuZGxlXG4gIHZhciBiaW5kTWV0aG9kID0gaXNBZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIHZhciB0b3VjaEFjdGlvbiA9IGlzQWRkID8gdGhpcy5fdG91Y2hBY3Rpb25WYWx1ZSA6ICcnO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLmhhbmRsZXNbaV07XG4gICAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGhhbmRsZSwgaXNBZGQgKTtcbiAgICBoYW5kbGVbIGJpbmRNZXRob2QgXSggJ2NsaWNrJywgdGhpcyApO1xuICAgIC8vIHRvdWNoLWFjdGlvbjogbm9uZSB0byBvdmVycmlkZSBicm93c2VyIHRvdWNoIGdlc3R1cmVzLiBtZXRhZml6enkvZmxpY2tpdHkjNTQwXG4gICAgaWYgKCB3aW5kb3cuUG9pbnRlckV2ZW50ICkge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvdWNoQWN0aW9uID0gdG91Y2hBY3Rpb247XG4gICAgfVxuICB9XG59O1xuXG4vLyBwcm90b3R5cGUgc28gaXQgY2FuIGJlIG92ZXJ3cml0ZWFibGUgYnkgRmxpY2tpdHlcbnByb3RvLl90b3VjaEFjdGlvblZhbHVlID0gJ25vbmUnO1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgaXNPa2F5ID0gdGhpcy5va2F5UG9pbnRlckRvd24oIGV2ZW50ICk7XG4gIGlmICggIWlzT2theSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdHJhY2sgc3RhcnQgZXZlbnQgcG9zaXRpb25cbiAgdGhpcy5wb2ludGVyRG93blBvaW50ZXIgPSBwb2ludGVyO1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucG9pbnRlckRvd25CbHVyKCk7XG4gIC8vIGJpbmQgbW92ZSBhbmQgZW5kIGV2ZW50c1xuICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyBub2RlcyB0aGF0IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjdXJzb3JOb2RlcyA9IHtcbiAgVEVYVEFSRUE6IHRydWUsXG4gIElOUFVUOiB0cnVlLFxuICBTRUxFQ1Q6IHRydWUsXG4gIE9QVElPTjogdHJ1ZSxcbn07XG5cbi8vIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjbGlja1R5cGVzID0ge1xuICByYWRpbzogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgZmlsZTogdHJ1ZSxcbn07XG5cbi8vIGRpc21pc3MgaW5wdXRzIHdpdGggdGV4dCBmaWVsZHMuIGZsaWNraXR5IzQwMywgZmxpY2tpdHkjNDA0XG5wcm90by5va2F5UG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc0N1cnNvck5vZGUgPSBjdXJzb3JOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIHZhciBpc0NsaWNrVHlwZSA9IGNsaWNrVHlwZXNbIGV2ZW50LnRhcmdldC50eXBlIF07XG4gIHZhciBpc09rYXkgPSAhaXNDdXJzb3JOb2RlIHx8IGlzQ2xpY2tUeXBlO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIH1cbiAgcmV0dXJuIGlzT2theTtcbn07XG5cbi8vIGtsdWRnZSB0byBibHVyIHByZXZpb3VzbHkgZm9jdXNlZCBpbnB1dFxucHJvdG8ucG9pbnRlckRvd25CbHVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgLy8gZG8gbm90IGJsdXIgYm9keSBmb3IgSUUxMCwgbWV0YWZpenp5L2ZsaWNraXR5IzExN1xuICB2YXIgY2FuQmx1ciA9IGZvY3VzZWQgJiYgZm9jdXNlZC5ibHVyICYmIGZvY3VzZWQgIT0gZG9jdW1lbnQuYm9keTtcbiAgaWYgKCBjYW5CbHVyICkge1xuICAgIGZvY3VzZWQuYmx1cigpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogZHJhZyBtb3ZlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB0aGlzLl9kcmFnUG9pbnRlck1vdmUoIGV2ZW50LCBwb2ludGVyICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcbiAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG4vLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xucHJvdG8uX2RyYWdQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB7XG4gICAgeDogcG9pbnRlci5wYWdlWCAtIHRoaXMucG9pbnRlckRvd25Qb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVkgLSB0aGlzLnBvaW50ZXJEb3duUG9pbnRlci5wYWdlWVxuICB9O1xuICAvLyBzdGFydCBkcmFnIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5oYXNEcmFnU3RhcnRlZCggbW92ZVZlY3RvciApICkge1xuICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfVxuICByZXR1cm4gbW92ZVZlY3Rvcjtcbn07XG5cbi8vIGNvbmRpdGlvbiBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcbnByb3RvLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XG4gIHJldHVybiBNYXRoLmFicyggbW92ZVZlY3Rvci54ICkgPiAzIHx8IE1hdGguYWJzKCBtb3ZlVmVjdG9yLnkgKSA+IDM7XG59O1xuXG4vLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XG4gIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5fZHJhZ1BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2ludGVyIGRpZG4ndCBtb3ZlIGVub3VnaCBmb3IgZHJhZyB0byBzdGFydFxuICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGRyYWdTdGFydFxucHJvdG8uX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgLy8gcHJldmVudCBjbGlja3NcbiAgdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgPSB0cnVlO1xuICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnU3RhcnQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGRyYWdNb3ZlXG5wcm90by5fZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcbiAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG5wcm90by5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLy8gZHJhZ0VuZFxucHJvdG8uX2RyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIHNldCBmbGFnc1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgLy8gcmUtZW5hYmxlIGNsaWNraW5nIGFzeW5jXG4gIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJldmVudGluZ0NsaWNrcztcbiAgfS5iaW5kKCB0aGlzICkgKTtcblxuICB0aGlzLmRyYWdFbmQoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdFbmQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cblxuLy8gaGFuZGxlIGFsbCBjbGlja3MgYW5kIHByZXZlbnQgY2xpY2tzIHdoZW4gZHJhZ2dpbmdcbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxuLy8gdHJpZ2dlcmVkIGFmdGVyIHBvaW50ZXIgZG93biAmIHVwIHdpdGggbm8vdGlueSBtb3ZlbWVudFxucHJvdG8uX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBpZ25vcmUgZW11bGF0ZWQgbW91c2UgdXAgY2xpY2tzXG4gIGlmICggdGhpcy5pc0lnbm9yaW5nTW91c2VVcCAmJiBldmVudC50eXBlID09ICdtb3VzZXVwJyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuXG4gIC8vIHNldCBmbGFnIGZvciBlbXVsYXRlZCBjbGlja3MgMzAwbXMgYWZ0ZXIgdG91Y2hlbmRcbiAgaWYgKCBldmVudC50eXBlICE9ICdtb3VzZXVwJyApIHtcbiAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcbiAgICAvLyByZXNldCBmbGFnIGFmdGVyIDMwMG1zXG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5pc0lnbm9yaW5nTW91c2VVcDtcbiAgICB9LmJpbmQoIHRoaXMgKSwgNDAwICk7XG4gIH1cbn07XG5cbnByb3RvLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSB1dGlscyAtLS0tLSAvL1xuXG5VbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIFVuaWRyYWdnZXI7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/unidragger/unidragger.js\n")},"./node_modules/unipointer/unipointer.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, EvEmitter ) {\n\n'use strict';\n\nfunction noop() {}\n\nfunction Unipointer() {}\n\n// inherit EvEmitter\nvar proto = Unipointer.prototype = Object.create( EvEmitter.prototype );\n\nproto.bindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd - remove if falsey\n */\nproto._bindStartEvent = function( elem, isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n  // default to mouse events\n  var startEvent = 'mousedown';\n  if ( window.PointerEvent ) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n  } else if ( 'ontouchstart' in window ) {\n    // Touch Events. iOS Safari\n    startEvent = 'touchstart';\n  }\n  elem[ bindMethod ]( startEvent, this );\n};\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// returns the touch that we're keeping track of\nproto.getTouch = function( touches ) {\n  for ( var i=0; i < touches.length; i++ ) {\n    var touch = touches[i];\n    if ( touch.identifier == this.pointerIdentifier ) {\n      return touch;\n    }\n  }\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  // dismiss clicks from right or middle buttons\n  var button = event.button;\n  if ( button && ( button !== 0 && button !== 1 ) ) {\n    return;\n  }\n  this._pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this._pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onpointerdown = function( event ) {\n  this._pointerDown( event, event );\n};\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto._pointerDown = function( event, pointer ) {\n  // dismiss right click and other pointers\n  // button = 0 is okay, 1-4 not\n  if ( event.button || this.isPointerDown ) {\n    return;\n  }\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n  this.pointerDown( event, pointer );\n};\n\nproto.pointerDown = function( event, pointer ) {\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// hash of events to be bound after start event\nvar postStartEvents = {\n  mousedown: [ 'mousemove', 'mouseup' ],\n  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],\n  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],\n};\n\nproto._bindPostStartEvents = function( event ) {\n  if ( !event ) {\n    return;\n  }\n  // get proper events to match start event\n  var events = postStartEvents[ event.type ];\n  // bind events to node\n  events.forEach( function( eventName ) {\n    window.addEventListener( eventName, this );\n  }, this );\n  // save these arguments\n  this._boundPointerEvents = events;\n};\n\nproto._unbindPostStartEvents = function() {\n  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n  if ( !this._boundPointerEvents ) {\n    return;\n  }\n  this._boundPointerEvents.forEach( function( eventName ) {\n    window.removeEventListener( eventName, this );\n  }, this );\n\n  delete this._boundPointerEvents;\n};\n\n// ----- move event ----- //\n\nproto.onmousemove = function( event ) {\n  this._pointerMove( event, event );\n};\n\nproto.onpointermove = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerMove( event, event );\n  }\n};\n\nproto.ontouchmove = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerMove( event, touch );\n  }\n};\n\n/**\n * pointer move\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerMove = function( event, pointer ) {\n  this.pointerMove( event, pointer );\n};\n\n// public\nproto.pointerMove = function( event, pointer ) {\n  this.emitEvent( 'pointerMove', [ event, pointer ] );\n};\n\n// ----- end event ----- //\n\n\nproto.onmouseup = function( event ) {\n  this._pointerUp( event, event );\n};\n\nproto.onpointerup = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerUp( event, event );\n  }\n};\n\nproto.ontouchend = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerUp( event, touch );\n  }\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerUp = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerUp( event, pointer );\n};\n\n// public\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n};\n\n// ----- pointer done ----- //\n\n// triggered on pointer up & pointer cancel\nproto._pointerDone = function() {\n  this._pointerReset();\n  this._unbindPostStartEvents();\n  this.pointerDone();\n};\n\nproto._pointerReset = function() {\n  // reset properties\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n};\n\nproto.pointerDone = noop;\n\n// ----- pointer cancel ----- //\n\nproto.onpointercancel = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerCancel( event, event );\n  }\n};\n\nproto.ontouchcancel = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerCancel( event, touch );\n  }\n};\n\n/**\n * pointer cancel\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerCancel = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerCancel( event, pointer );\n};\n\n// public\nproto.pointerCancel = function( event, pointer ) {\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// -----  ----- //\n\n// utility function for getting x/y coords from event\nUnipointer.getPointerPoint = function( pointer ) {\n  return {\n    x: pointer.pageX,\n    y: pointer.pageY\n  };\n};\n\n// -----  ----- //\n\nreturn Unipointer;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pcG9pbnRlci91bmlwb2ludGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaXBvaW50ZXIvdW5pcG9pbnRlci5qcz9lMGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pcG9pbnRlciB2Mi4zLjBcbiAqIGJhc2UgY2xhc3MgZm9yIGRvaW5nIG9uZSB0aGluZyB3aXRoIHBvaW50ZXIgZXZlbnRcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuVW5pcG9pbnRlciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBVbmlwb2ludGVyKCkge31cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaXBvaW50ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5wcm90by5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZCAtIHJlbW92ZSBpZiBmYWxzZXlcbiAqL1xucHJvdG8uX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQWRkICkge1xuICAvLyBtdW5nZSBpc0FkZCwgZGVmYXVsdCB0byB0cnVlXG4gIGlzQWRkID0gaXNBZGQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc0FkZDtcbiAgdmFyIGJpbmRNZXRob2QgPSBpc0FkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAvLyBkZWZhdWx0IHRvIG1vdXNlIGV2ZW50c1xuICB2YXIgc3RhcnRFdmVudCA9ICdtb3VzZWRvd24nO1xuICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgKSB7XG4gICAgLy8gUG9pbnRlciBFdmVudHNcbiAgICBzdGFydEV2ZW50ID0gJ3BvaW50ZXJkb3duJztcbiAgfSBlbHNlIGlmICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICkge1xuICAgIC8vIFRvdWNoIEV2ZW50cy4gaU9TIFNhZmFyaVxuICAgIHN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCc7XG4gIH1cbiAgZWxlbVsgYmluZE1ldGhvZCBdKCBzdGFydEV2ZW50LCB0aGlzICk7XG59O1xuXG4vLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG4vLyByZXR1cm5zIHRoZSB0b3VjaCB0aGF0IHdlJ3JlIGtlZXBpbmcgdHJhY2sgb2ZcbnByb3RvLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XG4gIGZvciAoIHZhciBpPTA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgaWYgKCB0b3VjaC5pZGVudGlmaWVyID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgICByZXR1cm4gdG91Y2g7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzbWlzcyBjbGlja3MgZnJvbSByaWdodCBvciBtaWRkbGUgYnV0dG9uc1xuICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICBpZiAoIGJ1dHRvbiAmJiAoIGJ1dHRvbiAhPT0gMCAmJiBidXR0b24gIT09IDEgKSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fcG9pbnRlckRvd24oIGV2ZW50LCBldmVudCApO1xufTtcblxucHJvdG8ub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLl9wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gZGlzbWlzcyByaWdodCBjbGljayBhbmQgb3RoZXIgcG9pbnRlcnNcbiAgLy8gYnV0dG9uID0gMCBpcyBva2F5LCAxLTQgbm90XG4gIGlmICggZXZlbnQuYnV0dG9uIHx8IHRoaXMuaXNQb2ludGVyRG93biApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzUG9pbnRlckRvd24gPSB0cnVlO1xuICAvLyBzYXZlIHBvaW50ZXIgaWRlbnRpZmllciB0byBtYXRjaCB1cCB0b3VjaCBldmVudHNcbiAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xuICAgIC8vIHBvaW50ZXJJZCBmb3IgcG9pbnRlciBldmVudHMsIHRvdWNoLmluZGVudGlmaWVyIGZvciB0b3VjaCBldmVudHNcbiAgICBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcblxuICB0aGlzLnBvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xufTtcblxucHJvdG8ucG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XG52YXIgcG9zdFN0YXJ0RXZlbnRzID0ge1xuICBtb3VzZWRvd246IFsgJ21vdXNlbW92ZScsICdtb3VzZXVwJyBdLFxuICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXG4gIHBvaW50ZXJkb3duOiBbICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmNhbmNlbCcgXSxcbn07XG5cbnByb3RvLl9iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoICFldmVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcbiAgdmFyIGV2ZW50cyA9IHBvc3RTdGFydEV2ZW50c1sgZXZlbnQudHlwZSBdO1xuICAvLyBiaW5kIGV2ZW50cyB0byBub2RlXG4gIGV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xuICB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgPSBldmVudHM7XG59O1xuXG5wcm90by5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGZvciBfYm91bmRFdmVudHMsIGluIGNhc2UgZHJhZ0VuZCB0cmlnZ2VyZWQgdHdpY2UgKG9sZCBJRTggYnVnKVxuICBpZiAoICF0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIGRlbGV0ZSB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHM7XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyTW92ZSggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xuICB9XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgbW92ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5wb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIHB1YmxpY1xucHJvdG8ucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG5cbnByb3RvLm9ubW91c2V1cCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcnVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJVcCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hlbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgdG91Y2ggKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG4vLyBwdWJsaWNcbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyVXAnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIHBvaW50ZXIgZG9uZSAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXG5wcm90by5fcG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIHRoaXMuX3VuYmluZFBvc3RTdGFydEV2ZW50cygpO1xuICB0aGlzLnBvaW50ZXJEb25lKCk7XG59O1xuXG5wcm90by5fcG9pbnRlclJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlc2V0IHByb3BlcnRpZXNcbiAgdGhpcy5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xufTtcblxucHJvdG8ucG9pbnRlckRvbmUgPSBub29wO1xuXG4vLyAtLS0tLSBwb2ludGVyIGNhbmNlbCAtLS0tLSAvL1xuXG5wcm90by5vbnBvaW50ZXJjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIHRvdWNoICk7XG4gIH1cbn07XG5cbi8qKlxuICogcG9pbnRlciBjYW5jZWxcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fcG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyQ2FuY2VsKCBldmVudCwgcG9pbnRlciApO1xufTtcblxuLy8gcHVibGljXG5wcm90by5wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIHgveSBjb29yZHMgZnJvbSBldmVudFxuVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQgPSBmdW5jdGlvbiggcG9pbnRlciApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVlcbiAgfTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVW5pcG9pbnRlcjtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/unipointer/unipointer.js\n")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n')},"./src/js/app.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _lazysizes = _interopRequireDefault(__webpack_require__(/*! lazysizes */ \"./node_modules/lazysizes/lazysizes.js\"));\n\nvar _flickity = _interopRequireDefault(__webpack_require__(/*! flickity */ \"./node_modules/flickity/js/index.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.throttle */ \"./node_modules/lodash.throttle/index.js\"));\n\nvar _lodash2 = _interopRequireDefault(__webpack_require__(/*! lodash.debounce */ \"./node_modules/lodash.debounce/index.js\"));\n\nvar _infinitegrid = _interopRequireWildcard(__webpack_require__(/*! @egjs/infinitegrid */ \"./node_modules/@egjs/infinitegrid/dist/infinitegrid.module.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* jshint esversion: 6 */\n__webpack_require__(/*! ../../node_modules/lazysizes/plugins/object-fit/ls.object-fit.js */ \"./node_modules/lazysizes/plugins/object-fit/ls.object-fit.js\");\n\nvar freezeVp = function freezeVp(e) {\n  e.preventDefault();\n};\n\nvar stopBodyScrolling = function stopBodyScrolling(bool) {\n  if (bool === true) {\n    document.body.addEventListener(\"touchmove\", freezeVp, false);\n  } else {\n    document.body.removeEventListener(\"touchmove\", freezeVp, false);\n  }\n};\n\nvar App = {\n  header: null,\n  siteTitle: null,\n  initialize: function initialize() {\n    App.header = document.querySelector(\"header\");\n    App.siteTitle = document.querySelector(\"#site-title\");\n    App.menu = document.getElementById(\"menu\");\n    App.interact.init();\n    App.sizeSet();\n    window.addEventListener('resize', (0, _lodash2.default)(App.sizeSet, 200));\n    document.getElementById(\"loader\").style.display = 'none';\n  },\n  sizeSet: function sizeSet() {\n    var headerT = document.querySelector('.header-template');\n\n    if (headerT) {\n      var max = 0;\n      var components = headerT.querySelectorAll('.template-component');\n      if (components.length == 0) return;\n\n      for (var i = 0; i < components.length; i++) {\n        max = Math.max(max, pageYOffset + components[i].getBoundingClientRect().bottom);\n      }\n\n      headerT.style.minHeight = max - App.header.offsetHeight + 'px';\n    }\n  },\n  interact: {\n    init: function init() {\n      App.interact.linkTargets();\n      App.interact.indexGrid();\n      App.interact.eventTargets();\n      App.interact.embedKirby();\n      App.interact.videoPlayers.init();\n      App.interact.loadSliders();\n    },\n    eventTargets: function eventTargets() {\n      App.interact.menuBurger();\n      var subClick = document.querySelectorAll('[event-target=submenu]');\n\n      for (var i = subClick.length - 1; i >= 0; i--) {\n        subClick[i].addEventListener('click', function (e) {\n          e.currentTarget.parentNode.classList.toggle('opened');\n        });\n      }\n    },\n    linkTargets: function linkTargets() {\n      var links = document.querySelectorAll(\"a\");\n\n      for (var i = 0; i < links.length; i++) {\n        var element = links[i];\n\n        if (element.host !== window.location.host) {\n          element.setAttribute('target', '_blank');\n        } else {\n          element.setAttribute('target', '_self');\n        }\n      }\n    },\n    videoPlayers: {\n      init: function init() {\n        var videos = document.getElementsByClassName('video-container');\n        if (videos.length < 1) return;\n        var hls = [];\n\n        var attachStream = function attachStream(videoElement) {\n          if (videoElement.getAttribute('data-stream') && Hls.isSupported()) {\n            hls[i] = new Hls({\n              minAutoBitrate: 1700000\n            });\n            hls[i].loadSource(videoElement.getAttribute('data-stream'));\n            hls[i].attachMedia(videoElement);\n          }\n        };\n\n        var togglePlay = function togglePlay(videoElement) {\n          if (videoElement.paused) {\n            videoElement.play();\n            videoElement.classList.add('playing');\n          } else {\n            videoElement.pause();\n            videoElement.classList.remove('playing');\n          }\n        };\n\n        var _loop = function _loop() {\n          var videoElement = videos[i].querySelector('video');\n          var videoPlayButton = videos[i].querySelector('.play-button');\n          videoElement.controls = false;\n          attachStream(videoElement);\n          if (videoPlayButton) videoPlayButton.addEventListener('click', function () {\n            togglePlay(videoElement);\n          });\n        };\n\n        for (var i = 0; i < videos.length; i++) {\n          _loop();\n        } // const options = {\n        //   controls: ['play-large'],\n        //   clickToPlay: false,\n        //   iconUrl: _root + \"/assets/images/plyr.svg\"\n        // };\n        // App.players = Array.from(document.querySelectorAll('.js-player')).map(player => new Plyr(player, options));\n\n      },\n      pause: function pause() {\n        for (var i = 0; i < App.players.length; i++) {\n          App.players[i].pause();\n        }\n      }\n    },\n    menuBurger: function menuBurger() {\n      var burger = document.getElementById('burger');\n\n      if (burger) {\n        burger.addEventListener('click', function () {\n          document.body.classList.toggle(\"menu-on\");\n          burger.classList.toggle(\"opened\"); // if (burger.classList.contains(\"opened\")) {\n          //   App.interact.menu.on();\n          // } else {\n          //   App.interact.menu.off();\n          // }\n        });\n      }\n    },\n    menu: {\n      on: function on() {\n        stopBodyScrolling(true);\n        App.container.style.marginBottom = \"0px\";\n        App.menuOver.classList.add('opened');\n        new TimelineLite().set(App.menuOver, {\n          autoAlpha: 1\n        }).fromTo(App.menuOver, 0.5, {\n          yPercent: 100,\n          force3D: true\n        }, {\n          yPercent: 0,\n          force3D: true,\n          ease: Power3.easeInOut\n        });\n      },\n      off: function off() {\n        stopBodyScrolling(false);\n        burger.classList.remove(\"opened\");\n        App.menuOver.classList.remove('opened');\n        new TimelineLite().fromTo(App.menuOver, 0.5, {\n          yPercent: 0,\n          force3D: true\n        }, {\n          yPercent: 100,\n          force3D: true,\n          ease: Power3.easeInOut\n        }).set(App.menuOver, {\n          autoAlpha: 0,\n          onComplete: App.sizeSet\n        });\n      }\n    },\n    embedKirby: function embedKirby() {\n      var pluginEmbedLoadLazyVideo = function pluginEmbedLoadLazyVideo() {\n        var wrapper = this.parentNode;\n        var embed = wrapper.children[0];\n        var script = wrapper.querySelector('script');\n        embed.src = script ? script.getAttribute('data-src') + '&autoplay=1' : embed.getAttribute('data-src') + '&autoplay=1';\n        wrapper.removeChild(this);\n      };\n\n      var thumb = document.getElementsByClassName('embed__thumb');\n\n      for (var i = 0; i < thumb.length; i++) {\n        thumb[i].addEventListener('click', pluginEmbedLoadLazyVideo, false);\n      }\n    },\n    indexGrid: function indexGrid() {\n      var grid = document.getElementById('index-artpieces');\n\n      if (grid) {\n        var ig = new _infinitegrid.default(grid, {\n          horizontal: false\n        });\n        ig.setLayout(_infinitegrid.GridLayout, {\n          margin: 23\n        });\n        var event = document.createEvent('HTMLEvents');\n        event.initEvent('resize', true, false);\n        window.dispatchEvent(event);\n      } // if (grid) {\n      //   var pckry = new Packery(grid, {\n      //     itemSelector: '.artpiece-item',\n      //     gutter: 23\n      //   });\n      // }\n\n    },\n    loadSliders: function loadSliders() {\n      var initFlickity = function initFlickity(element, options) {\n        var slider = new _flickity.default(element, options);\n        slider.slidesCount = slider.slides.length;\n        if (slider.slidesCount < 1) return; // Stop if no slides\n\n        slider.on('change', function () {\n          // $('#slide-number').html((slider.selectedIndex + 1) + '/' + slider.slidesCount);\n          if (this.selectedElement) {\n            var caption = this.element.parentNode.querySelector(\".caption\");\n            if (caption) caption.innerHTML = this.selectedElement.getAttribute(\"data-caption\");\n          }\n\n          var adjCellElems = this.getAdjacentCellElements(1);\n\n          for (var i = 0; i < adjCellElems.length; i++) {\n            var adjCellImgs = adjCellElems[i].querySelectorAll('.lazy:not(.lazyloaded):not(.lazyload)');\n\n            for (var j = 0; j < adjCellImgs.length; j++) {\n              adjCellImgs[j].classList.add('lazyload');\n            }\n          }\n        });\n        slider.on('staticClick', function (event, pointer, cellElement, cellIndex) {\n          if (!cellElement || !Modernizr.touchevents || cellElement.getAttribute('data-media') == \"video\") {\n            return;\n          } else {\n            this.next();\n          }\n        }); // let prevNextButtons = slider.element.querySelectorAll(\".flickity-prev-next-button\");\n        // prevNextButtons.forEach((el) => {\n        //   let cursor = document.createElement('div');\n        //   cursor.className = \"cursor\";\n        //   el.appendChild(cursor);\n        //   el.addEventListener('mousemove', () => {\n        //     if (!Modernizr.touchevents) {\n        //       let rect = el.getBoundingClientRect();\n        //       cursor.style.top = event.pageY - rect.top - window.scrollY + \"px\";\n        //       cursor.style.left = event.pageX - rect.left - window.scrollX + \"px\";\n        //     }\n        //   });\n        // })\n\n        if (slider.selectedElement) {\n          var caption = slider.element.parentNode.querySelector(\".caption\");\n          if (caption) caption.innerHTML = slider.selectedElement.getAttribute(\"data-caption\");\n        }\n      };\n\n      var flickitys = [];\n      var elements = document.getElementsByClassName('slider');\n\n      if (elements.length > 0) {\n        for (var i = 0; i < elements.length; i++) {\n          initFlickity(elements[i], {\n            cellSelector: '.slide',\n            imagesLoaded: true,\n            lazyLoad: 1,\n            autoPlay: Modernizr.touchevents ? 3000 : false,\n            setGallerySize: false,\n            adaptiveHeight: false,\n            percentPosition: true,\n            accessibility: true,\n            wrapAround: true,\n            prevNextButtons: true,\n            pageDots: false,\n            draggable: Modernizr.touchevents,\n            dragThreshold: 30,\n            arrowShape: 'M74.3 99.3L25 50 74.3.7l.7.8L26.5 50 75 98.5z'\n          });\n        }\n      }\n\n      var inlineElements = document.getElementsByClassName('inline-slider');\n\n      if (inlineElements.length > 0) {\n        for (var i = 0; i < inlineElements.length; i++) {\n          initFlickity(inlineElements[i], {\n            cellSelector: '.inline-item',\n            cellAlign: 'left',\n            imagesLoaded: true,\n            lazyLoad: false,\n            autoPlay: Modernizr.touchevents ? 3000 : false,\n            setGallerySize: true,\n            adaptiveHeight: false,\n            percentPosition: true,\n            accessibility: true,\n            wrapAround: true,\n            contain: false,\n            prevNextButtons: true,\n            pageDots: false,\n            draggable: Modernizr.touchevents,\n            dragThreshold: 30,\n            arrowShape: 'M74.3 99.3L25 50 74.3.7l.7.8L26.5 50 75 98.5z'\n          });\n        }\n      }\n    }\n  }\n};\ndocument.addEventListener(\"DOMContentLoaded\", App.initialize);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYXBwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9qcy9hcHAuanM/MDM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5cbmltcG9ydCBsYXp5c2l6ZXMgZnJvbSAnbGF6eXNpemVzJztcbmltcG9ydCBvcHRpbXVteCBmcm9tICdsYXp5c2l6ZXMnO1xucmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2xhenlzaXplcy9wbHVnaW5zL29iamVjdC1maXQvbHMub2JqZWN0LWZpdC5qcycpO1xuaW1wb3J0IEZsaWNraXR5IGZyb20gJ2ZsaWNraXR5Jztcbi8vIGltcG9ydCBQYWNrZXJ5IGZyb20gJ3BhY2tlcnknO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC50aHJvdHRsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCBJbmZpbml0ZUdyaWQsIHtcbiAgR3JpZExheW91dFxufSBmcm9tIFwiQGVnanMvaW5maW5pdGVncmlkXCI7XG5cbmNvbnN0IGZyZWV6ZVZwID0gKGUpID0+IHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuY29uc3Qgc3RvcEJvZHlTY3JvbGxpbmcgPSAoYm9vbCkgPT4ge1xuICBpZiAoYm9vbCA9PT0gdHJ1ZSkge1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmcmVlemVWcCwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmcmVlemVWcCwgZmFsc2UpO1xuICB9XG59O1xuXG5jb25zdCBBcHAgPSB7XG4gIGhlYWRlcjogbnVsbCxcbiAgc2l0ZVRpdGxlOiBudWxsLFxuICBpbml0aWFsaXplOiAoKSA9PiB7XG4gICAgQXBwLmhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIik7XG4gICAgQXBwLnNpdGVUaXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2l0ZS10aXRsZVwiKTtcbiAgICBBcHAubWVudSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWVudVwiKTtcbiAgICBBcHAuaW50ZXJhY3QuaW5pdCgpO1xuICAgIEFwcC5zaXplU2V0KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlKEFwcC5zaXplU2V0LCAyMDApKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRlclwiKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaXplU2V0OiAoKSA9PiB7XG4gICAgY29uc3QgaGVhZGVyVCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXItdGVtcGxhdGUnKTtcblxuICAgIGlmIChoZWFkZXJUKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBoZWFkZXJULnF1ZXJ5U2VsZWN0b3JBbGwoJy50ZW1wbGF0ZS1jb21wb25lbnQnKTtcbiAgICAgIGlmKGNvbXBvbmVudHMubGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHBhZ2VZT2Zmc2V0ICsgY29tcG9uZW50c1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pO1xuICAgICAgfVxuICAgICAgaGVhZGVyVC5zdHlsZS5taW5IZWlnaHQgPSBtYXggLSBBcHAuaGVhZGVyLm9mZnNldEhlaWdodCArICdweCdcbiAgICB9XG5cblxuICB9LFxuICBpbnRlcmFjdDoge1xuICAgIGluaXQ6ICgpID0+IHtcbiAgICAgIEFwcC5pbnRlcmFjdC5saW5rVGFyZ2V0cygpXG4gICAgICBBcHAuaW50ZXJhY3QuaW5kZXhHcmlkKClcbiAgICAgIEFwcC5pbnRlcmFjdC5ldmVudFRhcmdldHMoKVxuICAgICAgQXBwLmludGVyYWN0LmVtYmVkS2lyYnkoKVxuICAgICAgQXBwLmludGVyYWN0LnZpZGVvUGxheWVycy5pbml0KClcbiAgICAgIEFwcC5pbnRlcmFjdC5sb2FkU2xpZGVycygpXG4gICAgfSxcbiAgICBldmVudFRhcmdldHM6ICgpID0+IHtcbiAgICAgIEFwcC5pbnRlcmFjdC5tZW51QnVyZ2VyKClcbiAgICAgIGNvbnN0IHN1YkNsaWNrID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2V2ZW50LXRhcmdldD1zdWJtZW51XScpO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3ViQ2xpY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3ViQ2xpY2tbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgIGUuY3VycmVudFRhcmdldC5wYXJlbnROb2RlLmNsYXNzTGlzdC50b2dnbGUoJ29wZW5lZCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbmtUYXJnZXRzOiAoKSA9PiB7XG4gICAgICBjb25zdCBsaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJhXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbGlua3NbaV07XG4gICAgICAgIGlmIChlbGVtZW50Lmhvc3QgIT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0KSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19zZWxmJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZGVvUGxheWVyczoge1xuICAgICAgaW5pdDogKCkgPT4ge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd2aWRlby1jb250YWluZXInKTtcbiAgICAgICAgaWYgKHZpZGVvcy5sZW5ndGggPCAxKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgaGxzID0gW107XG5cbiAgICAgICAgY29uc3QgYXR0YWNoU3RyZWFtID0gKHZpZGVvRWxlbWVudCkgPT4ge1xuICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0cmVhbScpICYmIEhscy5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICBobHNbaV0gPSBuZXcgSGxzKHtcbiAgICAgICAgICAgICAgbWluQXV0b0JpdHJhdGU6IDE3MDAwMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGxzW2ldLmxvYWRTb3VyY2UodmlkZW9FbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdHJlYW0nKSk7XG4gICAgICAgICAgICBobHNbaV0uYXR0YWNoTWVkaWEodmlkZW9FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZVBsYXkgPSAodmlkZW9FbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5wYXVzZWQpIHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgncGxheWluZycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdwbGF5aW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlkZW9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdmlkZW9zW2ldLnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgY29uc3QgdmlkZW9QbGF5QnV0dG9uID0gdmlkZW9zW2ldLnF1ZXJ5U2VsZWN0b3IoJy5wbGF5LWJ1dHRvbicpO1xuICAgICAgICAgIHZpZGVvRWxlbWVudC5jb250cm9scyA9IGZhbHNlO1xuICAgICAgICAgIGF0dGFjaFN0cmVhbSh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgIGlmICh2aWRlb1BsYXlCdXR0b24pXG4gICAgICAgICAgICB2aWRlb1BsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRvZ2dsZVBsYXkodmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgLy8gICBjb250cm9sczogWydwbGF5LWxhcmdlJ10sXG4gICAgICAgIC8vICAgY2xpY2tUb1BsYXk6IGZhbHNlLFxuICAgICAgICAvLyAgIGljb25Vcmw6IF9yb290ICsgXCIvYXNzZXRzL2ltYWdlcy9wbHlyLnN2Z1wiXG4gICAgICAgIC8vIH07XG4gICAgICAgIC8vIEFwcC5wbGF5ZXJzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtcGxheWVyJykpLm1hcChwbGF5ZXIgPT4gbmV3IFBseXIocGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICAgIH0sXG4gICAgICBwYXVzZTogKCkgPT4ge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEFwcC5wbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgQXBwLnBsYXllcnNbaV0ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWVudUJ1cmdlcjogKCkgPT4ge1xuICAgICAgY29uc3QgYnVyZ2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1cmdlcicpO1xuICAgICAgaWYgKGJ1cmdlcikge1xuICAgICAgICBidXJnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKFwibWVudS1vblwiKTtcbiAgICAgICAgICBidXJnZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm9wZW5lZFwiKTtcblxuICAgICAgICAgIC8vIGlmIChidXJnZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3BlbmVkXCIpKSB7XG4gICAgICAgICAgLy8gICBBcHAuaW50ZXJhY3QubWVudS5vbigpO1xuICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICBBcHAuaW50ZXJhY3QubWVudS5vZmYoKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWVudToge1xuICAgICAgb246ICgpID0+IHtcbiAgICAgICAgc3RvcEJvZHlTY3JvbGxpbmcodHJ1ZSk7XG4gICAgICAgIEFwcC5jb250YWluZXIuc3R5bGUubWFyZ2luQm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgQXBwLm1lbnVPdmVyLmNsYXNzTGlzdC5hZGQoJ29wZW5lZCcpO1xuICAgICAgICBuZXcgVGltZWxpbmVMaXRlKCkuc2V0KEFwcC5tZW51T3Zlciwge1xuICAgICAgICAgIGF1dG9BbHBoYTogMSxcbiAgICAgICAgfSkuZnJvbVRvKEFwcC5tZW51T3ZlciwgMC41LCB7XG4gICAgICAgICAgeVBlcmNlbnQ6IDEwMCxcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeVBlcmNlbnQ6IDAsXG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZSxcbiAgICAgICAgICBlYXNlOiBQb3dlcjMuZWFzZUluT3V0XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9mZjogKCkgPT4ge1xuICAgICAgICBzdG9wQm9keVNjcm9sbGluZyhmYWxzZSk7XG4gICAgICAgIGJ1cmdlci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlbmVkXCIpO1xuICAgICAgICBBcHAubWVudU92ZXIuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XG4gICAgICAgIG5ldyBUaW1lbGluZUxpdGUoKS5mcm9tVG8oQXBwLm1lbnVPdmVyLCAwLjUsIHtcbiAgICAgICAgICB5UGVyY2VudDogMCxcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeVBlcmNlbnQ6IDEwMCxcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlLFxuICAgICAgICAgIGVhc2U6IFBvd2VyMy5lYXNlSW5PdXRcbiAgICAgICAgfSkuc2V0KEFwcC5tZW51T3Zlciwge1xuICAgICAgICAgIGF1dG9BbHBoYTogMCxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBBcHAuc2l6ZVNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtYmVkS2lyYnk6ICgpID0+IHtcbiAgICAgIHZhciBwbHVnaW5FbWJlZExvYWRMYXp5VmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBlbWJlZCA9IHdyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBzY3JpcHQgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCcpO1xuICAgICAgICBlbWJlZC5zcmMgPSBzY3JpcHQgPyBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpICsgJyZhdXRvcGxheT0xJyA6IGVtYmVkLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSArICcmYXV0b3BsYXk9MSc7XG4gICAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGh1bWIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdlbWJlZF9fdGh1bWInKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aHVtYi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aHVtYltpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHBsdWdpbkVtYmVkTG9hZExhenlWaWRlbywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5kZXhHcmlkOiAoKSA9PiB7XG4gICAgICBjb25zdCBncmlkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luZGV4LWFydHBpZWNlcycpO1xuXG4gICAgICBpZiAoZ3JpZCkge1xuICAgICAgICBjb25zdCBpZyA9IG5ldyBJbmZpbml0ZUdyaWQoZ3JpZCwge1xuICAgICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWcuc2V0TGF5b3V0KEdyaWRMYXlvdXQsIHtcbiAgICAgICAgICBtYXJnaW46IDIzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgncmVzaXplJywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIChncmlkKSB7XG4gICAgICAvLyAgIHZhciBwY2tyeSA9IG5ldyBQYWNrZXJ5KGdyaWQsIHtcbiAgICAgIC8vICAgICBpdGVtU2VsZWN0b3I6ICcuYXJ0cGllY2UtaXRlbScsXG4gICAgICAvLyAgICAgZ3V0dGVyOiAyM1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vIH1cblxuICAgIH0sXG4gICAgbG9hZFNsaWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRGbGlja2l0eSA9IChlbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIHZhciBzbGlkZXIgPSBuZXcgRmxpY2tpdHkoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIHNsaWRlci5zbGlkZXNDb3VudCA9IHNsaWRlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgICBpZiAoc2xpZGVyLnNsaWRlc0NvdW50IDwgMSkgcmV0dXJuOyAvLyBTdG9wIGlmIG5vIHNsaWRlc1xuICAgICAgICBzbGlkZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vICQoJyNzbGlkZS1udW1iZXInKS5odG1sKChzbGlkZXIuc2VsZWN0ZWRJbmRleCArIDEpICsgJy8nICsgc2xpZGVyLnNsaWRlc0NvdW50KTtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLmNhcHRpb25cIik7XG4gICAgICAgICAgICBpZiAoY2FwdGlvbilcbiAgICAgICAgICAgICAgY2FwdGlvbi5pbm5lckhUTUwgPSB0aGlzLnNlbGVjdGVkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcHRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZGpDZWxsRWxlbXMgPSB0aGlzLmdldEFkamFjZW50Q2VsbEVsZW1lbnRzKDEpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRqQ2VsbEVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYWRqQ2VsbEltZ3MgPSBhZGpDZWxsRWxlbXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLmxhenk6bm90KC5sYXp5bG9hZGVkKTpub3QoLmxhenlsb2FkKScpXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFkakNlbGxJbWdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGFkakNlbGxJbWdzW2pdLmNsYXNzTGlzdC5hZGQoJ2xhenlsb2FkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzbGlkZXIub24oJ3N0YXRpY0NsaWNrJywgZnVuY3Rpb24oZXZlbnQsIHBvaW50ZXIsIGNlbGxFbGVtZW50LCBjZWxsSW5kZXgpIHtcbiAgICAgICAgICBpZiAoIWNlbGxFbGVtZW50IHx8ICFNb2Rlcm5penIudG91Y2hldmVudHMgfHwgY2VsbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1lZGlhJykgPT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGxldCBwcmV2TmV4dEJ1dHRvbnMgPSBzbGlkZXIuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmZsaWNraXR5LXByZXYtbmV4dC1idXR0b25cIik7XG4gICAgICAgIC8vIHByZXZOZXh0QnV0dG9ucy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAvLyAgIGxldCBjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgLy8gICBjdXJzb3IuY2xhc3NOYW1lID0gXCJjdXJzb3JcIjtcbiAgICAgICAgLy8gICBlbC5hcHBlbmRDaGlsZChjdXJzb3IpO1xuICAgICAgICAvLyAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsICgpID0+IHtcbiAgICAgICAgLy8gICAgIGlmICghTW9kZXJuaXpyLnRvdWNoZXZlbnRzKSB7XG4gICAgICAgIC8vICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vICAgICAgIGN1cnNvci5zdHlsZS50b3AgPSBldmVudC5wYWdlWSAtIHJlY3QudG9wIC0gd2luZG93LnNjcm9sbFkgKyBcInB4XCI7XG4gICAgICAgIC8vICAgICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gZXZlbnQucGFnZVggLSByZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCArIFwicHhcIjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICB9KTtcblxuICAgICAgICAvLyB9KVxuICAgICAgICBpZiAoc2xpZGVyLnNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGNhcHRpb24gPSBzbGlkZXIuZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXCIuY2FwdGlvblwiKTtcbiAgICAgICAgICBpZiAoY2FwdGlvbilcbiAgICAgICAgICAgIGNhcHRpb24uaW5uZXJIVE1MID0gc2xpZGVyLnNlbGVjdGVkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmbGlja2l0eXMgPSBbXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NsaWRlcicpO1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluaXRGbGlja2l0eShlbGVtZW50c1tpXSwge1xuICAgICAgICAgICAgY2VsbFNlbGVjdG9yOiAnLnNsaWRlJyxcbiAgICAgICAgICAgIGltYWdlc0xvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGxhenlMb2FkOiAxLFxuICAgICAgICAgICAgYXV0b1BsYXk6IE1vZGVybml6ci50b3VjaGV2ZW50cyA/IDMwMDAgOiBmYWxzZSxcbiAgICAgICAgICAgIHNldEdhbGxlcnlTaXplOiBmYWxzZSxcbiAgICAgICAgICAgIGFkYXB0aXZlSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIHBlcmNlbnRQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kOiB0cnVlLFxuICAgICAgICAgICAgcHJldk5leHRCdXR0b25zOiB0cnVlLFxuICAgICAgICAgICAgcGFnZURvdHM6IGZhbHNlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBNb2Rlcm5penIudG91Y2hldmVudHMsXG4gICAgICAgICAgICBkcmFnVGhyZXNob2xkOiAzMCxcbiAgICAgICAgICAgIGFycm93U2hhcGU6ICdNNzQuMyA5OS4zTDI1IDUwIDc0LjMuN2wuNy44TDI2LjUgNTAgNzUgOTguNXonXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbmxpbmVFbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2lubGluZS1zbGlkZXInKTtcbiAgICAgIGlmIChpbmxpbmVFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5saW5lRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpbml0RmxpY2tpdHkoaW5saW5lRWxlbWVudHNbaV0sIHtcbiAgICAgICAgICAgIGNlbGxTZWxlY3RvcjogJy5pbmxpbmUtaXRlbScsXG4gICAgICAgICAgICBjZWxsQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgIGltYWdlc0xvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGxhenlMb2FkOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9QbGF5OiBNb2Rlcm5penIudG91Y2hldmVudHMgPyAzMDAwIDogZmFsc2UsXG4gICAgICAgICAgICBzZXRHYWxsZXJ5U2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFkYXB0aXZlSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIHBlcmNlbnRQb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICB3cmFwQXJvdW5kOiB0cnVlLFxuICAgICAgICAgICAgY29udGFpbjogZmFsc2UsXG4gICAgICAgICAgICBwcmV2TmV4dEJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgICBwYWdlRG90czogZmFsc2UsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IE1vZGVybml6ci50b3VjaGV2ZW50cyxcbiAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IDMwLFxuICAgICAgICAgICAgYXJyb3dTaGFwZTogJ003NC4zIDk5LjNMMjUgNTAgNzQuMy43bC43LjhMMjYuNSA1MCA3NSA5OC41eidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBBcHAuaW5pdGlhbGl6ZSk7Il0sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQVZBO0FBSUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBakNBO0FBQ0E7QUF3QkE7QUFBQTtBQVNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakRBO0FBbURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFGQTtBQUlBO0FBL0JBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFwUUE7QUEzQkE7QUFtU0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/app.js\n")}});